{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ProjectionExpressions.html\n// Import standard error handler\nconst utils_1 = require(\"./utils\");\nconst checkAttribute_1 = __importDefault(require(\"./checkAttribute\"));\nexports.default = (attributes, table, entity, type = false) => {\n  // Create an attribute names counter\n  let index = 0;\n  // If attributes isn't an array, make it one\n  const attrs = Array.isArray(attributes) ? attributes\n  // support simple string list\n  : typeof attributes === 'string' ? attributes.split(',').map(x => x.trim()) : [attributes];\n  // Check that table is valid and contains attributes\n  if (!table || !table.Table || Object.keys(table.Table.attributes).length == 0) {\n    utils_1.error(`Tables must be valid and contain attributes`);\n  } // end check table\n  // Add entityField if exists\n  if (type && table.Table.entityField) attrs.push(table.Table.entityField);\n  // Default collectors\n  let names = {};\n  let tableAttrs = [];\n  let entities = {};\n  // Loop through the attributes and add to the map\n  for (const attribute of attrs) {\n    // If a string\n    if (typeof attribute === 'string') {\n      // Check single attribute and merge results\n      const attr = checkAttribute_1.default(attribute, entity ? table[entity].schema.attributes : table.Table.attributes);\n      if (!Object.values(names).includes(attr)) {\n        names[`#proj${++index}`] = attr;\n        tableAttrs.push(attribute);\n      } // end if\n    } else if (typeof attribute === 'object') {\n      // If an object, loop through keys\n      for (const entity in attribute) {\n        // Check that the entity name exists\n        if (table[entity]) {\n          // Track entity attributes\n          if (!entities[entity]) entities[entity] = [];\n          // If attributes isn't an array, make it one\n          const ent_attrs = Array.isArray(attribute[entity]) ? attribute[entity]\n          // support simple string list\n          : typeof attribute[entity] === 'string' ? String(attribute[entity]).split(',').map(x => x.trim()) : utils_1.error(`Only arrays or strings are supported`);\n          // Loop entity projections\n          for (const ent_attribute of ent_attrs) {\n            // Check for string type\n            if (typeof ent_attribute != 'string') utils_1.error(`Entity projections must be string values`);\n            // Check the attribute and merge results\n            const attr = checkAttribute_1.default(ent_attribute, table[entity].schema.attributes);\n            if (!Object.values(names).includes(attr)) {\n              names[`#proj${++index}`] = attr;\n            } // end if\n            entities[entity].push(attr);\n          } // end for\n        } else {\n          utils_1.error(`'${entity}' is not a valid entity on this table`);\n        } // end if valid entity\n      } // end for loop\n      // Throw error if invalid type\n    } else {\n      utils_1.error(`'${typeof attribute}' is an invalid type. Projections require strings or arrays`);\n    }\n  } // end for\n  return {\n    names,\n    projections: Object.keys(names).join(','),\n    entities: Object.keys(entities).reduce((acc, ent) => {\n      return Object.assign(acc, {\n        [ent]: [...new Set([...entities[ent], ...tableAttrs])]\n      });\n    }, {}),\n    tableAttrs\n  };\n}; // end module","map":{"version":3,"names":["__importDefault","undefined","mod","__esModule","Object","defineProperty","exports","value","utils_1","require","checkAttribute_1","default","attributes","table","entity","type","index","attrs","Array","isArray","split","map","x","trim","Table","keys","length","error","entityField","push","names","tableAttrs","entities","attribute","attr","schema","values","includes","ent_attrs","String","ent_attribute","projections","join","reduce","acc","ent","assign","Set"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/projectionBuilder.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ProjectionExpressions.html\n// Import standard error handler\nconst utils_1 = require(\"./utils\");\nconst checkAttribute_1 = __importDefault(require(\"./checkAttribute\"));\nexports.default = (attributes, table, entity, type = false) => {\n    // Create an attribute names counter\n    let index = 0;\n    // If attributes isn't an array, make it one\n    const attrs = Array.isArray(attributes) ? attributes\n        // support simple string list\n        : typeof attributes === 'string' ? attributes.split(',').map(x => x.trim())\n            : [attributes];\n    // Check that table is valid and contains attributes\n    if (!table\n        || !table.Table\n        || Object.keys(table.Table.attributes).length == 0) {\n        utils_1.error(`Tables must be valid and contain attributes`);\n    } // end check table\n    // Add entityField if exists\n    if (type && table.Table.entityField)\n        attrs.push(table.Table.entityField);\n    // Default collectors\n    let names = {};\n    let tableAttrs = [];\n    let entities = {};\n    // Loop through the attributes and add to the map\n    for (const attribute of attrs) {\n        // If a string\n        if (typeof attribute === 'string') {\n            // Check single attribute and merge results\n            const attr = checkAttribute_1.default(attribute, (entity ? table[entity].schema.attributes : table.Table.attributes));\n            if (!Object.values(names).includes(attr)) {\n                names[`#proj${++index}`] = attr;\n                tableAttrs.push(attribute);\n            } // end if\n        }\n        else if (typeof attribute === 'object') {\n            // If an object, loop through keys\n            for (const entity in attribute) {\n                // Check that the entity name exists\n                if (table[entity]) {\n                    // Track entity attributes\n                    if (!entities[entity])\n                        entities[entity] = [];\n                    // If attributes isn't an array, make it one\n                    const ent_attrs = Array.isArray(attribute[entity]) ? attribute[entity]\n                        // support simple string list\n                        : typeof attribute[entity] === 'string' ? String(attribute[entity]).split(',').map(x => x.trim())\n                            : utils_1.error(`Only arrays or strings are supported`);\n                    // Loop entity projections\n                    for (const ent_attribute of ent_attrs) {\n                        // Check for string type\n                        if (typeof ent_attribute != 'string')\n                            utils_1.error(`Entity projections must be string values`);\n                        // Check the attribute and merge results\n                        const attr = checkAttribute_1.default(ent_attribute, table[entity].schema.attributes);\n                        if (!Object.values(names).includes(attr)) {\n                            names[`#proj${++index}`] = attr;\n                        } // end if\n                        entities[entity].push(attr);\n                    } // end for\n                }\n                else {\n                    utils_1.error(`'${entity}' is not a valid entity on this table`);\n                } // end if valid entity\n            } // end for loop\n            // Throw error if invalid type\n        }\n        else {\n            utils_1.error(`'${typeof attribute}' is an invalid type. Projections require strings or arrays`);\n        }\n    } // end for\n    return {\n        names,\n        projections: Object.keys(names).join(','),\n        entities: Object.keys(entities).reduce((acc, ent) => {\n            return Object.assign(acc, { [ent]: [...new Set([...entities[ent], ...tableAttrs])] });\n        }, {}),\n        tableAttrs\n    };\n}; // end module\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}