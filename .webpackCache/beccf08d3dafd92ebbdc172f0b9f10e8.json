{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationError = exports.validateRuleTree = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n *\n * @param ruleTree\n *\n * Validates the rule tree declaration by checking references of rule\n * functions. We deem rule tree valid if no two rules with the same name point\n * to different rules.\n *\n */\nfunction validateRuleTree(ruleTree) {\n  const rules = extractRules(ruleTree);\n  const valid = rules.reduce(({\n    map,\n    duplicates\n  }, rule) => {\n    if (!map.has(rule.name)) {\n      return {\n        map: map.set(rule.name, rule),\n        duplicates\n      };\n    } else if (!map.get(rule.name).equals(rule) && !duplicates.includes(rule.name)) {\n      return {\n        map: map.set(rule.name, rule),\n        duplicates: [...duplicates, rule.name]\n      };\n    } else {\n      return {\n        map,\n        duplicates\n      };\n    }\n  }, {\n    map: new Map(),\n    duplicates: []\n  });\n  if (valid.duplicates.length === 0) {\n    return {\n      status: 'ok'\n    };\n  } else {\n    const duplicates = valid.duplicates.join(', ');\n    return {\n      status: 'err',\n      message: `There seem to be multiple definitions of these rules: ${duplicates}`\n    };\n  }\n  /* Helper functions */\n  /**\n   *\n   * @param ruleTree\n   *\n   * Extracts rules from rule tree.\n   *\n   */\n  function extractRules(ruleTree) {\n    const resolvers = utils_1.flattenObjectOf(ruleTree, utils_1.isRuleFunction);\n    const rules = resolvers.reduce((rules, rule) => {\n      if (utils_1.isLogicRule(rule)) {\n        return [...rules, ...extractLogicRules(rule)];\n      } else {\n        return [...rules, rule];\n      }\n    }, []);\n    return rules;\n  }\n  /**\n   *\n   * Recursively extracts Rules from LogicRule\n   *\n   * @param rule\n   */\n  function extractLogicRules(rule) {\n    return rule.getRules().reduce((acc, shieldRule) => {\n      if (utils_1.isLogicRule(shieldRule)) {\n        return [...acc, ...extractLogicRules(shieldRule)];\n      } else {\n        return [...acc, shieldRule];\n      }\n    }, []);\n  }\n}\nexports.validateRuleTree = validateRuleTree;\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nexports.ValidationError = ValidationError;","map":{"version":3,"mappings":";;;;;;AACA,MAAAA,OAAA,GAAAC,OAAA;AAEA;;;;;;;;;AASA,SAAgBC,gBAAgBA,CAC9BC,QAAgB;EAEhB,MAAMC,KAAK,GAAGC,YAAY,CAACF,QAAQ,CAAC;EAEpC,MAAMG,KAAK,GAAGF,KAAK,CAACG,MAAM,CACxB,CAAC;IAAEC,GAAG;IAAEC;EAAU,CAAE,EAAEC,IAAI,KAAI;IAC5B,IAAI,CAACF,GAAG,CAACG,GAAG,CAACD,IAAI,CAACE,IAAI,CAAC,EAAE;MACvB,OAAO;QAAEJ,GAAG,EAAEA,GAAG,CAACK,GAAG,CAACH,IAAI,CAACE,IAAI,EAAEF,IAAI,CAAC;QAAED;MAAU,CAAE;KACrD,MAAM,IACL,CAACD,GAAG,CAACM,GAAG,CAACJ,IAAI,CAACE,IAAI,CAAE,CAACG,MAAM,CAACL,IAAI,CAAC,IACjC,CAACD,UAAU,CAACO,QAAQ,CAACN,IAAI,CAACE,IAAI,CAAC,EAC/B;MACA,OAAO;QACLJ,GAAG,EAAEA,GAAG,CAACK,GAAG,CAACH,IAAI,CAACE,IAAI,EAAEF,IAAI,CAAC;QAC7BD,UAAU,EAAE,CAAC,GAAGA,UAAU,EAAEC,IAAI,CAACE,IAAI;OACtC;KACF,MAAM;MACL,OAAO;QAAEJ,GAAG;QAAEC;MAAU,CAAE;;EAE9B,CAAC,EACD;IAAED,GAAG,EAAE,IAAIS,GAAG,EAAiB;IAAER,UAAU,EAAE;EAAE,CAAE,CAClD;EAED,IAAIH,KAAK,CAACG,UAAU,CAACS,MAAM,KAAK,CAAC,EAAE;IACjC,OAAO;MAAEC,MAAM,EAAE;IAAI,CAAE;GACxB,MAAM;IACL,MAAMV,UAAU,GAAGH,KAAK,CAACG,UAAU,CAACW,IAAI,CAAC,IAAI,CAAC;IAC9C,OAAO;MACLD,MAAM,EAAE,KAAK;MACbE,OAAO,EAAE,yDAAyDZ,UAAU;KAC7E;;EAGH;EACA;;;;;;;EAOA,SAASJ,YAAYA,CAACF,QAAgB;IACpC,MAAMmB,SAAS,GAAGtB,OAAA,CAAAuB,eAAe,CAAapB,QAAQ,EAAEH,OAAA,CAAAwB,cAAc,CAAC;IAEvE,MAAMpB,KAAK,GAAGkB,SAAS,CAACf,MAAM,CAAU,CAACH,KAAK,EAAEM,IAAI,KAAI;MACtD,IAAIV,OAAA,CAAAyB,WAAW,CAACf,IAAI,CAAC,EAAE;QACrB,OAAO,CAAC,GAAGN,KAAK,EAAE,GAAGsB,iBAAiB,CAAChB,IAAI,CAAC,CAAC;OAC9C,MAAM;QACL,OAAO,CAAC,GAAGN,KAAK,EAAEM,IAAI,CAAC;;IAE3B,CAAC,EAAE,EAAE,CAAC;IAEN,OAAON,KAAK;EACd;EAEA;;;;;;EAMA,SAASsB,iBAAiBA,CAAChB,IAAgB;IACzC,OAAOA,IAAI,CAACiB,QAAQ,EAAE,CAACpB,MAAM,CAAU,CAACqB,GAAG,EAAEC,UAAU,KAAI;MACzD,IAAI7B,OAAA,CAAAyB,WAAW,CAACI,UAAU,CAAC,EAAE;QAC3B,OAAO,CAAC,GAAGD,GAAG,EAAE,GAAGF,iBAAiB,CAACG,UAAU,CAAC,CAAC;OAClD,MAAM;QACL,OAAO,CAAC,GAAGD,GAAG,EAAEC,UAAU,CAAC;;IAE/B,CAAC,EAAE,EAAE,CAAC;EACR;AACF;AAvEAC,OAAA,CAAA5B,gBAAA,GAAAA,gBAAA;AAyEA,MAAa6B,eAAgB,SAAQC,KAAK;EACxCC,YAAYZ,OAAe;IACzB,KAAK,CAACA,OAAO,CAAC;EAChB;;AAHFS,OAAA,CAAAC,eAAA,GAAAA,eAAA","names":["utils_1","require","validateRuleTree","ruleTree","rules","extractRules","valid","reduce","map","duplicates","rule","has","name","set","get","equals","includes","Map","length","status","join","message","resolvers","flattenObjectOf","isRuleFunction","isLogicRule","extractLogicRules","getRules","acc","shieldRule","exports","ValidationError","Error","constructor"],"sourceRoot":"","sources":["../src/validation.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}