{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.operationToDocument = exports.parseSelectionSet = exports.parseOperation = exports.operationFromDocument = exports.FragmentSelection = exports.FieldSelection = exports.selectionOfElement = exports.selectionSetOfElement = exports.selectionSetOf = exports.allFieldDefinitionsInSelectionSet = exports.MutableSelectionSet = exports.SelectionSetUpdates = exports.SelectionSet = exports.ContainsResult = exports.NamedFragments = exports.NamedFragmentDefinition = exports.Operation = exports.concatOperationPaths = exports.conditionalDirectivesInOperationPath = exports.sameOperationPaths = exports.operationPathToStringPath = exports.FragmentElement = exports.Field = void 0;\nconst graphql_1 = require(\"graphql\");\nconst definitions_1 = require(\"./definitions\");\nconst federation_1 = require(\"./federation\");\nconst error_1 = require(\"./error\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst values_1 = require(\"./values\");\nconst uuid_1 = require(\"uuid\");\nfunction validate(condition, message, sourceAST) {\n  if (!condition) {\n    throw error_1.ERRORS.INVALID_GRAPHQL.err(message(), {\n      nodes: sourceAST\n    });\n  }\n}\nfunction haveSameDirectives(op1, op2) {\n  return (0, definitions_1.sameDirectiveApplications)(op1.appliedDirectives, op2.appliedDirectives);\n}\nclass AbstractOperationElement extends definitions_1.DirectiveTargetElement {\n  constructor(schema, directives) {\n    super(schema, directives);\n  }\n  collectVariables(collector) {\n    this.collectVariablesInElement(collector);\n    this.collectVariablesInAppliedDirectives(collector);\n  }\n  rebaseOnOrError(parentType) {\n    return this.rebaseOn({\n      parentType,\n      errorIfCannotRebase: true\n    });\n  }\n  addAttachement(key, value) {\n    if (!this.attachements) {\n      this.attachements = new Map();\n    }\n    this.attachements.set(key, value);\n  }\n  getAttachement(key) {\n    var _a;\n    return (_a = this.attachements) === null || _a === void 0 ? void 0 : _a.get(key);\n  }\n  copyAttachementsTo(elt) {\n    if (this.attachements) {\n      for (const [k, v] of this.attachements.entries()) {\n        elt.addAttachement(k, v);\n      }\n    }\n  }\n  keyForDirectives() {\n    return this.appliedDirectives.map(d => keyForDirective(d)).join(' ');\n  }\n}\nclass Field extends AbstractOperationElement {\n  constructor(definition, args, directives, alias) {\n    super(definition.schema(), directives);\n    this.definition = definition;\n    this.args = args;\n    this.alias = alias;\n    this.kind = 'Field';\n  }\n  collectVariablesInElement(collector) {\n    if (this.args) {\n      collector.collectInArguments(this.args);\n    }\n  }\n  get name() {\n    return this.definition.name;\n  }\n  argumentValue(name) {\n    return this.args ? this.args[name] : undefined;\n  }\n  responseName() {\n    return this.alias ? this.alias : this.name;\n  }\n  key() {\n    return this.responseName() + this.keyForDirectives();\n  }\n  asPathElement() {\n    return this.responseName();\n  }\n  get parentType() {\n    return this.definition.parent;\n  }\n  isLeafField() {\n    return (0, definitions_1.isLeafType)(this.baseType());\n  }\n  baseType() {\n    return (0, definitions_1.baseType)(this.definition.type);\n  }\n  withUpdatedDefinition(newDefinition) {\n    const newField = new Field(newDefinition, this.args, this.appliedDirectives, this.alias);\n    this.copyAttachementsTo(newField);\n    return newField;\n  }\n  withUpdatedAlias(newAlias) {\n    const newField = new Field(this.definition, this.args, this.appliedDirectives, newAlias);\n    this.copyAttachementsTo(newField);\n    return newField;\n  }\n  withUpdatedDirectives(newDirectives) {\n    const newField = new Field(this.definition, this.args, newDirectives, this.alias);\n    this.copyAttachementsTo(newField);\n    return newField;\n  }\n  argumentsToNodes() {\n    if (!this.args) {\n      return undefined;\n    }\n    const entries = Object.entries(this.args);\n    if (entries.length === 0) {\n      return undefined;\n    }\n    return entries.map(([n, v]) => {\n      return {\n        kind: graphql_1.Kind.ARGUMENT,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: n\n        },\n        value: (0, values_1.valueToAST)(v, this.definition.argument(n).type)\n      };\n    });\n  }\n  appliesTo(type) {\n    const definition = type.field(this.name);\n    return !!definition && this.selects(definition);\n  }\n  selects(definition, assumeValid = false, variableDefinitions) {\n    (0, utils_1.assert)(assumeValid || variableDefinitions, 'Must provide variable definitions if validation is needed');\n    if (definition === this.definition) {\n      return true;\n    }\n    if (this.name !== definition.name) {\n      return false;\n    }\n    for (const argDef of definition.arguments()) {\n      const appliedValue = this.argumentValue(argDef.name);\n      if (appliedValue === undefined) {\n        if (argDef.defaultValue === undefined && !(0, definitions_1.isNullableType)(argDef.type)) {\n          return false;\n        }\n      } else {\n        if (!assumeValid && !(0, values_1.isValidValue)(appliedValue, argDef, variableDefinitions)) {\n          return false;\n        }\n      }\n    }\n    if (!assumeValid && this.args) {\n      for (const [name, value] of Object.entries(this.args)) {\n        if (value !== null && definition.argument(name) === undefined) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  validate(variableDefinitions) {\n    validate(this.name === this.definition.name, () => `Field name \"${this.name}\" cannot select field \"${this.definition.coordinate}: name mismatch\"`);\n    for (const argDef of this.definition.arguments()) {\n      const appliedValue = this.argumentValue(argDef.name);\n      if (appliedValue === undefined) {\n        validate(argDef.defaultValue !== undefined || (0, definitions_1.isNullableType)(argDef.type), () => `Missing mandatory value for argument \"${argDef.name}\" of field \"${this.definition.coordinate}\" in selection \"${this}\"`);\n      } else {\n        validate((0, values_1.isValidValue)(appliedValue, argDef, variableDefinitions), () => `Invalid value ${(0, values_1.valueToString)(appliedValue)} for argument \"${argDef.coordinate}\" of type ${argDef.type}`);\n      }\n    }\n    if (this.args) {\n      for (const [name, value] of Object.entries(this.args)) {\n        validate(value === null || this.definition.argument(name) !== undefined, () => `Unknown argument \"${name}\" in field application of \"${this.name}\"`);\n      }\n    }\n  }\n  rebaseOn({\n    parentType,\n    errorIfCannotRebase\n  }) {\n    const fieldParent = this.definition.parent;\n    if (parentType === fieldParent) {\n      return this;\n    }\n    if (this.name === definitions_1.typenameFieldName) {\n      return this.withUpdatedDefinition(parentType.typenameField());\n    }\n    const fieldDef = parentType.field(this.name);\n    const canRebase = this.canRebaseOn(parentType) && fieldDef;\n    if (!canRebase) {\n      validate(!errorIfCannotRebase, () => `Cannot add selection of field \"${this.definition.coordinate}\" to selection set of parent type \"${parentType}\"`);\n      return undefined;\n    }\n    return this.withUpdatedDefinition(fieldDef);\n  }\n  canRebaseOn(parentType) {\n    const fieldParentType = this.definition.parent;\n    return parentType.name === fieldParentType.name || (0, definitions_1.isInterfaceType)(fieldParentType) || (0, federation_1.isInterfaceObjectType)(fieldParentType);\n  }\n  typeIfAddedTo(parentType) {\n    var _a, _b;\n    const fieldParentType = this.definition.parent;\n    if (parentType == fieldParentType) {\n      return this.definition.type;\n    }\n    if (this.name === definitions_1.typenameFieldName) {\n      return (_a = parentType.typenameField()) === null || _a === void 0 ? void 0 : _a.type;\n    }\n    return this.canRebaseOn(parentType) ? (_b = parentType.field(this.name)) === null || _b === void 0 ? void 0 : _b.type : undefined;\n  }\n  hasDefer() {\n    return false;\n  }\n  deferDirectiveArgs() {\n    return undefined;\n  }\n  withoutDefer() {\n    return this;\n  }\n  equals(that) {\n    if (this === that) {\n      return true;\n    }\n    return that.kind === 'Field' && this.name === that.name && this.alias === that.alias && (this.args ? that.args && (0, values_1.argumentsEquals)(this.args, that.args) : !that.args) && haveSameDirectives(this, that);\n  }\n  toString() {\n    const alias = this.alias ? this.alias + ': ' : '';\n    const entries = this.args ? Object.entries(this.args) : [];\n    const args = entries.length === 0 ? '' : '(' + entries.map(([n, v]) => {\n      var _a;\n      return `${n}: ${(0, values_1.valueToString)(v, (_a = this.definition.argument(n)) === null || _a === void 0 ? void 0 : _a.type)}`;\n    }).join(', ') + ')';\n    return alias + this.name + args + this.appliedDirectivesToString();\n  }\n}\nexports.Field = Field;\nfunction keyForDirective(directive, directivesNeverEqualToThemselves = ['defer']) {\n  if (directivesNeverEqualToThemselves.includes(directive.name)) {\n    return (0, uuid_1.v1)();\n  }\n  const entries = Object.entries(directive.arguments()).filter(([_, v]) => v !== undefined);\n  entries.sort(([n1], [n2]) => n1.localeCompare(n2));\n  const args = entries.length == 0 ? '' : '(' + entries.map(([n, v]) => `${n}: ${(0, values_1.valueToString)(v, directive.argumentType(n))}`).join(', ') + ')';\n  return `@${directive.name}${args}`;\n}\nclass FragmentElement extends AbstractOperationElement {\n  constructor(sourceType, typeCondition, directives) {\n    super(sourceType.schema(), directives);\n    this.sourceType = sourceType;\n    this.kind = 'FragmentElement';\n    this.typeCondition = typeCondition !== undefined && typeof typeCondition === 'string' ? this.schema().type(typeCondition) : typeCondition;\n  }\n  collectVariablesInElement(_) {}\n  get parentType() {\n    return this.sourceType;\n  }\n  key() {\n    if (!this.computedKey) {\n      this.computedKey = '...' + (this.typeCondition ? ' on ' + this.typeCondition.name : '') + this.keyForDirectives();\n    }\n    return this.computedKey;\n  }\n  castedType() {\n    return this.typeCondition ? this.typeCondition : this.sourceType;\n  }\n  asPathElement() {\n    const condition = this.typeCondition;\n    return condition ? `... on ${condition}` : undefined;\n  }\n  withUpdatedSourceType(newSourceType) {\n    return this.withUpdatedTypes(newSourceType, this.typeCondition);\n  }\n  withUpdatedCondition(newCondition) {\n    return this.withUpdatedTypes(this.sourceType, newCondition);\n  }\n  withUpdatedTypes(newSourceType, newCondition) {\n    const newFragment = new FragmentElement(newSourceType, newCondition === null || newCondition === void 0 ? void 0 : newCondition.name, this.appliedDirectives);\n    this.copyAttachementsTo(newFragment);\n    return newFragment;\n  }\n  withUpdatedDirectives(newDirectives) {\n    const newFragment = new FragmentElement(this.sourceType, this.typeCondition, newDirectives);\n    this.copyAttachementsTo(newFragment);\n    return newFragment;\n  }\n  rebaseOn({\n    parentType,\n    errorIfCannotRebase\n  }) {\n    const fragmentParent = this.parentType;\n    const typeCondition = this.typeCondition;\n    if (parentType === fragmentParent) {\n      return this;\n    }\n    const {\n      canRebase,\n      rebasedCondition\n    } = this.canRebaseOn(parentType);\n    if (!canRebase) {\n      validate(!errorIfCannotRebase, () => `Cannot add fragment of condition \"${typeCondition}\" (runtimes: [${(0, definitions_1.possibleRuntimeTypes)(typeCondition)}]) to parent type \"${parentType}\" (runtimes: ${(0, definitions_1.possibleRuntimeTypes)(parentType)})`);\n      return undefined;\n    }\n    return this.withUpdatedTypes(parentType, rebasedCondition);\n  }\n  canRebaseOn(parentType) {\n    if (!this.typeCondition) {\n      return {\n        canRebase: true,\n        rebasedCondition: undefined\n      };\n    }\n    const rebasedCondition = parentType.schema().type(this.typeCondition.name);\n    if (!rebasedCondition || !(0, definitions_1.isCompositeType)(rebasedCondition) || !(0, definitions_1.runtimeTypesIntersects)(parentType, rebasedCondition)) {\n      return {\n        canRebase: false\n      };\n    }\n    return {\n      canRebase: true,\n      rebasedCondition\n    };\n  }\n  castedTypeIfAddedTo(parentType) {\n    if (parentType == this.parentType) {\n      return this.castedType();\n    }\n    const {\n      canRebase,\n      rebasedCondition\n    } = this.canRebaseOn(parentType);\n    return canRebase ? rebasedCondition ? rebasedCondition : parentType : undefined;\n  }\n  hasDefer() {\n    return this.hasAppliedDirective('defer');\n  }\n  hasStream() {\n    return this.hasAppliedDirective('stream');\n  }\n  deferDirectiveArgs() {\n    var _a;\n    return (_a = this.appliedDirectivesOf(this.schema().deferDirective())[0]) === null || _a === void 0 ? void 0 : _a.arguments();\n  }\n  withoutDefer() {\n    const deferName = this.schema().deferDirective().name;\n    const updatedDirectives = this.appliedDirectives.filter(d => d.name !== deferName);\n    if (!this.typeCondition && updatedDirectives.length === 0) {\n      return undefined;\n    }\n    if (updatedDirectives.length === this.appliedDirectives.length) {\n      return this;\n    }\n    const updated = new FragmentElement(this.sourceType, this.typeCondition, updatedDirectives);\n    this.copyAttachementsTo(updated);\n    return updated;\n  }\n  withNormalizedDefer(normalizer) {\n    const deferArgs = this.deferDirectiveArgs();\n    if (!deferArgs) {\n      return this;\n    }\n    let newDeferArgs = undefined;\n    let conditionVariable = undefined;\n    if (deferArgs.if !== undefined) {\n      if (typeof deferArgs.if === 'boolean') {\n        if (deferArgs.if) {\n          newDeferArgs = {\n            ...deferArgs,\n            if: undefined\n          };\n        } else {\n          return this.withoutDefer();\n        }\n      } else {\n        conditionVariable = deferArgs.if;\n      }\n    }\n    let label = deferArgs.label;\n    if (!label) {\n      label = normalizer.newLabel();\n      if (newDeferArgs) {\n        newDeferArgs.label = label;\n      } else {\n        newDeferArgs = {\n          ...deferArgs,\n          label\n        };\n      }\n    }\n    if (conditionVariable) {\n      normalizer.registerCondition(label, conditionVariable);\n    }\n    if (!newDeferArgs) {\n      return this;\n    }\n    const deferDirective = this.schema().deferDirective();\n    const updatedDirectives = this.appliedDirectives.filter(d => d.name !== deferDirective.name).concat(new definitions_1.Directive(deferDirective.name, newDeferArgs));\n    const updated = new FragmentElement(this.sourceType, this.typeCondition, updatedDirectives);\n    this.copyAttachementsTo(updated);\n    return updated;\n  }\n  equals(that) {\n    var _a, _b;\n    if (this === that) {\n      return true;\n    }\n    return that.kind === 'FragmentElement' && ((_a = this.typeCondition) === null || _a === void 0 ? void 0 : _a.name) === ((_b = that.typeCondition) === null || _b === void 0 ? void 0 : _b.name) && haveSameDirectives(this, that);\n  }\n  toString() {\n    return '...' + (this.typeCondition ? ' on ' + this.typeCondition : '') + this.appliedDirectivesToString();\n  }\n}\nexports.FragmentElement = FragmentElement;\nfunction operationPathToStringPath(path) {\n  return path.filter(p => !(p.kind === 'FragmentElement' && !p.typeCondition)).map(p => {\n    var _a;\n    return p.kind === 'Field' ? p.responseName() : `... on ${(_a = p.typeCondition) === null || _a === void 0 ? void 0 : _a.coordinate}`;\n  });\n}\nexports.operationPathToStringPath = operationPathToStringPath;\nfunction sameOperationPaths(p1, p2) {\n  if (p1 === p2) {\n    return true;\n  }\n  if (p1.length !== p2.length) {\n    return false;\n  }\n  for (let i = 0; i < p1.length; i++) {\n    if (!p1[i].equals(p2[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.sameOperationPaths = sameOperationPaths;\nfunction conditionalDirectivesInOperationPath(path) {\n  return path.map(e => e.appliedDirectives).flat().filter(d => (0, definitions_1.isConditionalDirective)(d));\n}\nexports.conditionalDirectivesInOperationPath = conditionalDirectivesInOperationPath;\nfunction concatOperationPaths(head, tail) {\n  if (head.length === 0) {\n    return tail;\n  }\n  if (tail.length === 0) {\n    return head;\n  }\n  const lastOfHead = head[head.length - 1];\n  const conditionals = conditionalDirectivesInOperationPath(head);\n  let firstOfTail = tail[0];\n  while (firstOfTail && isUselessFollowupElement(lastOfHead, firstOfTail, conditionals)) {\n    tail = tail.slice(1);\n    firstOfTail = tail[0];\n  }\n  return head.concat(tail);\n}\nexports.concatOperationPaths = concatOperationPaths;\nfunction isUselessFollowupElement(first, followup, conditionals) {\n  const typeOfFirst = first.kind === 'Field' ? first.baseType() : first.typeCondition;\n  return !!typeOfFirst && followup.kind === 'FragmentElement' && !!followup.typeCondition && (followup.appliedDirectives.length === 0 || (0, definitions_1.isDirectiveApplicationsSubset)(conditionals, followup.appliedDirectives)) && (0, types_1.isSubtype)(followup.typeCondition, typeOfFirst);\n}\nfunction computeFragmentsDependents(fragments) {\n  const reverseDeps = new utils_1.SetMultiMap();\n  for (const fragment of fragments.definitions()) {\n    for (const dependency of fragment.fragmentUsages().keys()) {\n      reverseDeps.add(dependency, fragment.name);\n    }\n  }\n  return reverseDeps;\n}\nfunction clearKeptFragments(usages, fragments, minUsagesToOptimize) {\n  let toCheck = Array.from(usages.entries()).filter(([_, count]) => count >= minUsagesToOptimize).map(([name, _]) => name);\n  while (toCheck.length > 0) {\n    const newToCheck = [];\n    for (const name of toCheck) {\n      usages.delete(name);\n      const ownUsages = fragments.get(name).fragmentUsages();\n      for (const [otherName, otherCount] of ownUsages.entries()) {\n        const prevCount = usages.get(otherName);\n        if (prevCount !== undefined) {\n          const newCount = prevCount + otherCount;\n          usages.set(otherName, newCount);\n          if (prevCount < minUsagesToOptimize && newCount >= minUsagesToOptimize) {\n            newToCheck.push(otherName);\n          }\n        }\n      }\n    }\n    toCheck = newToCheck;\n  }\n}\nfunction computeFragmentsToKeep(selectionSet, fragments, minUsagesToOptimize) {\n  const usages = new Map();\n  selectionSet.collectUsedFragmentNames(usages);\n  if (usages.size === 0) {\n    return null;\n  }\n  for (const fragment of fragments.definitions()) {\n    if (usages.get(fragment.name) === undefined) {\n      usages.set(fragment.name, 0);\n    }\n  }\n  const reverseDependencies = computeFragmentsDependents(fragments);\n  const toExpand = new Set();\n  let shouldContinue = true;\n  while (shouldContinue) {\n    shouldContinue = false;\n    clearKeptFragments(usages, fragments, minUsagesToOptimize);\n    for (const name of (0, utils_1.mapKeys)(usages)) {\n      const count = usages.get(name);\n      if (count === 0) {\n        continue;\n      }\n      if (count >= minUsagesToOptimize) {\n        shouldContinue = true;\n        break;\n      }\n      const fragmentsUsingName = reverseDependencies.get(name);\n      if (!fragmentsUsingName || [...fragmentsUsingName].every(fragName => toExpand.has(fragName) || !usages.get(fragName))) {\n        toExpand.add(name);\n        usages.delete(name);\n        shouldContinue = true;\n        const nameUsages = fragments.get(name).fragmentUsages();\n        for (const [otherName, otherCount] of nameUsages.entries()) {\n          const prev = usages.get(otherName);\n          if (prev !== undefined) {\n            usages.set(otherName, prev + count * otherCount);\n          }\n        }\n      }\n    }\n  }\n  for (const name of usages.keys()) {\n    toExpand.add(name);\n  }\n  return toExpand.size === 0 ? fragments : fragments.filter(f => !toExpand.has(f.name));\n}\nclass Operation {\n  constructor(schema, rootKind, selectionSet, variableDefinitions, fragments, name) {\n    this.schema = schema;\n    this.rootKind = rootKind;\n    this.selectionSet = selectionSet;\n    this.variableDefinitions = variableDefinitions;\n    this.fragments = fragments;\n    this.name = name;\n  }\n  withUpdatedSelectionSet(newSelectionSet) {\n    if (this.selectionSet === newSelectionSet) {\n      return this;\n    }\n    return new Operation(this.schema, this.rootKind, newSelectionSet, this.variableDefinitions, this.fragments, this.name);\n  }\n  withUpdatedSelectionSetAndFragments(newSelectionSet, newFragments) {\n    if (this.selectionSet === newSelectionSet && newFragments === this.fragments) {\n      return this;\n    }\n    return new Operation(this.schema, this.rootKind, newSelectionSet, this.variableDefinitions, newFragments, this.name);\n  }\n  optimize(fragments, minUsagesToOptimize = 2) {\n    (0, utils_1.assert)(minUsagesToOptimize >= 1, `Expected 'minUsagesToOptimize' to be at least 1, but got ${minUsagesToOptimize}`);\n    if (!fragments || fragments.isEmpty()) {\n      return this;\n    }\n    let optimizedSelection = this.selectionSet.optimize(fragments);\n    if (optimizedSelection === this.selectionSet) {\n      return this;\n    }\n    let finalFragments = computeFragmentsToKeep(optimizedSelection, fragments, minUsagesToOptimize);\n    if (finalFragments !== null && (finalFragments === null || finalFragments === void 0 ? void 0 : finalFragments.size) !== fragments.size) {\n      optimizedSelection = optimizedSelection.expandFragments(finalFragments);\n      optimizedSelection = optimizedSelection.normalize({\n        parentType: optimizedSelection.parentType\n      });\n      if (finalFragments) {\n        let beforeRemoval;\n        do {\n          beforeRemoval = finalFragments;\n          const usages = new Map();\n          optimizedSelection.collectUsedFragmentNames(usages);\n          finalFragments.collectUsedFragmentNames(usages);\n          finalFragments = finalFragments.filter(f => {\n            var _a;\n            return ((_a = usages.get(f.name)) !== null && _a !== void 0 ? _a : 0) > 0;\n          });\n        } while (finalFragments && finalFragments.size < beforeRemoval.size);\n      }\n    }\n    return this.withUpdatedSelectionSetAndFragments(optimizedSelection, finalFragments !== null && finalFragments !== void 0 ? finalFragments : undefined);\n  }\n  expandAllFragments() {\n    const expanded = this.selectionSet.expandFragments();\n    return this.withUpdatedSelectionSetAndFragments(expanded.normalize({\n      parentType: expanded.parentType\n    }), undefined);\n  }\n  normalize() {\n    return this.withUpdatedSelectionSet(this.selectionSet.normalize({\n      parentType: this.selectionSet.parentType\n    }));\n  }\n  withoutDefer(labelsToRemove) {\n    return this.withUpdatedSelectionSet(this.selectionSet.withoutDefer(labelsToRemove));\n  }\n  withNormalizedDefer() {\n    const normalizer = new DeferNormalizer();\n    const {\n      hasDefers,\n      hasNonLabelledOrConditionalDefers\n    } = normalizer.init(this.selectionSet);\n    let updatedOperation = this;\n    if (hasNonLabelledOrConditionalDefers) {\n      updatedOperation = this.withUpdatedSelectionSet(this.selectionSet.withNormalizedDefer(normalizer));\n    }\n    return {\n      operation: updatedOperation,\n      hasDefers,\n      assignedDeferLabels: normalizer.assignedLabels,\n      deferConditions: normalizer.deferConditions\n    };\n  }\n  collectDefaultedVariableValues() {\n    const defaultedVariableValues = {};\n    for (const {\n      variable,\n      defaultValue\n    } of this.variableDefinitions.definitions()) {\n      if (defaultValue !== undefined) {\n        defaultedVariableValues[variable.name] = defaultValue;\n      }\n    }\n    return defaultedVariableValues;\n  }\n  toString(expandFragments = false, prettyPrint = true) {\n    return this.selectionSet.toOperationString(this.rootKind, this.variableDefinitions, this.fragments, this.name, expandFragments, prettyPrint);\n  }\n}\nexports.Operation = Operation;\nclass NamedFragmentDefinition extends definitions_1.DirectiveTargetElement {\n  constructor(schema, name, typeCondition, directives) {\n    super(schema, directives);\n    this.name = name;\n    this.typeCondition = typeCondition;\n    this.expandedSelectionSetsAtTypesCache = new Map();\n  }\n  setSelectionSet(selectionSet) {\n    (0, utils_1.assert)(!this._selectionSet, 'Attempting to set the selection set of a fragment definition already built');\n    (0, utils_1.assert)(selectionSet.parentType === this.typeCondition, `Fragment selection set parent is ${selectionSet.parentType} differs from the fragment condition type ${this.typeCondition}`);\n    this._selectionSet = selectionSet;\n    return this;\n  }\n  get selectionSet() {\n    (0, utils_1.assert)(this._selectionSet, () => `Trying to access fragment definition ${this.name} before it is fully built`);\n    return this._selectionSet;\n  }\n  withUpdatedSelectionSet(newSelectionSet) {\n    return new NamedFragmentDefinition(this.schema(), this.name, this.typeCondition).setSelectionSet(newSelectionSet);\n  }\n  fragmentUsages() {\n    if (!this._fragmentUsages) {\n      this._fragmentUsages = new Map();\n      this.selectionSet.collectUsedFragmentNames(this._fragmentUsages);\n    }\n    return this._fragmentUsages;\n  }\n  collectUsedFragmentNames(collector) {\n    const usages = this.fragmentUsages();\n    for (const [name, count] of usages.entries()) {\n      const prevCount = collector.get(name);\n      collector.set(name, prevCount ? prevCount + count : count);\n    }\n  }\n  toFragmentDefinitionNode() {\n    return {\n      kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: this.name\n      },\n      typeCondition: {\n        kind: graphql_1.Kind.NAMED_TYPE,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: this.typeCondition.name\n        }\n      },\n      selectionSet: this.selectionSet.toSelectionSetNode()\n    };\n  }\n  canApplyDirectlyAtType(type) {\n    if ((0, types_1.sameType)(type, this.typeCondition)) {\n      return true;\n    }\n    if (!(0, definitions_1.isAbstractType)(this.typeCondition)) {\n      return false;\n    }\n    const conditionRuntimes = (0, definitions_1.possibleRuntimeTypes)(this.typeCondition);\n    const typeRuntimes = (0, definitions_1.possibleRuntimeTypes)(type);\n    if (conditionRuntimes.length < typeRuntimes.length || !typeRuntimes.every(t1 => conditionRuntimes.some(t2 => (0, types_1.sameType)(t1, t2)))) {\n      return false;\n    }\n    return (0, definitions_1.isObjectType)(type) || (0, definitions_1.isUnionType)(this.typeCondition);\n  }\n  expandedSelectionSet() {\n    if (!this._expandedSelectionSet) {\n      this._expandedSelectionSet = this.selectionSet.expandFragments();\n    }\n    return this._expandedSelectionSet;\n  }\n  expandedSelectionSetAtType(type) {\n    let cached = this.expandedSelectionSetsAtTypesCache.get(type.name);\n    if (!cached) {\n      cached = this.computeExpandedSelectionSetAtType(type);\n      this.expandedSelectionSetsAtTypesCache.set(type.name, cached);\n    }\n    return cached;\n  }\n  computeExpandedSelectionSetAtType(type) {\n    const expandedSelectionSet = this.expandedSelectionSet();\n    const selectionSet = expandedSelectionSet.normalize({\n      parentType: type\n    });\n    const trimmed = expandedSelectionSet.minus(selectionSet);\n    const validator = trimmed.isEmpty() ? undefined : FieldsConflictValidator.build(trimmed);\n    return {\n      selectionSet,\n      validator\n    };\n  }\n  includes(otherFragment) {\n    if (this.name === otherFragment) {\n      return false;\n    }\n    if (!this._includedFragmentNames) {\n      this._includedFragmentNames = this.computeIncludedFragmentNames();\n    }\n    return this._includedFragmentNames.has(otherFragment);\n  }\n  computeIncludedFragmentNames() {\n    const included = new Set();\n    for (const selection of this.selectionSet.selections()) {\n      if (selection instanceof FragmentSpreadSelection) {\n        included.add(selection.namedFragment.name);\n      }\n    }\n    return included;\n  }\n  toString(indent) {\n    return `fragment ${this.name} on ${this.typeCondition}${this.appliedDirectivesToString()} ${this.selectionSet.toString(false, true, indent)}`;\n  }\n}\nexports.NamedFragmentDefinition = NamedFragmentDefinition;\nclass NamedFragments {\n  constructor() {\n    this.fragments = new utils_1.MapWithCachedArrays();\n  }\n  isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.fragments.size;\n  }\n  names() {\n    return this.fragments.keys();\n  }\n  add(fragment) {\n    if (this.fragments.has(fragment.name)) {\n      throw error_1.ERRORS.INVALID_GRAPHQL.err(`Duplicate fragment name '${fragment}'`);\n    }\n    this.fragments.set(fragment.name, fragment);\n  }\n  addIfNotExist(fragment) {\n    if (!this.fragments.has(fragment.name)) {\n      this.fragments.set(fragment.name, fragment);\n    }\n  }\n  maybeApplyingDirectlyAtType(type) {\n    return this.fragments.values().filter(f => f.canApplyDirectlyAtType(type));\n  }\n  get(name) {\n    return this.fragments.get(name);\n  }\n  has(name) {\n    return this.fragments.has(name);\n  }\n  definitions() {\n    return this.fragments.values();\n  }\n  collectUsedFragmentNames(collector) {\n    for (const fragment of this.definitions()) {\n      fragment.collectUsedFragmentNames(collector);\n    }\n  }\n  map(mapper) {\n    const mapped = new NamedFragments();\n    for (const def of this.fragments.values()) {\n      mapped.fragments.set(def.name, mapper(def));\n    }\n    return mapped;\n  }\n  mapInDependencyOrder(mapper) {\n    const fragmentsMap = new Map();\n    for (const fragment of this.definitions()) {\n      fragmentsMap.set(fragment.name, {\n        fragment,\n        dependsOn: Array.from(fragment.fragmentUsages().keys())\n      });\n    }\n    const removedFragments = new Set();\n    const mappedFragments = new NamedFragments();\n    while (fragmentsMap.size > 0) {\n      for (const [name, info] of fragmentsMap) {\n        if (info.dependsOn.every(n => mappedFragments.has(n) || removedFragments.has(n))) {\n          const mapped = mapper(info.fragment, mappedFragments);\n          fragmentsMap.delete(name);\n          if (!mapped) {\n            removedFragments.add(name);\n          } else {\n            mappedFragments.add(mapped);\n          }\n          break;\n        }\n      }\n    }\n    return mappedFragments.isEmpty() ? undefined : mappedFragments;\n  }\n  mapToExpandedSelectionSets(mapper) {\n    return this.mapInDependencyOrder((fragment, newFragments) => {\n      const mappedSelectionSet = mapper(fragment.selectionSet.expandFragments().normalize({\n        parentType: fragment.typeCondition\n      }));\n      if (!mappedSelectionSet) {\n        return undefined;\n      }\n      const reoptimizedSelectionSet = mappedSelectionSet.optimize(newFragments);\n      return fragment.withUpdatedSelectionSet(reoptimizedSelectionSet);\n    });\n  }\n  selectionSetIsWorthUsing(selectionSet) {\n    const selections = selectionSet.selections();\n    if (selections.length === 0) {\n      return false;\n    }\n    if (selections.length === 1) {\n      const s = selections[0];\n      return !(s.kind === 'FieldSelection' && s.element.isLeafField());\n    }\n    return true;\n  }\n  rebaseOn(schema) {\n    return this.mapInDependencyOrder((fragment, newFragments) => {\n      const rebasedType = schema.type(fragment.selectionSet.parentType.name);\n      if (!rebasedType || !(0, definitions_1.isCompositeType)(rebasedType)) {\n        return undefined;\n      }\n      let rebasedSelection = fragment.selectionSet.rebaseOn({\n        parentType: rebasedType,\n        fragments: newFragments,\n        errorIfCannotRebase: false\n      });\n      rebasedSelection = rebasedSelection.normalize({\n        parentType: rebasedType\n      });\n      return this.selectionSetIsWorthUsing(rebasedSelection) ? new NamedFragmentDefinition(schema, fragment.name, rebasedType).setSelectionSet(rebasedSelection) : undefined;\n    });\n  }\n  filter(predicate) {\n    return this.mapInDependencyOrder((fragment, newFragments) => {\n      if (predicate(fragment)) {\n        const updatedSelectionSet = fragment.selectionSet.expandFragments(newFragments);\n        return updatedSelectionSet === fragment.selectionSet ? fragment : fragment.withUpdatedSelectionSet(updatedSelectionSet.normalize({\n          parentType: updatedSelectionSet.parentType\n        }));\n      } else {\n        return undefined;\n      }\n    });\n  }\n  validate(variableDefinitions) {\n    for (const fragment of this.fragments.values()) {\n      fragment.selectionSet.validate(variableDefinitions);\n    }\n  }\n  toFragmentDefinitionNodes() {\n    return this.definitions().map(f => f.toFragmentDefinitionNode());\n  }\n  toString(indent) {\n    return this.definitions().map(f => f.toString(indent)).join('\\n\\n');\n  }\n}\nexports.NamedFragments = NamedFragments;\nclass DeferNormalizer {\n  constructor() {\n    this.index = 0;\n    this.assignedLabels = new Set();\n    this.deferConditions = new utils_1.SetMultiMap();\n    this.usedLabels = new Set();\n  }\n  init(selectionSet) {\n    let hasNonLabelledOrConditionalDefers = false;\n    let hasDefers = false;\n    const stack = selectionSet.selections().concat();\n    while (stack.length > 0) {\n      const selection = stack.pop();\n      if (selection.kind === 'FragmentSelection') {\n        const deferArgs = selection.element.deferDirectiveArgs();\n        if (deferArgs) {\n          hasDefers = true;\n          if (!deferArgs.label || deferArgs.if !== undefined) {\n            hasNonLabelledOrConditionalDefers = true;\n          }\n          if (deferArgs.label) {\n            this.usedLabels.add(deferArgs.label);\n          }\n        }\n      }\n      if (selection.selectionSet) {\n        selection.selectionSet.selections().forEach(s => stack.push(s));\n      }\n    }\n    return {\n      hasDefers,\n      hasNonLabelledOrConditionalDefers\n    };\n  }\n  nextLabel() {\n    return `qp__${this.index++}`;\n  }\n  newLabel() {\n    let candidate = this.nextLabel();\n    while (this.usedLabels.has(candidate)) {\n      candidate = this.nextLabel();\n    }\n    this.assignedLabels.add(candidate);\n    return candidate;\n  }\n  registerCondition(label, condition) {\n    this.deferConditions.add(condition.name, label);\n  }\n}\nvar ContainsResult;\n(function (ContainsResult) {\n  ContainsResult[ContainsResult[\"NOT_CONTAINED\"] = 0] = \"NOT_CONTAINED\";\n  ContainsResult[ContainsResult[\"STRICTLY_CONTAINED\"] = 1] = \"STRICTLY_CONTAINED\";\n  ContainsResult[ContainsResult[\"EQUAL\"] = 2] = \"EQUAL\";\n})(ContainsResult || (exports.ContainsResult = ContainsResult = {}));\nclass SelectionSet {\n  constructor(parentType, keyedSelections = new Map()) {\n    this.parentType = parentType;\n    this._keyedSelections = keyedSelections;\n    this._selections = (0, utils_1.mapValues)(keyedSelections);\n  }\n  selectionsInReverseOrder() {\n    const length = this._selections.length;\n    const reversed = new Array(length);\n    for (let i = 0; i < length; i++) {\n      reversed[i] = this._selections[length - i - 1];\n    }\n    return reversed;\n  }\n  selections() {\n    return this._selections;\n  }\n  hasTopLevelTypenameField() {\n    return this._keyedSelections.has(definitions_1.typenameFieldName);\n  }\n  withoutTopLevelTypenameField() {\n    if (!this.hasTopLevelTypenameField) {\n      return this;\n    }\n    const newKeyedSelections = new Map();\n    for (const [key, selection] of this._keyedSelections) {\n      if (key !== definitions_1.typenameFieldName) {\n        newKeyedSelections.set(key, selection);\n      }\n    }\n    return new SelectionSet(this.parentType, newKeyedSelections);\n  }\n  fieldsInSet() {\n    const fields = new Array();\n    for (const selection of this.selections()) {\n      if (selection.kind === 'FieldSelection') {\n        fields.push({\n          path: [],\n          field: selection\n        });\n      } else {\n        const condition = selection.element.typeCondition;\n        const header = condition ? [`... on ${condition}`] : [];\n        for (const {\n          path,\n          field\n        } of selection.selectionSet.fieldsInSet()) {\n          fields.push({\n            path: header.concat(path),\n            field\n          });\n        }\n      }\n    }\n    return fields;\n  }\n  fieldsByResponseName() {\n    const byResponseName = new utils_1.MultiMap();\n    this.collectFieldsByResponseName(byResponseName);\n    return byResponseName;\n  }\n  collectFieldsByResponseName(collector) {\n    for (const selection of this.selections()) {\n      if (selection.kind === 'FieldSelection') {\n        collector.add(selection.element.responseName(), selection);\n      } else {\n        selection.selectionSet.collectFieldsByResponseName(collector);\n      }\n    }\n  }\n  usedVariables() {\n    const collector = new definitions_1.VariableCollector();\n    this.collectVariables(collector);\n    return collector.variables();\n  }\n  collectVariables(collector) {\n    for (const selection of this.selections()) {\n      selection.collectVariables(collector);\n    }\n  }\n  collectUsedFragmentNames(collector) {\n    for (const selection of this.selections()) {\n      selection.collectUsedFragmentNames(collector);\n    }\n  }\n  optimize(fragments) {\n    if (!fragments || fragments.isEmpty()) {\n      return this;\n    }\n    const wrapped = new InlineFragmentSelection(new FragmentElement(this.parentType, this.parentType), this);\n    const validator = FieldsConflictMultiBranchValidator.ofInitial(FieldsConflictValidator.build(this));\n    const optimized = wrapped.optimize(fragments, validator);\n    return optimized instanceof FragmentSpreadSelection ? selectionSetOf(this.parentType, optimized) : optimized.selectionSet;\n  }\n  optimizeSelections(fragments, validator) {\n    return this.lazyMap(selection => selection.optimize(fragments, validator));\n  }\n  expandFragments(updatedFragments) {\n    return this.lazyMap(selection => selection.expandFragments(updatedFragments));\n  }\n  normalize({\n    parentType,\n    recursive\n  }) {\n    return this.lazyMap(selection => selection.normalize({\n      parentType,\n      recursive\n    }), {\n      parentType\n    });\n  }\n  lazyMap(mapper, options) {\n    var _a;\n    const selections = this.selections();\n    let updatedSelections = undefined;\n    for (let i = 0; i < selections.length; i++) {\n      const selection = selections[i];\n      const updated = mapper(selection);\n      if (updated !== selection && !updatedSelections) {\n        updatedSelections = new SelectionSetUpdates();\n        for (let j = 0; j < i; j++) {\n          updatedSelections.add(selections[j]);\n        }\n      }\n      if (!!updated && updatedSelections) {\n        updatedSelections.add(updated);\n      }\n    }\n    if (!updatedSelections) {\n      return this;\n    }\n    return updatedSelections.toSelectionSet((_a = options === null || options === void 0 ? void 0 : options.parentType) !== null && _a !== void 0 ? _a : this.parentType);\n  }\n  withoutDefer(labelsToRemove) {\n    return this.lazyMap(selection => selection.withoutDefer(labelsToRemove));\n  }\n  withNormalizedDefer(normalizer) {\n    return this.lazyMap(selection => selection.withNormalizedDefer(normalizer));\n  }\n  hasDefer() {\n    return this.selections().some(s => s.hasDefer());\n  }\n  filter(predicate) {\n    return this.lazyMap(selection => predicate(selection) ? selection : undefined);\n  }\n  filterRecursiveDepthFirst(predicate) {\n    return this.lazyMap(selection => selection.filterRecursiveDepthFirst(predicate));\n  }\n  withoutEmptyBranches() {\n    const updated = this.filterRecursiveDepthFirst(selection => {\n      var _a;\n      return ((_a = selection.selectionSet) === null || _a === void 0 ? void 0 : _a.isEmpty()) !== true;\n    });\n    return updated.isEmpty() ? undefined : updated;\n  }\n  rebaseOn({\n    parentType,\n    fragments,\n    errorIfCannotRebase\n  }) {\n    if (this.parentType === parentType) {\n      return this;\n    }\n    const newSelections = new Map();\n    for (const selection of this.selections()) {\n      const rebasedSelection = selection.rebaseOn({\n        parentType,\n        fragments,\n        errorIfCannotRebase\n      });\n      if (rebasedSelection) {\n        newSelections.set(selection.key(), rebasedSelection);\n      }\n    }\n    return new SelectionSet(parentType, newSelections);\n  }\n  equals(that) {\n    if (this === that) {\n      return true;\n    }\n    if (this._selections.length !== that._selections.length) {\n      return false;\n    }\n    for (const [key, thisSelection] of this._keyedSelections) {\n      const thatSelection = that._keyedSelections.get(key);\n      if (!thatSelection || !thisSelection.equals(thatSelection)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  contains(that, options) {\n    var _a;\n    const ignoreMissingTypename = (_a = options === null || options === void 0 ? void 0 : options.ignoreMissingTypename) !== null && _a !== void 0 ? _a : false;\n    if (that._selections.length > this._selections.length) {\n      if (!ignoreMissingTypename || that._selections.length > this._selections.length + 1 || this.hasTopLevelTypenameField() || !that.hasTopLevelTypenameField()) {\n        return ContainsResult.NOT_CONTAINED;\n      }\n    }\n    let isEqual = true;\n    let didIgnoreTypename = false;\n    for (const [key, thatSelection] of that._keyedSelections) {\n      if (key === definitions_1.typenameFieldName && ignoreMissingTypename) {\n        if (!this._keyedSelections.has(definitions_1.typenameFieldName)) {\n          didIgnoreTypename = true;\n        }\n        continue;\n      }\n      const thisSelection = this._keyedSelections.get(key);\n      const selectionResult = thisSelection === null || thisSelection === void 0 ? void 0 : thisSelection.contains(thatSelection, options);\n      if (selectionResult === undefined || selectionResult === ContainsResult.NOT_CONTAINED) {\n        return ContainsResult.NOT_CONTAINED;\n      }\n      isEqual && (isEqual = selectionResult === ContainsResult.EQUAL);\n    }\n    return isEqual && that._selections.length === this._selections.length + (didIgnoreTypename ? 1 : 0) ? ContainsResult.EQUAL : ContainsResult.STRICTLY_CONTAINED;\n  }\n  containsTopLevelField(field) {\n    const selection = this._keyedSelections.get(field.key());\n    return !!selection && selection.element.equals(field);\n  }\n  minus(that) {\n    const updated = new SelectionSetUpdates();\n    for (const [key, thisSelection] of this._keyedSelections) {\n      const thatSelection = that._keyedSelections.get(key);\n      if (thatSelection) {\n        const remainder = thisSelection.minus(thatSelection);\n        if (remainder) {\n          updated.add(remainder);\n        }\n      } else {\n        updated.add(thisSelection);\n      }\n    }\n    return updated.toSelectionSet(this.parentType);\n  }\n  intersectionWith(that) {\n    if (this.isEmpty()) {\n      return this;\n    }\n    if (that.isEmpty()) {\n      return that;\n    }\n    const intersection = new SelectionSetUpdates();\n    for (const [key, thisSelection] of this._keyedSelections) {\n      const thatSelection = that._keyedSelections.get(key);\n      if (thatSelection) {\n        const selection = thisSelection.intersectionWith(thatSelection);\n        if (selection) {\n          intersection.add(selection);\n        }\n      }\n    }\n    return intersection.toSelectionSet(this.parentType);\n  }\n  canRebaseOn(parentTypeToTest) {\n    return this.selections().every(selection => selection.canAddTo(parentTypeToTest));\n  }\n  validate(variableDefinitions) {\n    validate(!this.isEmpty(), () => `Invalid empty selection set`);\n    for (const selection of this.selections()) {\n      selection.validate(variableDefinitions);\n    }\n  }\n  isEmpty() {\n    return this._selections.length === 0;\n  }\n  toSelectionSetNode() {\n    if (this.isEmpty()) {\n      return {\n        kind: graphql_1.Kind.SELECTION_SET,\n        selections: [{\n          kind: graphql_1.Kind.FIELD,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: '...'\n          }\n        }]\n      };\n    }\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: Array.from(this.selectionsInPrintOrder(), s => s.toSelectionNode())\n    };\n  }\n  selectionsInPrintOrder() {\n    const isNonAliasedTypenameSelection = s => s.kind === 'FieldSelection' && !s.element.alias && s.element.name === definitions_1.typenameFieldName;\n    const typenameSelection = this._selections.find(s => isNonAliasedTypenameSelection(s));\n    if (typenameSelection) {\n      return [typenameSelection].concat(this.selections().filter(s => !isNonAliasedTypenameSelection(s)));\n    } else {\n      return this._selections;\n    }\n  }\n  toOperationPaths() {\n    return this.toOperationPathsInternal([]);\n  }\n  toOperationPathsInternal(parentPaths) {\n    return this.selections().flatMap(selection => {\n      const updatedPaths = parentPaths.map(path => path.concat(selection.element));\n      return selection.selectionSet ? selection.selectionSet.toOperationPathsInternal(updatedPaths) : updatedPaths;\n    });\n  }\n  forEachElement(callback) {\n    var _a;\n    const stack = this.selectionsInReverseOrder().concat();\n    while (stack.length > 0) {\n      const selection = stack.pop();\n      callback(selection.element);\n      (_a = selection.selectionSet) === null || _a === void 0 ? void 0 : _a.selectionsInReverseOrder().forEach(s => stack.push(s));\n    }\n  }\n  some(predicate) {\n    for (const selection of this.selections()) {\n      if (predicate(selection.element) || selection.selectionSet && selection.selectionSet.some(predicate)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  toOperationString(rootKind, variableDefinitions, fragments, operationName, expandFragments = false, prettyPrint = true) {\n    const indent = prettyPrint ? '' : undefined;\n    const fragmentsDefinitions = !expandFragments && fragments && !fragments.isEmpty() ? fragments.toString(indent) + \"\\n\\n\" : \"\";\n    if (rootKind == \"query\" && !operationName && variableDefinitions.isEmpty()) {\n      return fragmentsDefinitions + this.toString(expandFragments, true, indent);\n    }\n    const nameAndVariables = operationName ? \" \" + (operationName + (variableDefinitions.isEmpty() ? \"\" : variableDefinitions.toString())) : variableDefinitions.isEmpty() ? \"\" : \" \" + variableDefinitions.toString();\n    return fragmentsDefinitions + rootKind + nameAndVariables + \" \" + this.toString(expandFragments, true, indent);\n  }\n  toString(expandFragments = true, includeExternalBrackets = true, indent) {\n    if (this.isEmpty()) {\n      return '{}';\n    }\n    if (indent === undefined) {\n      const selectionsToString = this.selections().map(s => s.toString(expandFragments)).join(' ');\n      return includeExternalBrackets ? '{ ' + selectionsToString + ' }' : selectionsToString;\n    } else {\n      const selectionIndent = includeExternalBrackets ? indent + \"  \" : indent;\n      const selectionsToString = this.selections().map(s => s.toString(expandFragments, selectionIndent)).join('\\n');\n      return includeExternalBrackets ? '{\\n' + selectionsToString + '\\n' + indent + '}' : selectionsToString;\n    }\n  }\n}\nexports.SelectionSet = SelectionSet;\nclass SelectionSetUpdates {\n  constructor() {\n    this.keyedUpdates = new utils_1.MultiMap();\n  }\n  isEmpty() {\n    return this.keyedUpdates.size === 0;\n  }\n  add(selections) {\n    addToKeyedUpdates(this.keyedUpdates, selections);\n    return this;\n  }\n  addAtPath(path, selections) {\n    if (path.length === 0) {\n      if (selections) {\n        addToKeyedUpdates(this.keyedUpdates, selections);\n      }\n    } else {\n      if (path.length === 1 && !selections) {\n        const element = path[0];\n        if (element.kind === 'Field' && element.isLeafField()) {\n          const selection = selectionOfElement(element);\n          this.keyedUpdates.add(selection.key(), selection);\n          return this;\n        }\n      }\n      this.keyedUpdates.add(path[0].key(), {\n        path,\n        selections\n      });\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new SelectionSetUpdates();\n    for (const [key, values] of this.keyedUpdates.entries()) {\n      cloned.keyedUpdates.set(key, Array.from(values));\n    }\n    return cloned;\n  }\n  clear() {\n    this.keyedUpdates.clear();\n  }\n  toSelectionSet(parentType, fragments) {\n    return makeSelectionSet(parentType, this.keyedUpdates, fragments);\n  }\n  toString() {\n    return '{\\n' + [...this.keyedUpdates.entries()].map(([k, updates]) => {\n      const updStr = updates.map(upd => upd instanceof AbstractSelection ? upd.toString() : `${upd.path} -> ${upd.selections}`);\n      return ` - ${k}: ${updStr}`;\n    }).join('\\n') + '\\n\\}';\n  }\n}\nexports.SelectionSetUpdates = SelectionSetUpdates;\nfunction addToKeyedUpdates(keyedUpdates, selections) {\n  if (selections instanceof AbstractSelection) {\n    addOneToKeyedUpdates(keyedUpdates, selections);\n  } else {\n    const toAdd = selections instanceof SelectionSet ? selections.selections() : selections;\n    for (const selection of toAdd) {\n      addOneToKeyedUpdates(keyedUpdates, selection);\n    }\n  }\n}\nfunction addOneToKeyedUpdates(keyedUpdates, selection) {\n  if (selection instanceof FragmentSpreadSelection) {\n    keyedUpdates.set(selection.key(), [selection]);\n  } else {\n    keyedUpdates.add(selection.key(), selection);\n  }\n}\nfunction maybeRebaseOnSchema(toRebase, schema) {\n  if (toRebase.schema() === schema) {\n    return toRebase;\n  }\n  const rebased = schema.type(toRebase.name);\n  (0, utils_1.assert)(rebased && (0, definitions_1.isCompositeType)(rebased), () => `Expected ${toRebase} to exists and be composite in the rebased schema, but got ${rebased === null || rebased === void 0 ? void 0 : rebased.kind}`);\n  return rebased;\n}\nfunction isUnecessaryFragment(parentType, fragment) {\n  return fragment.element.appliedDirectives.length === 0 && (!fragment.element.typeCondition || (0, types_1.isSubtype)(maybeRebaseOnSchema(fragment.element.typeCondition, parentType.schema()), parentType));\n}\nfunction withUnecessaryFragmentsRemoved(parentType, selections) {\n  if (selections instanceof AbstractSelection) {\n    if (selections.kind !== 'FragmentSelection' || !isUnecessaryFragment(parentType, selections)) {\n      return selections;\n    }\n    return withUnecessaryFragmentsRemoved(parentType, selections.selectionSet);\n  }\n  const toCheck = selections instanceof SelectionSet ? selections.selections() : selections;\n  const filtered = [];\n  for (const selection of toCheck) {\n    if (selection.kind === 'FragmentSelection' && isUnecessaryFragment(parentType, selection)) {\n      const subSelections = withUnecessaryFragmentsRemoved(parentType, selection.selectionSet);\n      if (subSelections instanceof AbstractSelection) {\n        filtered.push(subSelections);\n      } else {\n        for (const subSelection of subSelections) {\n          filtered.push(subSelection);\n        }\n      }\n    } else {\n      filtered.push(selection);\n    }\n  }\n  return filtered;\n}\nfunction makeSelection(parentType, updates, fragments) {\n  (0, utils_1.assert)(updates.length > 0, 'Should not be called without any updates');\n  const first = updates[0];\n  if (updates.length === 1 && first instanceof AbstractSelection) {\n    return first.rebaseOnOrError({\n      parentType,\n      fragments\n    });\n  }\n  const element = updateElement(first).rebaseOnOrError(parentType);\n  const subSelectionParentType = element.kind === 'Field' ? element.baseType() : element.castedType();\n  if (!(0, definitions_1.isCompositeType)(subSelectionParentType)) {\n    return selectionOfElement(element);\n  }\n  const subSelectionKeyedUpdates = new utils_1.MultiMap();\n  for (const update of updates) {\n    if (update instanceof AbstractSelection) {\n      if (update.selectionSet) {\n        addToKeyedUpdates(subSelectionKeyedUpdates, update.selectionSet);\n      }\n    } else {\n      addSubpathToKeyUpdates(subSelectionKeyedUpdates, subSelectionParentType, update);\n    }\n  }\n  return selectionOfElement(element, makeSelectionSet(subSelectionParentType, subSelectionKeyedUpdates, fragments));\n}\nfunction updateElement(update) {\n  return update instanceof AbstractSelection ? update.element : update.path[0];\n}\nfunction addSubpathToKeyUpdates(keyedUpdates, subSelectionParentType, pathUpdate) {\n  if (pathUpdate.path.length === 1) {\n    if (!pathUpdate.selections) {\n      return;\n    }\n    addToKeyedUpdates(keyedUpdates, withUnecessaryFragmentsRemoved(subSelectionParentType, pathUpdate.selections));\n  } else {\n    keyedUpdates.add(pathUpdate.path[1].key(), {\n      path: pathUpdate.path.slice(1),\n      selections: pathUpdate.selections\n    });\n  }\n}\nfunction makeSelectionSet(parentType, keyedUpdates, fragments) {\n  const selections = new Map();\n  for (const [key, updates] of keyedUpdates.entries()) {\n    selections.set(key, makeSelection(parentType, updates, fragments));\n  }\n  return new SelectionSet(parentType, selections);\n}\nclass MutableSelectionSet {\n  constructor(parentType, _updates, memoizer) {\n    this.parentType = parentType;\n    this._updates = _updates;\n    this.memoizer = memoizer;\n  }\n  static empty(parentType) {\n    return this.emptyWithMemoized(parentType, () => ({}));\n  }\n  static emptyWithMemoized(parentType, memoizer) {\n    return new MutableSelectionSet(parentType, new SelectionSetUpdates(), memoizer);\n  }\n  static of(selectionSet) {\n    return this.ofWithMemoized(selectionSet, () => ({}));\n  }\n  static ofWithMemoized(selectionSet, memoizer) {\n    const s = new MutableSelectionSet(selectionSet.parentType, new SelectionSetUpdates(), memoizer);\n    s._updates.add(selectionSet);\n    s.computed = selectionSet;\n    return s;\n  }\n  isEmpty() {\n    return this._updates.isEmpty();\n  }\n  get() {\n    if (!this.computed) {\n      this.computed = this._updates.toSelectionSet(this.parentType);\n      this._updates.clear();\n      this._updates.add(this.computed);\n    }\n    return this.computed;\n  }\n  updates() {\n    this.computed = undefined;\n    this._memoized = undefined;\n    return this._updates;\n  }\n  clone() {\n    const cloned = new MutableSelectionSet(this.parentType, this._updates.clone(), this.memoizer);\n    cloned.computed = this.computed;\n    cloned._memoized = this._memoized;\n    return cloned;\n  }\n  rebaseOn(parentType) {\n    const rebased = new MutableSelectionSet(parentType, new SelectionSetUpdates(), this.memoizer);\n    rebased._updates.add(this.get());\n    return rebased;\n  }\n  memoized() {\n    if (!this._memoized) {\n      this._memoized = this.memoizer(this.get());\n    }\n    return this._memoized;\n  }\n  toString() {\n    return this.get().toString();\n  }\n}\nexports.MutableSelectionSet = MutableSelectionSet;\nfunction allFieldDefinitionsInSelectionSet(selection) {\n  const stack = Array.from(selection.selections());\n  const allFields = [];\n  while (stack.length > 0) {\n    const selection = stack.pop();\n    if (selection.kind === 'FieldSelection') {\n      allFields.push(selection.element.definition);\n    }\n    if (selection.selectionSet) {\n      stack.push(...selection.selectionSet.selections());\n    }\n  }\n  return allFields;\n}\nexports.allFieldDefinitionsInSelectionSet = allFieldDefinitionsInSelectionSet;\nfunction selectionSetOf(parentType, selection) {\n  const map = new Map();\n  map.set(selection.key(), selection);\n  return new SelectionSet(parentType, map);\n}\nexports.selectionSetOf = selectionSetOf;\nfunction selectionSetOfElement(element, subSelection) {\n  return selectionSetOf(element.parentType, selectionOfElement(element, subSelection));\n}\nexports.selectionSetOfElement = selectionSetOfElement;\nfunction selectionOfElement(element, subSelection) {\n  return element.kind === 'Field' ? new FieldSelection(element, subSelection) : new InlineFragmentSelection(element, subSelection);\n}\nexports.selectionOfElement = selectionOfElement;\nclass AbstractSelection {\n  constructor(element) {\n    this.element = element;\n  }\n  rebaseOnOrError({\n    parentType,\n    fragments\n  }) {\n    return this.rebaseOn({\n      parentType,\n      fragments,\n      errorIfCannotRebase: true\n    });\n  }\n  get parentType() {\n    return this.element.parentType;\n  }\n  isTypenameField() {\n    return false;\n  }\n  collectVariables(collector) {\n    var _a;\n    this.element.collectVariables(collector);\n    (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.collectVariables(collector);\n  }\n  collectUsedFragmentNames(collector) {\n    var _a;\n    (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.collectUsedFragmentNames(collector);\n  }\n  withUpdatedSelectionSet(selectionSet) {\n    return this.withUpdatedComponents(this.element, selectionSet);\n  }\n  withUpdatedElement(element) {\n    return this.withUpdatedComponents(element, this.selectionSet);\n  }\n  mapToSelectionSet(mapper) {\n    if (!this.selectionSet) {\n      return this.us();\n    }\n    const updatedSelectionSet = mapper(this.selectionSet);\n    return updatedSelectionSet === this.selectionSet ? this.us() : this.withUpdatedSelectionSet(updatedSelectionSet);\n  }\n  isFragmentSpread() {\n    return false;\n  }\n  minus(that) {\n    if (this.selectionSet && that.selectionSet) {\n      const updatedSubSelectionSet = this.selectionSet.minus(that.selectionSet);\n      if (!updatedSubSelectionSet.isEmpty()) {\n        return this.withUpdatedSelectionSet(updatedSubSelectionSet);\n      }\n    }\n    return undefined;\n  }\n  intersectionWith(that) {\n    if (this.selectionSet && that.selectionSet) {\n      const subSelectionSetIntersection = this.selectionSet.intersectionWith(that.selectionSet);\n      if (subSelectionSetIntersection.isEmpty()) {\n        return undefined;\n      } else {\n        return this.withUpdatedSelectionSet(subSelectionSetIntersection);\n      }\n    } else {\n      return this.us();\n    }\n  }\n  tryOptimizeSubselectionWithFragments({\n    parentType,\n    subSelection,\n    fragments,\n    validator,\n    canUseFullMatchingFragment\n  }) {\n    const candidates = fragments.maybeApplyingDirectlyAtType(parentType);\n    if (candidates.length === 0) {\n      return subSelection;\n    }\n    const applyingFragments = [];\n    for (const candidate of candidates) {\n      const atType = candidate.expandedSelectionSetAtType(parentType);\n      if (atType.selectionSet.isEmpty() || atType.selectionSet.selections().length === 1 && atType.selectionSet.selections()[0].isTypenameField()) {\n        continue;\n      }\n      const res = subSelection.contains(atType.selectionSet, {\n        ignoreMissingTypename: true\n      });\n      if (res === ContainsResult.EQUAL) {\n        if (canUseFullMatchingFragment(candidate)) {\n          if (!validator.checkCanReuseFragmentAndTrackIt(atType)) {\n            continue;\n          }\n          return candidate;\n        }\n        if (candidate.appliedDirectives.length === 0) {\n          applyingFragments.push({\n            fragment: candidate,\n            atType\n          });\n        }\n      } else if (res === ContainsResult.STRICTLY_CONTAINED && candidate.appliedDirectives.length === 0) {\n        applyingFragments.push({\n          fragment: candidate,\n          atType\n        });\n      }\n    }\n    if (applyingFragments.length === 0) {\n      return subSelection;\n    }\n    const filteredApplyingFragments = applyingFragments.filter(({\n      fragment\n    }) => !applyingFragments.some(o => o.fragment.includes(fragment.name)));\n    let notCoveredByFragments = subSelection;\n    const optimized = new SelectionSetUpdates();\n    for (const {\n      fragment,\n      atType\n    } of filteredApplyingFragments) {\n      if (!validator.checkCanReuseFragmentAndTrackIt(atType)) {\n        continue;\n      }\n      const notCovered = subSelection.minus(atType.selectionSet);\n      notCoveredByFragments = notCoveredByFragments.intersectionWith(notCovered);\n      optimized.add(new FragmentSpreadSelection(parentType, fragments, fragment, []));\n    }\n    return optimized.add(notCoveredByFragments).toSelectionSet(parentType, fragments);\n  }\n}\nclass FieldsConflictMultiBranchValidator {\n  constructor(validators) {\n    this.validators = validators;\n  }\n  static ofInitial(validator) {\n    return new FieldsConflictMultiBranchValidator([validator]);\n  }\n  forField(field) {\n    const forAllBranches = this.validators.flatMap(vs => vs.forField(field));\n    (0, utils_1.assert)(forAllBranches.length > 0, `Shoud have found at least one validator for ${field}`);\n    return new FieldsConflictMultiBranchValidator(forAllBranches);\n  }\n  checkCanReuseFragmentAndTrackIt(fragment) {\n    const validator = fragment.validator;\n    if (!validator) {\n      return true;\n    }\n    if (!this.validators.every(v => v.doMergeWith(validator))) {\n      return false;\n    }\n    if (this.usedSpreadTrimmedPartAtLevel) {\n      if (!this.usedSpreadTrimmedPartAtLevel.every(t => validator.doMergeWith(t))) {\n        return false;\n      }\n    } else {\n      this.usedSpreadTrimmedPartAtLevel = [];\n    }\n    this.usedSpreadTrimmedPartAtLevel.push(validator);\n    return true;\n  }\n}\nclass FieldsConflictValidator {\n  constructor(byResponseName) {\n    this.byResponseName = byResponseName;\n  }\n  static build(s) {\n    return FieldsConflictValidator.forLevel(s.fieldsInSet());\n  }\n  static forLevel(level) {\n    var _a;\n    const atLevel = new Map();\n    for (const {\n      field\n    } of level) {\n      const responseName = field.element.responseName();\n      let atResponseName = atLevel.get(responseName);\n      if (!atResponseName) {\n        atResponseName = new Map();\n        atLevel.set(responseName, atResponseName);\n      }\n      if (field.selectionSet) {\n        const forField = (_a = atResponseName.get(field.element)) !== null && _a !== void 0 ? _a : [];\n        atResponseName.set(field.element, forField.concat(field.selectionSet.fieldsInSet()));\n      } else {\n        atResponseName.set(field.element, null);\n      }\n    }\n    const byResponseName = new Map();\n    for (const [name, level] of atLevel.entries()) {\n      const atResponseName = new Map();\n      for (const [field, collectedFields] of level) {\n        const validator = collectedFields ? FieldsConflictValidator.forLevel(collectedFields) : null;\n        atResponseName.set(field, validator);\n      }\n      byResponseName.set(name, atResponseName);\n    }\n    return new FieldsConflictValidator(byResponseName);\n  }\n  forField(field) {\n    const byResponseName = this.byResponseName.get(field.responseName());\n    if (!byResponseName) {\n      return [];\n    }\n    return (0, utils_1.mapValues)(byResponseName).filter(v => !!v);\n  }\n  doMergeWith(that) {\n    var _a, _b;\n    for (const [responseName, thisFields] of this.byResponseName.entries()) {\n      const thatFields = that.byResponseName.get(responseName);\n      if (!thatFields) {\n        continue;\n      }\n      for (const [thisField, thisValidator] of thisFields.entries()) {\n        for (const [thatField, thatValidator] of thatFields.entries()) {\n          if (!(0, types_1.typesCanBeMerged)(thisField.definition.type, thatField.definition.type)) {\n            return false;\n          }\n          const p1 = thisField.parentType;\n          const p2 = thatField.parentType;\n          if ((0, types_1.sameType)(p1, p2) || !(0, definitions_1.isObjectType)(p1) || !(0, definitions_1.isObjectType)(p2)) {\n            if (thisField.name !== thatField.name || !(0, values_1.argumentsEquals)((_a = thisField.args) !== null && _a !== void 0 ? _a : {}, (_b = thatField.args) !== null && _b !== void 0 ? _b : {}) || thisValidator && thatValidator && !thisValidator.doMergeWith(thatValidator)) {\n              return false;\n            }\n          } else {\n            if (thisValidator && thatValidator && !thisValidator.hasSameResponseShapeThan(thatValidator)) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n  hasSameResponseShapeThan(that) {\n    for (const [responseName, thisFields] of this.byResponseName.entries()) {\n      const thatFields = that.byResponseName.get(responseName);\n      if (!thatFields) {\n        continue;\n      }\n      for (const [thisField, thisValidator] of thisFields.entries()) {\n        for (const [thatField, thatValidator] of thatFields.entries()) {\n          if (!(0, types_1.typesCanBeMerged)(thisField.definition.type, thatField.definition.type) || thisValidator && thatValidator && !thisValidator.hasSameResponseShapeThan(thatValidator)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  toString(indent = '') {\n    return '{\\n' + [...this.byResponseName.entries()].map(([name, byFields]) => {\n      const innerIndent = indent + '  ';\n      return `${innerIndent}${name}: [\\n` + [...byFields.entries()].map(([field, next]) => `${innerIndent}  ${field.parentType}.${field}${next ? next.toString(innerIndent + '  ') : ''}`).join('\\n') + `\\n${innerIndent}]`;\n    }).join('\\n') + `\\n${indent}}`;\n  }\n}\nclass FieldSelection extends AbstractSelection {\n  constructor(field, _selectionSet) {\n    super(field);\n    this._selectionSet = _selectionSet;\n    this.kind = 'FieldSelection';\n  }\n  get selectionSet() {\n    return this._selectionSet;\n  }\n  us() {\n    return this;\n  }\n  isTypenameField() {\n    return this.element.definition.name === definitions_1.typenameFieldName;\n  }\n  withUpdatedComponents(field, selectionSet) {\n    if (this.element === field && this.selectionSet === selectionSet) {\n      return this;\n    }\n    return new FieldSelection(field, selectionSet);\n  }\n  key() {\n    return this.element.key();\n  }\n  optimize(fragments, validator) {\n    const fieldBaseType = (0, definitions_1.baseType)(this.element.definition.type);\n    if (!(0, definitions_1.isCompositeType)(fieldBaseType) || !this.selectionSet) {\n      return this;\n    }\n    const fieldValidator = validator.forField(this.element);\n    const optimized = this.tryOptimizeSubselectionWithFragments({\n      parentType: fieldBaseType,\n      subSelection: this.selectionSet,\n      fragments,\n      validator: fieldValidator,\n      canUseFullMatchingFragment: fragment => fragment.appliedDirectives.length === 0\n    });\n    let optimizedSelection;\n    if (optimized instanceof NamedFragmentDefinition) {\n      optimizedSelection = selectionSetOf(fieldBaseType, new FragmentSpreadSelection(fieldBaseType, fragments, optimized, []));\n    } else {\n      optimizedSelection = optimized;\n    }\n    optimizedSelection = optimizedSelection.optimizeSelections(fragments, fieldValidator);\n    return this.selectionSet === optimizedSelection ? this : this.withUpdatedSelectionSet(optimizedSelection);\n  }\n  filterRecursiveDepthFirst(predicate) {\n    if (!this.selectionSet) {\n      return predicate(this) ? this : undefined;\n    }\n    const updatedSelectionSet = this.selectionSet.filterRecursiveDepthFirst(predicate);\n    const thisWithFilteredSelectionSet = this.selectionSet === updatedSelectionSet ? this : new FieldSelection(this.element, updatedSelectionSet);\n    return predicate(thisWithFilteredSelectionSet) ? thisWithFilteredSelectionSet : undefined;\n  }\n  validate(variableDefinitions) {\n    var _a;\n    this.element.validate(variableDefinitions);\n    validate(this.element.isLeafField() || this.selectionSet && !this.selectionSet.isEmpty(), () => `Invalid empty selection set for field \"${this.element.definition.coordinate}\" of non-leaf type ${this.element.definition.type}`, this.element.definition.sourceAST);\n    (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.validate(variableDefinitions);\n  }\n  rebaseOn({\n    parentType,\n    fragments,\n    errorIfCannotRebase\n  }) {\n    if (this.element.parentType === parentType) {\n      return this;\n    }\n    const rebasedElement = this.element.rebaseOn({\n      parentType,\n      errorIfCannotRebase\n    });\n    if (!rebasedElement) {\n      return undefined;\n    }\n    if (!this.selectionSet) {\n      return this.withUpdatedElement(rebasedElement);\n    }\n    const rebasedBase = rebasedElement.baseType();\n    if (rebasedBase === this.selectionSet.parentType) {\n      return this.withUpdatedElement(rebasedElement);\n    }\n    validate((0, definitions_1.isCompositeType)(rebasedBase), () => `Cannot rebase field selection ${this} on ${parentType}: rebased field base return type ${rebasedBase} is not composite`);\n    const rebasedSelectionSet = this.selectionSet.rebaseOn({\n      parentType: rebasedBase,\n      fragments,\n      errorIfCannotRebase\n    });\n    return rebasedSelectionSet.isEmpty() ? undefined : this.withUpdatedComponents(rebasedElement, rebasedSelectionSet);\n  }\n  canAddTo(parentType) {\n    if (this.element.parentType === parentType) {\n      return true;\n    }\n    const type = this.element.typeIfAddedTo(parentType);\n    if (!type) {\n      return false;\n    }\n    const base = (0, definitions_1.baseType)(type);\n    if (this.selectionSet && this.selectionSet.parentType !== base) {\n      (0, utils_1.assert)((0, definitions_1.isCompositeType)(base), () => `${this.element} should have a selection set as it's type is not a composite`);\n      return this.selectionSet.selections().every(s => s.canAddTo(base));\n    }\n    return true;\n  }\n  toSelectionNode() {\n    var _a;\n    const alias = this.element.alias ? {\n      kind: graphql_1.Kind.NAME,\n      value: this.element.alias\n    } : undefined;\n    return {\n      kind: graphql_1.Kind.FIELD,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: this.element.name\n      },\n      alias,\n      arguments: this.element.argumentsToNodes(),\n      directives: this.element.appliedDirectivesToDirectiveNodes(),\n      selectionSet: (_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.toSelectionSetNode()\n    };\n  }\n  withoutDefer(labelsToRemove) {\n    return this.mapToSelectionSet(s => s.withoutDefer(labelsToRemove));\n  }\n  withNormalizedDefer(normalizer) {\n    return this.mapToSelectionSet(s => s.withNormalizedDefer(normalizer));\n  }\n  hasDefer() {\n    var _a;\n    return !!((_a = this.selectionSet) === null || _a === void 0 ? void 0 : _a.hasDefer());\n  }\n  normalize({\n    parentType,\n    recursive\n  }) {\n    const definition = parentType === this.parentType ? this.element.definition : parentType.field(this.element.name);\n    (0, utils_1.assert)(definition, `Cannot normalize ${this.element} at ${parentType} which does not have that field`);\n    const element = this.element.definition === definition ? this.element : this.element.withUpdatedDefinition(definition);\n    if (!this.selectionSet) {\n      return this.withUpdatedElement(element);\n    }\n    const base = element.baseType();\n    (0, utils_1.assert)((0, definitions_1.isCompositeType)(base), () => `Field ${element} should not have a sub-selection`);\n    const normalizedSubSelection = (recursive !== null && recursive !== void 0 ? recursive : true) ? this.selectionSet.normalize({\n      parentType: base\n    }) : this.selectionSet;\n    if (normalizedSubSelection === null || normalizedSubSelection === void 0 ? void 0 : normalizedSubSelection.isEmpty()) {\n      return this.withUpdatedComponents(element, selectionSetOfElement(new Field(base.typenameField(), undefined, [new definitions_1.Directive('include', {\n        'if': false\n      })])));\n    } else {\n      return this.withUpdatedComponents(element, normalizedSubSelection);\n    }\n  }\n  expandFragments(updatedFragments) {\n    return this.mapToSelectionSet(s => s.expandFragments(updatedFragments));\n  }\n  equals(that) {\n    if (this === that) {\n      return true;\n    }\n    if (!(that instanceof FieldSelection) || !this.element.equals(that.element)) {\n      return false;\n    }\n    if (!this.selectionSet) {\n      return !that.selectionSet;\n    }\n    return !!that.selectionSet && this.selectionSet.equals(that.selectionSet);\n  }\n  contains(that, options) {\n    if (!(that instanceof FieldSelection) || !this.element.equals(that.element)) {\n      return ContainsResult.NOT_CONTAINED;\n    }\n    if (!this.selectionSet) {\n      (0, utils_1.assert)(!that.selectionSet, '`this` and `that` have the same element, so if one does not have a sub-selection, neither should the other one');\n      return ContainsResult.EQUAL;\n    }\n    (0, utils_1.assert)(that.selectionSet, '`this` and `that` have the same element, so if one has sub-selection, the other one should too');\n    return this.selectionSet.contains(that.selectionSet, options);\n  }\n  toString(expandFragments = true, indent) {\n    return (indent !== null && indent !== void 0 ? indent : '') + this.element + (this.selectionSet ? ' ' + this.selectionSet.toString(expandFragments, true, indent) : '');\n  }\n}\nexports.FieldSelection = FieldSelection;\nclass FragmentSelection extends AbstractSelection {\n  constructor() {\n    super(...arguments);\n    this.kind = 'FragmentSelection';\n  }\n  us() {\n    return this;\n  }\n  validateDeferAndStream() {\n    if (this.element.hasDefer() || this.element.hasStream()) {\n      const schemaDef = this.element.schema().schemaDefinition;\n      const parentType = this.parentType;\n      validate(schemaDef.rootType('mutation') !== parentType && schemaDef.rootType('subscription') !== parentType, () => {\n        var _a;\n        return `The @defer and @stream directives cannot be used on ${(_a = schemaDef.roots().filter(t => t.type === parentType).pop()) === null || _a === void 0 ? void 0 : _a.rootKind} root type \"${parentType}\"`;\n      });\n    }\n  }\n  filterRecursiveDepthFirst(predicate) {\n    const updatedSelectionSet = this.selectionSet.filterRecursiveDepthFirst(predicate);\n    const thisWithFilteredSelectionSet = updatedSelectionSet === this.selectionSet ? this : new InlineFragmentSelection(this.element, updatedSelectionSet);\n    return predicate(thisWithFilteredSelectionSet) ? thisWithFilteredSelectionSet : undefined;\n  }\n  hasDefer() {\n    return this.element.hasDefer() || this.selectionSet.hasDefer();\n  }\n  normalize({\n    parentType,\n    recursive\n  }) {\n    const thisCondition = this.element.typeCondition;\n    if (thisCondition && parentType !== this.parentType) {\n      const conditionRuntimes = (0, definitions_1.possibleRuntimeTypes)(thisCondition);\n      const typeRuntimes = (0, definitions_1.possibleRuntimeTypes)(parentType);\n      if (!conditionRuntimes.some(t => typeRuntimes.includes(t))) {\n        return undefined;\n      }\n    }\n    return this.normalizeKnowingItIntersects({\n      parentType,\n      recursive\n    });\n  }\n}\nexports.FragmentSelection = FragmentSelection;\nclass InlineFragmentSelection extends FragmentSelection {\n  constructor(fragment, _selectionSet) {\n    super(fragment);\n    this._selectionSet = _selectionSet;\n  }\n  get selectionSet() {\n    return this._selectionSet;\n  }\n  key() {\n    return this.element.key();\n  }\n  withUpdatedComponents(fragment, selectionSet) {\n    if (fragment === this.element && selectionSet === this.selectionSet) {\n      return this;\n    }\n    return new InlineFragmentSelection(fragment, selectionSet);\n  }\n  validate(variableDefinitions) {\n    this.validateDeferAndStream();\n    validate(!this.selectionSet.isEmpty(), () => `Invalid empty selection set for fragment \"${this.element}\"`);\n    this.selectionSet.validate(variableDefinitions);\n  }\n  rebaseOn({\n    parentType,\n    fragments,\n    errorIfCannotRebase\n  }) {\n    if (this.parentType === parentType) {\n      return this;\n    }\n    const rebasedFragment = this.element.rebaseOn({\n      parentType,\n      errorIfCannotRebase\n    });\n    if (!rebasedFragment) {\n      return undefined;\n    }\n    const rebasedCastedType = rebasedFragment.castedType();\n    if (rebasedCastedType === this.selectionSet.parentType) {\n      return this.withUpdatedElement(rebasedFragment);\n    }\n    const rebasedSelectionSet = this.selectionSet.rebaseOn({\n      parentType: rebasedCastedType,\n      fragments,\n      errorIfCannotRebase\n    });\n    return rebasedSelectionSet.isEmpty() ? undefined : this.withUpdatedComponents(rebasedFragment, rebasedSelectionSet);\n  }\n  canAddTo(parentType) {\n    if (this.element.parentType === parentType) {\n      return true;\n    }\n    const type = this.element.castedTypeIfAddedTo(parentType);\n    if (!type) {\n      return false;\n    }\n    if (this.selectionSet.parentType !== type) {\n      return this.selectionSet.selections().every(s => s.canAddTo(type));\n    }\n    return true;\n  }\n  toSelectionNode() {\n    const typeCondition = this.element.typeCondition;\n    return {\n      kind: graphql_1.Kind.INLINE_FRAGMENT,\n      typeCondition: typeCondition ? {\n        kind: graphql_1.Kind.NAMED_TYPE,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: typeCondition.name\n        }\n      } : undefined,\n      directives: this.element.appliedDirectivesToDirectiveNodes(),\n      selectionSet: this.selectionSet.toSelectionSetNode()\n    };\n  }\n  optimize(fragments, validator) {\n    let optimizedSelection = this.selectionSet;\n    const typeCondition = this.element.typeCondition;\n    if (typeCondition) {\n      const optimized = this.tryOptimizeSubselectionWithFragments({\n        parentType: typeCondition,\n        subSelection: optimizedSelection,\n        fragments,\n        validator,\n        canUseFullMatchingFragment: fragment => {\n          return fragment.appliedDirectives.length === 0 || (0, types_1.sameType)(typeCondition, fragment.typeCondition) && fragment.appliedDirectives.every(d => this.element.appliedDirectives.some(s => (0, definitions_1.sameDirectiveApplication)(d, s)));\n        }\n      });\n      if (optimized instanceof NamedFragmentDefinition) {\n        if ((0, types_1.sameType)(typeCondition, optimized.typeCondition)) {\n          let spreadDirectives = this.element.appliedDirectives;\n          if (optimized.appliedDirectives) {\n            spreadDirectives = spreadDirectives.filter(s => !optimized.appliedDirectives.some(d => (0, definitions_1.sameDirectiveApplication)(d, s)));\n          }\n          return new FragmentSpreadSelection(this.parentType, fragments, optimized, spreadDirectives);\n        } else {\n          optimizedSelection = selectionSetOf(typeCondition, new FragmentSpreadSelection(typeCondition, fragments, optimized, []));\n        }\n      } else {\n        optimizedSelection = optimized;\n      }\n    }\n    optimizedSelection = optimizedSelection.optimizeSelections(fragments, validator);\n    return this.selectionSet === optimizedSelection ? this : new InlineFragmentSelection(this.element, optimizedSelection);\n  }\n  withoutDefer(labelsToRemove) {\n    const newSelection = this.selectionSet.withoutDefer(labelsToRemove);\n    const deferArgs = this.element.deferDirectiveArgs();\n    const hasDeferToRemove = deferArgs && (!labelsToRemove || deferArgs.label && labelsToRemove.has(deferArgs.label));\n    if (newSelection === this.selectionSet && !hasDeferToRemove) {\n      return this;\n    }\n    const newElement = hasDeferToRemove ? this.element.withoutDefer() : this.element;\n    if (!newElement) {\n      return newSelection;\n    }\n    return this.withUpdatedComponents(newElement, newSelection);\n  }\n  withNormalizedDefer(normalizer) {\n    const newElement = this.element.withNormalizedDefer(normalizer);\n    const newSelection = this.selectionSet.withNormalizedDefer(normalizer);\n    if (!newElement) {\n      return newSelection;\n    }\n    return newElement === this.element && newSelection === this.selectionSet ? this : this.withUpdatedComponents(newElement, newSelection);\n  }\n  normalizeKnowingItIntersects({\n    parentType,\n    recursive\n  }) {\n    var _a;\n    const thisCondition = this.element.typeCondition;\n    if (this.element.appliedDirectives.length === 0) {\n      if (!thisCondition || parentType === this.element.typeCondition || (0, definitions_1.isObjectType)(parentType)) {\n        const normalized = this.selectionSet.normalize({\n          parentType,\n          recursive\n        });\n        return normalized.isEmpty() ? undefined : normalized;\n      }\n    }\n    let normalizedSelectionSet;\n    if (recursive !== null && recursive !== void 0 ? recursive : true) {\n      normalizedSelectionSet = this.selectionSet.normalize({\n        parentType: thisCondition !== null && thisCondition !== void 0 ? thisCondition : parentType\n      });\n      if (normalizedSelectionSet.isEmpty()) {\n        if (this.element.appliedDirectives.length === 0) {\n          return undefined;\n        } else {\n          return this.withUpdatedComponents(this.element.rebaseOnOrError(parentType), selectionSetOfElement(new Field(((_a = this.element.typeCondition) !== null && _a !== void 0 ? _a : parentType).typenameField(), undefined, [new definitions_1.Directive('include', {\n            'if': false\n          })])));\n        }\n      }\n    } else {\n      normalizedSelectionSet = this.selectionSet;\n    }\n    if (this.element.appliedDirectives.length === 0 && (0, definitions_1.isAbstractType)(thisCondition)) {\n      (0, utils_1.assert)(!(0, definitions_1.isObjectType)(parentType), () => `Should not have got here if ${parentType} is an object type`);\n      const currentRuntimes = (0, definitions_1.possibleRuntimeTypes)(parentType);\n      const liftableSelections = [];\n      for (const selection of normalizedSelectionSet.selections()) {\n        if (selection.kind === 'FragmentSelection' && selection.element.typeCondition && (0, definitions_1.isObjectType)(selection.element.typeCondition) && currentRuntimes.includes(selection.element.typeCondition)) {\n          liftableSelections.push(selection);\n        }\n      }\n      if (liftableSelections.length === normalizedSelectionSet.selections().length) {\n        return normalizedSelectionSet;\n      }\n      if (liftableSelections.length > 0) {\n        const newSet = new SelectionSetUpdates();\n        newSet.add(liftableSelections);\n        newSet.add(this.withUpdatedSelectionSet(normalizedSelectionSet.filter(s => !liftableSelections.includes(s))));\n        return newSet.toSelectionSet(parentType);\n      }\n    }\n    return this.parentType === parentType && this.selectionSet === normalizedSelectionSet ? this : this.withUpdatedComponents(this.element.rebaseOnOrError(parentType), normalizedSelectionSet);\n  }\n  expandFragments(updatedFragments) {\n    return this.mapToSelectionSet(s => s.expandFragments(updatedFragments));\n  }\n  equals(that) {\n    if (this === that) {\n      return true;\n    }\n    return that instanceof FragmentSelection && this.element.equals(that.element) && this.selectionSet.equals(that.selectionSet);\n  }\n  contains(that, options) {\n    if (!(that instanceof FragmentSelection) || !this.element.equals(that.element)) {\n      return ContainsResult.NOT_CONTAINED;\n    }\n    return this.selectionSet.contains(that.selectionSet, options);\n  }\n  toString(expandFragments = true, indent) {\n    return (indent !== null && indent !== void 0 ? indent : '') + this.element + ' ' + this.selectionSet.toString(expandFragments, true, indent);\n  }\n}\nclass FragmentSpreadSelection extends FragmentSelection {\n  constructor(sourceType, fragments, namedFragment, spreadDirectives) {\n    super(new FragmentElement(sourceType, namedFragment.typeCondition, namedFragment.appliedDirectives.concat(spreadDirectives)));\n    this.fragments = fragments;\n    this.namedFragment = namedFragment;\n    this.spreadDirectives = spreadDirectives;\n  }\n  isFragmentSpread() {\n    return true;\n  }\n  get selectionSet() {\n    return this.namedFragment.selectionSet;\n  }\n  key() {\n    if (!this.computedKey) {\n      this.computedKey = '...' + this.namedFragment.name + (this.spreadDirectives.length === 0 ? '' : ' ' + this.spreadDirectives.join(' '));\n    }\n    return this.computedKey;\n  }\n  withUpdatedComponents(_fragment, _selectionSet) {\n    (0, utils_1.assert)(false, `Unsupported`);\n  }\n  normalizeKnowingItIntersects({\n    parentType\n  }) {\n    (0, utils_1.assert)(parentType.schema() === this.parentType.schema(), 'Should not try to normalize using a type from another schema');\n    return this.rebaseOnOrError({\n      parentType,\n      fragments: this.fragments\n    });\n  }\n  validate() {\n    this.validateDeferAndStream();\n    validate((0, definitions_1.runtimeTypesIntersects)(this.parentType, this.namedFragment.typeCondition), () => `Fragment \"${this.namedFragment.name}\" cannot be spread inside type ${this.parentType} as the runtime types do not intersect ${this.namedFragment.typeCondition}`);\n  }\n  toSelectionNode() {\n    const directiveNodes = this.spreadDirectives.length === 0 ? undefined : this.spreadDirectives.map(directive => {\n      return {\n        kind: graphql_1.Kind.DIRECTIVE,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: directive.name\n        },\n        arguments: directive.argumentsToAST()\n      };\n    });\n    return {\n      kind: graphql_1.Kind.FRAGMENT_SPREAD,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: this.namedFragment.name\n      },\n      directives: directiveNodes\n    };\n  }\n  optimize(_1, _2) {\n    return this;\n  }\n  rebaseOn({\n    parentType,\n    fragments,\n    errorIfCannotRebase\n  }) {\n    if (this.parentType === parentType) {\n      return this;\n    }\n    const rebaseOnSameSchema = this.parentType.schema() === parentType.schema();\n    (0, utils_1.assert)(fragments || rebaseOnSameSchema, `Must provide fragments is rebasing on other schema`);\n    const newFragments = fragments !== null && fragments !== void 0 ? fragments : this.fragments;\n    const namedFragment = newFragments.get(this.namedFragment.name);\n    if (!namedFragment) {\n      validate(!errorIfCannotRebase, () => `Cannot rebase ${this.toString(false)} if it isn't part of the provided fragments`);\n      return undefined;\n    }\n    if (!rebaseOnSameSchema && !(0, definitions_1.runtimeTypesIntersects)(parentType, namedFragment.typeCondition)) {\n      const expanded = this.namedFragment.selectionSet.rebaseOn({\n        parentType,\n        fragments,\n        errorIfCannotRebase\n      });\n      return expanded.isEmpty() ? undefined : new InlineFragmentSelection(new FragmentElement(parentType), expanded);\n    }\n    return new FragmentSpreadSelection(parentType, newFragments, namedFragment, this.spreadDirectives);\n  }\n  canAddTo(_) {\n    return true;\n  }\n  expandFragments(updatedFragments) {\n    if (updatedFragments === null || updatedFragments === void 0 ? void 0 : updatedFragments.has(this.namedFragment.name)) {\n      return this;\n    }\n    const expandedSubSelections = this.selectionSet.expandFragments(updatedFragments);\n    return (0, types_1.sameType)(this.parentType, this.namedFragment.typeCondition) && this.element.appliedDirectives.length === 0 ? expandedSubSelections.selections() : new InlineFragmentSelection(this.element, expandedSubSelections);\n  }\n  collectUsedFragmentNames(collector) {\n    const usageCount = collector.get(this.namedFragment.name);\n    collector.set(this.namedFragment.name, usageCount === undefined ? 1 : usageCount + 1);\n  }\n  withoutDefer(_labelsToRemove) {\n    (0, utils_1.assert)(false, 'Unsupported, see `Operation.withAllDeferLabelled`');\n  }\n  withNormalizedDefer(_normalizer) {\n    (0, utils_1.assert)(false, 'Unsupported, see `Operation.withAllDeferLabelled`');\n  }\n  minus(that) {\n    (0, utils_1.assert)(this.equals(that), () => `Invalid operation for ${this.toString(false)} and ${that.toString(false)}`);\n    return undefined;\n  }\n  equals(that) {\n    if (this === that) {\n      return true;\n    }\n    return that instanceof FragmentSpreadSelection && this.namedFragment.name === that.namedFragment.name && (0, definitions_1.sameDirectiveApplications)(this.spreadDirectives, that.spreadDirectives);\n  }\n  contains(that, options) {\n    if (this.equals(that)) {\n      return ContainsResult.EQUAL;\n    }\n    if (!(that instanceof FragmentSelection) || !this.element.equals(that.element)) {\n      return ContainsResult.NOT_CONTAINED;\n    }\n    return this.selectionSet.contains(that.selectionSet, options);\n  }\n  toString(expandFragments = true, indent) {\n    if (expandFragments) {\n      return (indent !== null && indent !== void 0 ? indent : '') + this.element + ' ' + this.selectionSet.toString(true, true, indent);\n    } else {\n      const directives = this.spreadDirectives;\n      const directiveString = directives.length == 0 ? '' : ' ' + directives.join(' ');\n      return (indent !== null && indent !== void 0 ? indent : '') + '...' + this.namedFragment.name + directiveString;\n    }\n  }\n}\nfunction selectionSetOfNode(parentType, node, variableDefinitions, fragments, fieldAccessor = (type, name) => type.field(name)) {\n  if (node.selections.length === 1) {\n    return selectionSetOf(parentType, selectionOfNode(parentType, node.selections[0], variableDefinitions, fragments, fieldAccessor));\n  }\n  const selections = new SelectionSetUpdates();\n  for (const selectionNode of node.selections) {\n    selections.add(selectionOfNode(parentType, selectionNode, variableDefinitions, fragments, fieldAccessor));\n  }\n  return selections.toSelectionSet(parentType, fragments);\n}\nfunction directiveOfNode(schema, node) {\n  const directiveDef = schema.directive(node.name.value);\n  validate(directiveDef, () => `Unknown directive \"@${node.name.value}\"`);\n  return new definitions_1.Directive(directiveDef.name, (0, values_1.argumentsFromAST)(directiveDef.coordinate, node.arguments, directiveDef));\n}\nfunction directivesOfNodes(schema, nodes) {\n  var _a;\n  return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map(n => directiveOfNode(schema, n))) !== null && _a !== void 0 ? _a : [];\n}\nfunction selectionOfNode(parentType, node, variableDefinitions, fragments, fieldAccessor = (type, name) => type.field(name)) {\n  var _a, _b;\n  let selection;\n  const directives = directivesOfNodes(parentType.schema(), node.directives);\n  switch (node.kind) {\n    case graphql_1.Kind.FIELD:\n      const definition = fieldAccessor(parentType, node.name.value);\n      validate(definition, () => `Cannot query field \"${node.name.value}\" on type \"${parentType}\".`, parentType.sourceAST);\n      const type = (0, definitions_1.baseType)(definition.type);\n      const selectionSet = node.selectionSet ? selectionSetOfNode(type, node.selectionSet, variableDefinitions, fragments, fieldAccessor) : undefined;\n      selection = new FieldSelection(new Field(definition, (0, values_1.argumentsFromAST)(definition.coordinate, node.arguments, definition), directives, (_a = node.alias) === null || _a === void 0 ? void 0 : _a.value), selectionSet);\n      break;\n    case graphql_1.Kind.INLINE_FRAGMENT:\n      const element = new FragmentElement(parentType, (_b = node.typeCondition) === null || _b === void 0 ? void 0 : _b.name.value, directives);\n      selection = new InlineFragmentSelection(element, selectionSetOfNode(element.typeCondition ? element.typeCondition : element.parentType, node.selectionSet, variableDefinitions, fragments, fieldAccessor));\n      break;\n    case graphql_1.Kind.FRAGMENT_SPREAD:\n      const fragmentName = node.name.value;\n      validate(fragments, () => `Cannot find fragment name \"${fragmentName}\" (no fragments were provided)`);\n      const fragment = fragments.get(fragmentName);\n      validate(fragment, () => `Cannot find fragment name \"${fragmentName}\" (provided fragments are: [${fragments.names().join(', ')}])`);\n      selection = new FragmentSpreadSelection(parentType, fragments, fragment, directives);\n      break;\n  }\n  return selection;\n}\nfunction operationFromDocument(schema, document, options) {\n  let operation;\n  const operationName = options === null || options === void 0 ? void 0 : options.operationName;\n  const fragments = new NamedFragments();\n  document.definitions.forEach(definition => {\n    switch (definition.kind) {\n      case graphql_1.Kind.OPERATION_DEFINITION:\n        validate(!operation || operationName, () => 'Must provide operation name if query contains multiple operations.');\n        if (!operationName || definition.name && definition.name.value === operationName) {\n          operation = definition;\n        }\n        break;\n      case graphql_1.Kind.FRAGMENT_DEFINITION:\n        const name = definition.name.value;\n        const typeName = definition.typeCondition.name.value;\n        const typeCondition = schema.type(typeName);\n        if (!typeCondition) {\n          throw error_1.ERRORS.INVALID_GRAPHQL.err(`Unknown type \"${typeName}\" for fragment \"${name}\"`, {\n            nodes: definition\n          });\n        }\n        if (!(0, definitions_1.isCompositeType)(typeCondition)) {\n          throw error_1.ERRORS.INVALID_GRAPHQL.err(`Invalid fragment \"${name}\" on non-composite type \"${typeName}\"`, {\n            nodes: definition\n          });\n        }\n        fragments.add(new NamedFragmentDefinition(schema, name, typeCondition, directivesOfNodes(schema, definition.directives)));\n        break;\n    }\n  });\n  validate(operation, () => operationName ? `Unknown operation named \"${operationName}\"` : 'No operation found in provided document.');\n  const variableDefinitions = operation.variableDefinitions ? (0, definitions_1.variableDefinitionsFromAST)(schema, operation.variableDefinitions) : new definitions_1.VariableDefinitions();\n  document.definitions.forEach(definition => {\n    switch (definition.kind) {\n      case graphql_1.Kind.FRAGMENT_DEFINITION:\n        const fragment = fragments.get(definition.name.value);\n        fragment.setSelectionSet(selectionSetOfNode(fragment.typeCondition, definition.selectionSet, variableDefinitions, fragments));\n        break;\n    }\n  });\n  fragments.validate(variableDefinitions);\n  return operationFromAST({\n    schema,\n    operation,\n    variableDefinitions,\n    fragments,\n    validateInput: options === null || options === void 0 ? void 0 : options.validate\n  });\n}\nexports.operationFromDocument = operationFromDocument;\nfunction operationFromAST({\n  schema,\n  operation,\n  variableDefinitions,\n  fragments,\n  validateInput\n}) {\n  var _a;\n  const rootType = schema.schemaDefinition.root(operation.operation);\n  validate(rootType, () => `The schema has no \"${operation.operation}\" root type defined`);\n  const fragmentsIfAny = fragments.isEmpty() ? undefined : fragments;\n  return new Operation(schema, operation.operation, parseSelectionSet({\n    parentType: rootType.type,\n    source: operation.selectionSet,\n    variableDefinitions,\n    fragments: fragmentsIfAny,\n    validate: validateInput\n  }), variableDefinitions, fragmentsIfAny, (_a = operation.name) === null || _a === void 0 ? void 0 : _a.value);\n}\nfunction parseOperation(schema, operation, options) {\n  return operationFromDocument(schema, (0, graphql_1.parse)(operation), options);\n}\nexports.parseOperation = parseOperation;\nfunction parseSelectionSet({\n  parentType,\n  source,\n  variableDefinitions = new definitions_1.VariableDefinitions(),\n  fragments,\n  fieldAccessor,\n  validate = true\n}) {\n  const node = typeof source === 'string' ? parseOperationAST(source.trim().startsWith('{') ? source : `{${source}}`).selectionSet : source;\n  const selectionSet = selectionSetOfNode(parentType, node, variableDefinitions !== null && variableDefinitions !== void 0 ? variableDefinitions : new definitions_1.VariableDefinitions(), fragments, fieldAccessor);\n  if (validate) selectionSet.validate(variableDefinitions);\n  return selectionSet;\n}\nexports.parseSelectionSet = parseSelectionSet;\nfunction parseOperationAST(source) {\n  const parsed = (0, graphql_1.parse)(source);\n  validate(parsed.definitions.length === 1, () => 'Selections should contain a single definitions, found ' + parsed.definitions.length);\n  const def = parsed.definitions[0];\n  validate(def.kind === graphql_1.Kind.OPERATION_DEFINITION, () => 'Expected an operation definition but got a ' + def.kind);\n  return def;\n}\nfunction operationToDocument(operation) {\n  var _a;\n  const operationAST = {\n    kind: graphql_1.Kind.OPERATION_DEFINITION,\n    operation: operation.rootKind,\n    name: operation.name ? {\n      kind: graphql_1.Kind.NAME,\n      value: operation.name\n    } : undefined,\n    selectionSet: operation.selectionSet.toSelectionSetNode(),\n    variableDefinitions: operation.variableDefinitions.toVariableDefinitionNodes()\n  };\n  const fragmentASTs = operation.fragments ? (_a = operation.fragments) === null || _a === void 0 ? void 0 : _a.toFragmentDefinitionNodes() : [];\n  return {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [operationAST].concat(fragmentASTs)\n  };\n}\nexports.operationToDocument = operationToDocument;","map":{"version":3,"mappings":"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","names":["graphql_1","require","definitions_1","federation_1","error_1","types_1","utils_1","values_1","uuid_1","validate","condition","message","sourceAST","ERRORS","INVALID_GRAPHQL","err","nodes","haveSameDirectives","op1","op2","sameDirectiveApplications","appliedDirectives","AbstractOperationElement","DirectiveTargetElement","constructor","schema","directives","collectVariables","collector","collectVariablesInElement","collectVariablesInAppliedDirectives","rebaseOnOrError","parentType","rebaseOn","errorIfCannotRebase","addAttachement","key","value","attachements","Map","set","getAttachement","_a","get","copyAttachementsTo","elt","k","v","entries","keyForDirectives","map","d","keyForDirective","join","Field","definition","args","alias","kind","collectInArguments","name","argumentValue","undefined","responseName","asPathElement","parent","isLeafField","isLeafType","baseType","type","withUpdatedDefinition","newDefinition","newField","withUpdatedAlias","newAlias","withUpdatedDirectives","newDirectives","argumentsToNodes","Object","length","n","Kind","ARGUMENT","NAME","valueToAST","argument","appliesTo","field","selects","assumeValid","variableDefinitions","assert","argDef","arguments","appliedValue","defaultValue","isNullableType","isValidValue","coordinate","valueToString","fieldParent","typenameFieldName","typenameField","fieldDef","canRebase","canRebaseOn","fieldParentType","isInterfaceType","isInterfaceObjectType","typeIfAddedTo","_b","hasDefer","deferDirectiveArgs","withoutDefer","equals","that","argumentsEquals","toString","appliedDirectivesToString","exports","directive","directivesNeverEqualToThemselves","includes","v1","filter","_","sort","n1","n2","localeCompare","argumentType","FragmentElement","sourceType","typeCondition","computedKey","castedType","withUpdatedSourceType","newSourceType","withUpdatedTypes","withUpdatedCondition","newCondition","newFragment","fragmentParent","rebasedCondition","possibleRuntimeTypes","isCompositeType","runtimeTypesIntersects","castedTypeIfAddedTo","hasAppliedDirective","hasStream","appliedDirectivesOf","deferDirective","deferName","updatedDirectives","updated","withNormalizedDefer","normalizer","deferArgs","newDeferArgs","conditionVariable","if","label","newLabel","registerCondition","concat","Directive","operationPathToStringPath","path","p","sameOperationPaths","p1","p2","i","conditionalDirectivesInOperationPath","e","flat","isConditionalDirective","concatOperationPaths","head","tail","lastOfHead","conditionals","firstOfTail","isUselessFollowupElement","slice","first","followup","typeOfFirst","isDirectiveApplicationsSubset","isSubtype","computeFragmentsDependents","fragments","reverseDeps","SetMultiMap","fragment","definitions","dependency","fragmentUsages","keys","add","clearKeptFragments","usages","minUsagesToOptimize","toCheck","Array","from","count","newToCheck","delete","ownUsages","otherName","otherCount","prevCount","newCount","push","computeFragmentsToKeep","selectionSet","collectUsedFragmentNames","size","reverseDependencies","toExpand","Set","shouldContinue","mapKeys","fragmentsUsingName","every","fragName","has","nameUsages","prev","f","Operation","rootKind","withUpdatedSelectionSet","newSelectionSet","withUpdatedSelectionSetAndFragments","newFragments","optimize","isEmpty","optimizedSelection","finalFragments","expandFragments","normalize","beforeRemoval","expandAllFragments","expanded","labelsToRemove","DeferNormalizer","hasDefers","hasNonLabelledOrConditionalDefers","init","updatedOperation","operation","assignedDeferLabels","assignedLabels","deferConditions","collectDefaultedVariableValues","defaultedVariableValues","variable","prettyPrint","toOperationString","NamedFragmentDefinition","expandedSelectionSetsAtTypesCache","setSelectionSet","_selectionSet","_fragmentUsages","toFragmentDefinitionNode","FRAGMENT_DEFINITION","NAMED_TYPE","toSelectionSetNode","canApplyDirectlyAtType","sameType","isAbstractType","conditionRuntimes","typeRuntimes","t1","some","t2","isObjectType","isUnionType","expandedSelectionSet","_expandedSelectionSet","expandedSelectionSetAtType","cached","computeExpandedSelectionSetAtType","trimmed","minus","validator","FieldsConflictValidator","build","otherFragment","_includedFragmentNames","computeIncludedFragmentNames","included","selection","selections","FragmentSpreadSelection","namedFragment","indent","NamedFragments","MapWithCachedArrays","names","addIfNotExist","maybeApplyingDirectlyAtType","values","mapper","mapped","def","mapInDependencyOrder","fragmentsMap","dependsOn","removedFragments","mappedFragments","info","mapToExpandedSelectionSets","mappedSelectionSet","reoptimizedSelectionSet","selectionSetIsWorthUsing","s","element","rebasedType","rebasedSelection","predicate","updatedSelectionSet","toFragmentDefinitionNodes","index","usedLabels","stack","pop","forEach","nextLabel","candidate","ContainsResult","SelectionSet","keyedSelections","_keyedSelections","_selections","mapValues","selectionsInReverseOrder","reversed","hasTopLevelTypenameField","withoutTopLevelTypenameField","newKeyedSelections","fieldsInSet","fields","header","fieldsByResponseName","byResponseName","MultiMap","collectFieldsByResponseName","usedVariables","VariableCollector","variables","wrapped","InlineFragmentSelection","FieldsConflictMultiBranchValidator","ofInitial","optimized","selectionSetOf","optimizeSelections","lazyMap","updatedFragments","recursive","options","updatedSelections","SelectionSetUpdates","j","toSelectionSet","filterRecursiveDepthFirst","withoutEmptyBranches","newSelections","thisSelection","thatSelection","contains","ignoreMissingTypename","NOT_CONTAINED","isEqual","didIgnoreTypename","selectionResult","EQUAL","STRICTLY_CONTAINED","containsTopLevelField","remainder","intersectionWith","intersection","parentTypeToTest","canAddTo","SELECTION_SET","FIELD","selectionsInPrintOrder","toSelectionNode","isNonAliasedTypenameSelection","typenameSelection","find","toOperationPaths","toOperationPathsInternal","parentPaths","flatMap","updatedPaths","forEachElement","callback","operationName","fragmentsDefinitions","nameAndVariables","includeExternalBrackets","selectionsToString","selectionIndent","keyedUpdates","addToKeyedUpdates","addAtPath","selectionOfElement","clone","cloned","clear","makeSelectionSet","updates","updStr","upd","AbstractSelection","addOneToKeyedUpdates","toAdd","maybeRebaseOnSchema","toRebase","rebased","isUnecessaryFragment","withUnecessaryFragmentsRemoved","filtered","subSelections","subSelection","makeSelection","updateElement","subSelectionParentType","subSelectionKeyedUpdates","update","addSubpathToKeyUpdates","pathUpdate","MutableSelectionSet","_updates","memoizer","empty","emptyWithMemoized","of","ofWithMemoized","computed","_memoized","memoized","allFieldDefinitionsInSelectionSet","allFields","selectionSetOfElement","FieldSelection","isTypenameField","withUpdatedComponents","withUpdatedElement","mapToSelectionSet","us","isFragmentSpread","updatedSubSelectionSet","subSelectionSetIntersection","tryOptimizeSubselectionWithFragments","canUseFullMatchingFragment","candidates","applyingFragments","atType","res","checkCanReuseFragmentAndTrackIt","filteredApplyingFragments","o","notCoveredByFragments","notCovered","validators","forField","forAllBranches","vs","doMergeWith","usedSpreadTrimmedPartAtLevel","t","forLevel","level","atLevel","atResponseName","collectedFields","thisFields","thatFields","thisField","thisValidator","thatField","thatValidator","typesCanBeMerged","hasSameResponseShapeThan","byFields","innerIndent","next","fieldBaseType","fieldValidator","thisWithFilteredSelectionSet","rebasedElement","rebasedBase","rebasedSelectionSet","base","appliedDirectivesToDirectiveNodes","normalizedSubSelection","FragmentSelection","validateDeferAndStream","schemaDef","schemaDefinition","rootType","roots","thisCondition","normalizeKnowingItIntersects","rebasedFragment","rebasedCastedType","INLINE_FRAGMENT","sameDirectiveApplication","spreadDirectives","newSelection","hasDeferToRemove","newElement","normalized","normalizedSelectionSet","currentRuntimes","liftableSelections","newSet","_fragment","directiveNodes","DIRECTIVE","argumentsToAST","FRAGMENT_SPREAD","_1","_2","rebaseOnSameSchema","expandedSubSelections","usageCount","_labelsToRemove","_normalizer","directiveString","selectionSetOfNode","node","fieldAccessor","selectionOfNode","selectionNode","directiveOfNode","directiveDef","argumentsFromAST","directivesOfNodes","fragmentName","operationFromDocument","document","OPERATION_DEFINITION","typeName","variableDefinitionsFromAST","VariableDefinitions","operationFromAST","validateInput","root","fragmentsIfAny","parseSelectionSet","source","parseOperation","parse","parseOperationAST","trim","startsWith","parsed","operationToDocument","operationAST","toVariableDefinitionNodes","fragmentASTs","DOCUMENT"],"sourceRoot":"","sources":["../src/operations.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}