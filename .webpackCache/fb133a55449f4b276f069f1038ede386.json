{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Parser = void 0;\nexports.parse = parse;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseValue = parseValue;\nvar _syntaxError = require('../error/syntaxError.js');\nvar _ast = require('./ast.js');\nvar _directiveLocation = require('./directiveLocation.js');\nvar _kinds = require('./kinds.js');\nvar _lexer = require('./lexer.js');\nvar _source = require('./source.js');\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nfunction parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nclass Parser {\n  constructor(source, options) {\n    const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);\n    this._lexer = new _lexer.Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return this.node(token, {\n      kind: _kinds.Kind.NAME,\n      value: token.value\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF)\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n        case 'type':\n          return this.parseObjectTypeDefinition();\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n        case 'union':\n          return this.parseUnionTypeDefinition();\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n      if (hasDescription) {\n        throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');\n      }\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n        case 'fragment':\n          return this.parseFragmentDefinition();\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: _ast.OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    const operation = this.parseOperationType();\n    let name;\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n    switch (operationToken.value) {\n      case 'query':\n        return _ast.OperationTypeNode.QUERY;\n      case 'mutation':\n        return _ast.OperationTypeNode.MUTATION;\n      case 'subscription':\n        return _ast.OperationTypeNode.SUBSCRIPTION;\n    }\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,\n      directives: this.parseConstDirectives()\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName()\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  }\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false)\n      });\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet()\n      });\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet()\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n      case _tokenKind.TokenKind.INT:\n        this._lexer.advance();\n        return this.node(token, {\n          kind: _kinds.Kind.INT,\n          value: token.value\n        });\n      case _tokenKind.TokenKind.FLOAT:\n        this._lexer.advance();\n        return this.node(token, {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value\n        });\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n      case _tokenKind.TokenKind.NAME:\n        this._lexer.advance();\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: true\n            });\n          case 'false':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: false\n            });\n          case 'null':\n            return this.node(token, {\n              kind: _kinds.Kind.NULL\n            });\n          default:\n            return this.node(token, {\n              kind: _kinds.Kind.ENUM,\n              value: token.value\n            });\n        }\n      case _tokenKind.TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(_tokenKind.TokenKind.DOLLAR);\n          if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected variable \"$${varName}\" in constant value.`);\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n        return this.parseVariable();\n      default:\n        throw this.unexpected();\n    }\n  }\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n  parseStringLiteral() {\n    const token = this._lexer.token;\n    this._lexer.advance();\n    return this.node(token, {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.LIST,\n      values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R)\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R)\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst)\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n    return directives;\n  }\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst)\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: innerType\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return this.node(start, {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type\n      });\n    }\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName()\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements') ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {\n      throw (0, _syntaxError.syntaxError)(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);\n    }\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n        case 'type':\n          return this.parseObjectTypeExtension();\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n        case 'union':\n          return this.parseUnionTypeExtension();\n        case 'enum':\n          return this.parseEnumTypeExtension();\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    if (Object.prototype.hasOwnProperty.call(_directiveLocation.DirectiveLocation, name.value)) {\n      return name;\n    }\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {\n      node.loc = new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this._lexer.advance();\n      return token;\n    }\n    throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this._lexer.advance();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Expected \"${value}\", found ${getTokenDesc(token)}.`);\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return (0, _syntaxError.syntaxError)(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nexports.Parser = Parser;\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return (0, _lexer.isPunctuatorTokenKind)(kind) ? `\"${kind}\"` : kind;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Parser","parse","parseConstValue","parseType","parseValue","_syntaxError","require","_ast","_directiveLocation","_kinds","_lexer","_source","_tokenKind","source","options","parser","parseDocument","expectToken","TokenKind","SOF","parseValueLiteral","EOF","parseConstValueLiteral","type","parseTypeReference","constructor","sourceObj","isSource","Source","Lexer","_options","parseName","token","NAME","node","kind","Kind","DOCUMENT","definitions","many","parseDefinition","peek","BRACE_L","parseOperationDefinition","hasDescription","peekDescription","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","syntaxError","start","parseFragmentDefinition","parseTypeSystemExtension","unexpected","OPERATION_DEFINITION","operation","OperationTypeNode","QUERY","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","MUTATION","SUBSCRIPTION","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","parseConstDirectives","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","allowLegacyFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","varName","block","LIST","values","any","BRACKET_R","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","innerType","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","delimitedMany","AMP","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","types","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","parseEnumValueName","ENUM_VALUE_DEFINITION","getTokenDesc","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","prototype","hasOwnProperty","call","DirectiveLocation","startToken","_this$_options2","noLocation","loc","Location","lastToken","getTokenKindDesc","atToken","openKind","parseFn","closeKind","nodes","delimiterKind","isPunctuatorTokenKind"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/graphql-npm-16.5.0-348f68b718-a82a926d08.zip/node_modules/graphql/language/parser.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true,\n});\nexports.Parser = void 0;\nexports.parse = parse;\nexports.parseConstValue = parseConstValue;\nexports.parseType = parseType;\nexports.parseValue = parseValue;\n\nvar _syntaxError = require('../error/syntaxError.js');\n\nvar _ast = require('./ast.js');\n\nvar _directiveLocation = require('./directiveLocation.js');\n\nvar _kinds = require('./kinds.js');\n\nvar _lexer = require('./lexer.js');\n\nvar _source = require('./source.js');\n\nvar _tokenKind = require('./tokenKind.js');\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nfunction parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nfunction parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nfunction parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(_tokenKind.TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(_tokenKind.TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nclass Parser {\n  constructor(source, options) {\n    const sourceObj = (0, _source.isSource)(source)\n      ? source\n      : new _source.Source(source);\n    this._lexer = new _lexer.Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(_tokenKind.TokenKind.NAME);\n    return this.node(token, {\n      kind: _kinds.Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.DOCUMENT,\n      definitions: this.many(\n        _tokenKind.TokenKind.SOF,\n        this.parseDefinition,\n        _tokenKind.TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw (0, _syntaxError.syntaxError)(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(_tokenKind.TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: _kinds.Kind.OPERATION_DEFINITION,\n        operation: _ast.OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(_tokenKind.TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return _ast.OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return _ast.OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return _ast.OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type:\n        (this.expectToken(_tokenKind.TokenKind.COLON),\n        this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: _kinds.Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.SELECTION_SET,\n      selections: this.many(\n        _tokenKind.TokenKind.BRACE_L,\n        this.parseSelection,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(_tokenKind.TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      item,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: _kinds.Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case _tokenKind.TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case _tokenKind.TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case _tokenKind.TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.INT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: _kinds.Kind.FLOAT,\n          value: token.value,\n        });\n\n      case _tokenKind.TokenKind.STRING:\n      case _tokenKind.TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case _tokenKind.TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: _kinds.Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: _kinds.Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: _kinds.Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case _tokenKind.TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(_tokenKind.TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw (0, _syntaxError.syntaxError)(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: _kinds.Kind.STRING,\n      value: token.value,\n      block: token.kind === _tokenKind.TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.LIST,\n      values: this.any(\n        _tokenKind.TokenKind.BRACKET_L,\n        item,\n        _tokenKind.TokenKind.BRACKET_R,\n      ),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.OBJECT,\n      fields: this.any(\n        _tokenKind.TokenKind.BRACE_L,\n        item,\n        _tokenKind.TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(_tokenKind.TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(_tokenKind.TokenKind.AT);\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(_tokenKind.TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: _kinds.Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {\n      return this.node(start, {\n        kind: _kinds.Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: _kinds.Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return (\n      this.peek(_tokenKind.TokenKind.STRING) ||\n      this.peek(_tokenKind.TokenKind.BLOCK_STRING)\n    );\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(_tokenKind.TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)\n      ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === _tokenKind.TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      _tokenKind.TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      _tokenKind.TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(_tokenKind.TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(\n      _tokenKind.TokenKind.PIPE,\n      this.parseDirectiveLocation,\n    );\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (\n      Object.prototype.hasOwnProperty.call(\n        _directiveLocation.DirectiveLocation,\n        name.value,\n      )\n    ) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new _ast.Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw (0, _syntaxError.syntaxError)(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return (0, _syntaxError.syntaxError)(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nexports.Parser = Parser;\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return (0, _lexer.isPunctuatorTokenKind)(kind) ? `\"${kind}\"` : kind;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}