{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;\nconst graphql_1 = require(\"graphql\");\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n  commentsRegistry = {};\n}\nexports.resetComments = resetComments;\nfunction collectComment(node) {\n  var _a;\n  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n  if (entityName == null) {\n    return;\n  }\n  pushComment(node, entityName);\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        for (const value of node.values) {\n          pushComment(value, entityName, value.name.value);\n        }\n      }\n      break;\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        for (const field of node.fields) {\n          pushComment(field, entityName, field.name.value);\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            for (const arg of field.arguments) {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            }\n          }\n        }\n      }\n      break;\n  }\n}\nexports.collectComment = collectComment;\nfunction pushComment(node, entity, field, argument) {\n  const comment = getComment(node);\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n  const keys = [entity];\n  if (field) {\n    keys.push(field);\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n  const path = keys.join('.');\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n  commentsRegistry[path].push(comment);\n}\nexports.pushComment = pushComment;\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\nexports.printComment = printComment;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a;\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n    const items = [];\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n  };\n}\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave: node => {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n      // the query short form.\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: ({\n      variable,\n      type,\n      defaultValue,\n      directives\n    }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '))\n  },\n  SelectionSet: {\n    leave: ({\n      selections\n    }) => block(selections)\n  },\n  Field: {\n    leave({\n      alias,\n      name,\n      arguments: args,\n      directives,\n      selectionSet\n    }) {\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  Argument: {\n    leave: ({\n      name,\n      value\n    }) => name + ': ' + value\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: ({\n      name,\n      directives\n    }) => '...' + name + wrap(' ', join(directives, ' '))\n  },\n  InlineFragment: {\n    leave: ({\n      typeCondition,\n      directives,\n      selectionSet\n    }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ')\n  },\n  FragmentDefinition: {\n    leave: ({\n      name,\n      typeCondition,\n      variableDefinitions,\n      directives,\n      selectionSet\n    }) =>\n    // Note: fragment variable definitions are experimental and may be changed\n    // or removed in the future.\n    `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n  },\n  // Value\n  IntValue: {\n    leave: ({\n      value\n    }) => value\n  },\n  FloatValue: {\n    leave: ({\n      value\n    }) => value\n  },\n  StringValue: {\n    leave: ({\n      value,\n      block: isBlockString\n    }) => {\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: ({\n      value\n    }) => value ? 'true' : 'false'\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: ({\n      value\n    }) => value\n  },\n  ListValue: {\n    leave: ({\n      values\n    }) => '[' + join(values, ', ') + ']'\n  },\n  ObjectValue: {\n    leave: ({\n      fields\n    }) => '{' + join(fields, ', ') + '}'\n  },\n  ObjectField: {\n    leave: ({\n      name,\n      value\n    }) => name + ': ' + value\n  },\n  // Directive\n  Directive: {\n    leave: ({\n      name,\n      arguments: args\n    }) => '@' + name + wrap('(', join(args, ', '), ')')\n  },\n  // Type\n  NamedType: {\n    leave: ({\n      name\n    }) => name\n  },\n  ListType: {\n    leave: ({\n      type\n    }) => '[' + type + ']'\n  },\n  NonNullType: {\n    leave: ({\n      type\n    }) => type + '!'\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: ({\n      directives,\n      operationTypes\n    }) => join(['schema', join(directives, ' '), block(operationTypes)], ' ')\n  },\n  OperationTypeDefinition: {\n    leave: ({\n      operation,\n      type\n    }) => operation + ': ' + type\n  },\n  ScalarTypeDefinition: {\n    leave: ({\n      name,\n      directives\n    }) => join(['scalar', name, join(directives, ' ')], ' ')\n  },\n  ObjectTypeDefinition: {\n    leave: ({\n      name,\n      interfaces,\n      directives,\n      fields\n    }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')\n  },\n  FieldDefinition: {\n    leave: ({\n      name,\n      arguments: args,\n      type,\n      directives\n    }) => name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '))\n  },\n  InputValueDefinition: {\n    leave: ({\n      name,\n      type,\n      defaultValue,\n      directives\n    }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ')\n  },\n  InterfaceTypeDefinition: {\n    leave: ({\n      name,\n      interfaces,\n      directives,\n      fields\n    }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')\n  },\n  UnionTypeDefinition: {\n    leave: ({\n      name,\n      directives,\n      types\n    }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ')\n  },\n  EnumTypeDefinition: {\n    leave: ({\n      name,\n      directives,\n      values\n    }) => join(['enum', name, join(directives, ' '), block(values)], ' ')\n  },\n  EnumValueDefinition: {\n    leave: ({\n      name,\n      directives\n    }) => join([name, join(directives, ' ')], ' ')\n  },\n  InputObjectTypeDefinition: {\n    leave: ({\n      name,\n      directives,\n      fields\n    }) => join(['input', name, join(directives, ' '), block(fields)], ' ')\n  },\n  DirectiveDefinition: {\n    leave: ({\n      name,\n      arguments: args,\n      repeatable,\n      locations\n    }) => 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ')\n  },\n  SchemaExtension: {\n    leave: ({\n      directives,\n      operationTypes\n    }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' ')\n  },\n  ScalarTypeExtension: {\n    leave: ({\n      name,\n      directives\n    }) => join(['extend scalar', name, join(directives, ' ')], ' ')\n  },\n  ObjectTypeExtension: {\n    leave: ({\n      name,\n      interfaces,\n      directives,\n      fields\n    }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')\n  },\n  InterfaceTypeExtension: {\n    leave: ({\n      name,\n      interfaces,\n      directives,\n      fields\n    }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')\n  },\n  UnionTypeExtension: {\n    leave: ({\n      name,\n      directives,\n      types\n    }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ')\n  },\n  EnumTypeExtension: {\n    leave: ({\n      name,\n      directives,\n      values\n    }) => join(['extend enum', name, join(directives, ' '), block(values)], ' ')\n  },\n  InputObjectTypeExtension: {\n    leave: ({\n      name,\n      directives,\n      fields\n    }) => join(['extend input', name, join(directives, ' '), block(fields)], ' ')\n  }\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n  ...prev,\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n  return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);\n}\nexports.printWithComments = printWithComments;\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\nexports.getDescription = getDescription;\nfunction getComment(node) {\n  const rawValue = getLeadingCommentBlock(node);\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(`\\n${rawValue}`);\n  }\n}\nexports.getComment = getComment;\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let token = loc.startToken.prev;\n  while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n  // Remove common indentation from all lines but first.\n  const commonIndent = getBlockStringIndentation(lines);\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\nexports.dedentBlockStringValue = dedentBlockStringValue;\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n  return commonIndent === null ? 0 : commonIndent;\n}\nexports.getBlockStringIndentation = getBlockStringIndentation;\nfunction leadingWhitespace(str) {\n  let i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getBlockStringIndentation","dedentBlockStringValue","getLeadingCommentBlock","getComment","getDescription","printWithComments","printComment","pushComment","collectComment","resetComments","graphql_1","require","MAX_LINE_LENGTH","commentsRegistry","node","_a","entityName","name","kind","values","fields","field","isFieldDefinitionNode","arguments","arg","entity","argument","comment","length","keys","push","path","join","replace","maybeArray","separator","filter","x","hasMultilineItems","some","str","includes","addDescription","cb","_key","_parent","ancestors","parent","reduce","prev","key","Boolean","items","map","description","indent","maybeString","block","array","wrap","start","end","printBlockString","isDescription","escaped","indexOf","printDocASTReducer","Name","leave","Variable","Document","definitions","OperationDefinition","varDefs","variableDefinitions","prefix","operation","directives","selectionSet","VariableDefinition","variable","type","defaultValue","SelectionSet","selections","Field","alias","args","argsLine","Argument","FragmentSpread","InlineFragment","typeCondition","FragmentDefinition","IntValue","FloatValue","StringValue","isBlockString","JSON","stringify","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","operationTypes","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","interfaces","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","types","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","repeatable","locations","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","printDocASTReducerWithComments","ast","visit","options","commentDescriptions","rawValue","undefined","loc","comments","token","startToken","TokenKind","COMMENT","next","line","String","reverse","rawString","lines","split","commonIndent","i","slice","isBlank","shift","pop","leadingWhitespace"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/__virtual__/@graphql-tools-utils-virtual-c460c70582/0/cache/@graphql-tools-utils-npm-8.9.0-8fcb9b9e58-8d1d8a1172.zip/node_modules/@graphql-tools/utils/cjs/comments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;\nconst graphql_1 = require(\"graphql\");\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nexports.resetComments = resetComments;\nfunction collectComment(node) {\n    var _a;\n    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nexports.collectComment = collectComment;\nfunction pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nexports.pushComment = pushComment;\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\nexports.printComment = printComment;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    var _a;\n    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        var _a;\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);\n}\nexports.printWithComments = printWithComments;\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n        return getComment(node);\n    }\n}\nexports.getDescription = getDescription;\nfunction getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nexports.getComment = getComment;\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === graphql_1.TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\nexports.dedentBlockStringValue = dedentBlockStringValue;\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nexports.getBlockStringIndentation = getBlockStringIndentation;\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}