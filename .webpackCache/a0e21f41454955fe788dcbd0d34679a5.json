{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildServiceDefinition = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_2 = require(\"./utilities/graphql\");\nconst predicates_1 = require(\"./utilities/predicates\");\nfunction flattened(arr) {\n  return new Array().concat(...arr);\n}\nfunction buildServiceDefinition(modules) {\n  const errors = [];\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directivesMap = Object.create(null);\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  for (let module of modules) {\n    if ((0, graphql_2.isNode)(module) && (0, graphql_2.isDocumentNode)(module)) {\n      module = {\n        typeDefs: module\n      };\n    }\n    for (const definition of module.typeDefs.definitions) {\n      if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n        const typeName = definition.name.value;\n        if (typeDefinitionsMap[typeName]) {\n          typeDefinitionsMap[typeName].push(definition);\n        } else {\n          typeDefinitionsMap[typeName] = [definition];\n        }\n      } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n        const typeName = definition.name.value;\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(definition);\n        } else {\n          typeExtensionsMap[typeName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n        if (directivesMap[directiveName]) {\n          directivesMap[directiveName].push(definition);\n        } else {\n          directivesMap[directiveName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n        schemaDefinitions.push(definition);\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(definition);\n      }\n    }\n  }\n  for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n    if (typeDefinitions.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n    }\n  }\n  for (const [directiveName, directives] of Object.entries(directivesMap)) {\n    if (directives.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n    }\n  }\n  let operationTypeMap;\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n    const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map(node => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));\n    for (const operationType of operationTypes) {\n      const typeName = operationType.type.name.value;\n      const operation = operationType.operation;\n      if (operationTypeMap[operation]) {\n        throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n      }\n      if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n        throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n      }\n      operationTypeMap[operation] = typeName;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n  for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n    if (!typeDefinitionsMap[typeName]) {\n      if (Object.values(operationTypeMap).includes(typeName)) {\n        typeDefinitionsMap[typeName] = [{\n          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: typeName\n          }\n        }];\n      } else {\n        errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n      }\n    }\n  }\n  if (errors.length > 0) {\n    return {\n      errors\n    };\n  }\n  try {\n    const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n    const directives = flattened(Object.values(directivesMap));\n    let schema = (0, graphql_1.buildASTSchema)({\n      kind: graphql_1.Kind.DOCUMENT,\n      definitions: [...typeDefinitions, ...directives]\n    });\n    const typeExtensions = flattened(Object.values(typeExtensionsMap));\n    if (typeExtensions.length > 0) {\n      schema = (0, graphql_1.extendSchema)(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: typeExtensions\n      });\n    }\n    for (const module of modules) {\n      if (\"kind\" in module || !module.resolvers) continue;\n      addResolversToSchema(schema, module.resolvers);\n    }\n    return {\n      schema\n    };\n  } catch (error) {\n    return {\n      errors: [error]\n    };\n  }\n}\nexports.buildServiceDefinition = buildServiceDefinition;\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if (!(0, graphql_1.isObjectType)(type)) continue;\n    const fieldMap = type.getFields();\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        if (fieldConfig.resolve) {\n          field.resolve = fieldConfig.resolve;\n        }\n        if (fieldConfig.subscribe) {\n          field.subscribe = fieldConfig.subscribe;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["graphql_1","require","graphql_2","predicates_1","flattened","arr","Array","concat","buildServiceDefinition","modules","errors","typeDefinitionsMap","Object","create","typeExtensionsMap","directivesMap","schemaDefinitions","schemaExtensions","module","isNode","isDocumentNode","typeDefs","definition","definitions","isTypeDefinitionNode","typeName","name","value","push","isTypeExtensionNode","kind","Kind","DIRECTIVE_DEFINITION","directiveName","SCHEMA_DEFINITION","SCHEMA_EXTENSION","typeDefinitions","entries","length","GraphQLError","directives","operationTypeMap","schemaDefinition","operationTypes","map","node","filter","isNotNullOrUndefined","operationType","type","operation","query","mutation","subscription","typeExtensions","values","includes","OBJECT_TYPE_DEFINITION","NAME","schema","buildASTSchema","DOCUMENT","extendSchema","resolvers","addResolversToSchema","error","exports","fieldConfigs","getType","isObjectType","fieldMap","getFields","fieldName","fieldConfig","startsWith","substring","field","resolve","subscribe"],"sourceRoot":"","sources":["../src/buildServiceDefinition.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}