{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst parseEntity_1 = __importDefault(require(\"../lib/parseEntity\"));\nconst validateTypes_1 = __importDefault(require(\"../lib/validateTypes\"));\nconst normalizeData_1 = __importDefault(require(\"../lib/normalizeData\"));\nconst formatItem_1 = __importDefault(require(\"../lib/formatItem\"));\nconst getKey_1 = __importDefault(require(\"../lib/getKey\"));\nconst expressionBuilder_1 = __importDefault(require(\"../lib/expressionBuilder\"));\nconst projectionBuilder_1 = __importDefault(require(\"../lib/projectionBuilder\"));\n// Import error handlers\nconst utils_1 = require(\"../lib/utils\");\n// Declare Entity class\nclass Entity {\n  // Declare constructor (entity config)\n  constructor(entity) {\n    // Sanity check the entity object\n    if (typeof entity !== 'object' || Array.isArray(entity)) utils_1.error('Please provide a valid entity definition');\n    // Parse the entity and merge into this\n    Object.assign(this, parseEntity_1.default(entity));\n  } // end construcor\n  // Set the Entity's Table\n  set table(table) {\n    // If a Table\n    if (table.Table && table.Table.attributes) {\n      // If this Entity already has a Table, throw an error\n      if (this._table) {\n        utils_1.error(`This entity is already assigned a Table (${this._table.name})`);\n        // Else if the Entity doesn't exist in the Table, add it\n      } else if (!table.entities.includes(this.name)) {\n        table.addEntity(this);\n      }\n      // Set the Entity's table\n      this._table = table;\n      // If an entity tracking field is enabled, add the attributes, alias and the default\n      if (table.Table.entityField) {\n        this.schema.attributes[table.Table.entityField] = {\n          type: 'string',\n          alias: this._etAlias,\n          default: this.name\n        };\n        this.defaults[table.Table.entityField] = this.name;\n        this.schema.attributes[this._etAlias] = {\n          type: 'string',\n          map: table.Table.entityField,\n          default: this.name\n        };\n        this.defaults[this._etAlias] = this.name;\n      } // end if entity tracking\n      // Throw an error if not a valid Table\n    } else {\n      utils_1.error('Invalid Table');\n    }\n  } // end set table\n  // Returns the Entity's Table\n  get table() {\n    if (this._table) {\n      return this._table;\n    } else {\n      return utils_1.error(`The '${this.name}' entity must be attached to a Table to perform this operation`);\n    }\n  }\n  // Return reference to the DocumentClient\n  get DocumentClient() {\n    if (this.table.DocumentClient) {\n      return this.table.DocumentClient;\n    } else {\n      return utils_1.error('DocumentClient required for this operation');\n    }\n  }\n  // Sets the auto execute mode (default to true)\n  set autoExecute(val) {\n    this._execute = typeof val === 'boolean' ? val : undefined;\n  }\n  // Gets the current auto execute mode\n  get autoExecute() {\n    return typeof this._execute === 'boolean' ? this._execute : typeof this.table.autoExecute === 'boolean' ? this.table.autoExecute : true;\n  }\n  // Sets the auto parse mode (default to true)\n  set autoParse(val) {\n    this._parse = typeof val === 'boolean' ? val : undefined;\n  }\n  // Gets the current auto execute mode\n  get autoParse() {\n    return typeof this._parse === 'boolean' ? this._parse : typeof this.table.autoParse === 'boolean' ? this.table.autoParse : true;\n  }\n  // Primary key getters\n  get partitionKey() {\n    return this.schema.keys.partitionKey ? this.attribute(this.schema.keys.partitionKey) : utils_1.error(`No partitionKey defined`);\n  }\n  get sortKey() {\n    return this.schema.keys.sortKey ? this.attribute(this.schema.keys.sortKey) : null;\n  }\n  // Get mapped attribute name\n  attribute(attr) {\n    return this.schema.attributes[attr] && this.schema.attributes[attr].map ? this.schema.attributes[attr].map : this.schema.attributes[attr] ? attr : utils_1.error(`'${attr}' does not exist or is an invalid alias`);\n  } // end attribute\n  // Parses the item\n  parse(input, include = []) {\n    // TODO: 'include' needs to handle nested maps?\n    // Convert include to roots and de-alias\n    include = include.map(attr => {\n      const _attr = attr.split('.')[0].split('[')[0];\n      return this.schema.attributes[_attr] && this.schema.attributes[_attr].map || _attr;\n    });\n    // Load the schema\n    const {\n      schema,\n      linked\n    } = this;\n    // Assume standard response from DynamoDB\n    const data = input.Item || input.Items || input;\n    if (Array.isArray(data)) {\n      return data.map(item => formatItem_1.default(this.DocumentClient)(schema.attributes, linked, item, include));\n    } else {\n      return formatItem_1.default(this.DocumentClient)(schema.attributes, linked, data, include);\n    }\n  } // end parse\n  /**\n   * Generate GET parameters and execute operation\n   * @param {object} item - The keys from item you wish to get.\n   * @param {object} [options] - Additional get options.\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.\n   */\n  get(item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload\n      const payload = this.getParams(item, options, params);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.get(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, result.Item ? {\n            Item: this.parse(result.Item, Array.isArray(options.include) ? options.include : [])\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end if-else\n    });\n  } // end get\n  /**\n   * Generate parameters for GET batch operation\n   * @param {object} item - The keys from item you wish to get.\n   */\n  getBatch(item = {}) {\n    return {\n      Table: this.table,\n      Key: this.getParams(item).Key\n    };\n  }\n  /**\n   * Generate parameters for GET transaction operation\n   * @param {object} item - The keys from item you wish to get.\n   * @param {object} [options] - Additional get options\n   *\n   * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Get.html\n   */\n  getTransaction(item = {}, options = {}) {\n    // Destructure options to check for extraneous arguments\n    const {\n        attributes\n      } = options,\n      // ProjectionExpression\n      args = __rest(options\n      // Error on extraneous arguments\n      , [\"attributes\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0) utils_1.error(`Invalid get transaction options: ${Object.keys(args).join(', ')}`);\n    // Generate the get parameters\n    let payload = this.getParams(item, options);\n    // Return in transaction format\n    return {\n      Entity: this,\n      Get: payload\n    };\n  }\n  /**\n   * Generate GET parameters\n   * @param {object} item - The keys from item you wish to get.\n   * @param {object} [options] - Additional get options.\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.\n   */\n  getParams(item = {}, options = {}, params = {}) {\n    // Extract schema and merge defaults\n    const {\n      schema,\n      defaults,\n      linked,\n      _table\n    } = this;\n    const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);\n    const {\n        consistent,\n        // ConsistentRead (boolean)\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        attributes\n      } = options,\n      // Projections\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"consistent\", \"capacity\", \"attributes\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid get options: ${args.join(', ')}`);\n    // Verify consistent read\n    if (consistent !== undefined && typeof consistent !== 'boolean') utils_1.error(`'consistent' requires a boolean`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    let ExpressionAttributeNames; // init ExpressionAttributeNames\n    let ProjectionExpression; // init ProjectionExpression\n    // If projections\n    if (attributes) {\n      const {\n        names,\n        projections\n      } = projectionBuilder_1.default(attributes, this.table, this.name);\n      if (Object.keys(names).length > 0) {\n        // Merge names and add projection expression\n        ExpressionAttributeNames = names;\n        ProjectionExpression = projections;\n      } // end if names\n    } // end if projections\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: _table.name,\n      Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)\n    }, ExpressionAttributeNames ? {\n      ExpressionAttributeNames\n    } : null, ProjectionExpression ? {\n      ProjectionExpression\n    } : null, consistent ? {\n      ConsistentRead: consistent\n    } : null, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, typeof params === 'object' ? params : {});\n    return payload;\n  } // end getParams\n  /**\n   * Generate DELETE parameters and execute operation\n   * @param {object} item - The keys from item you wish to delete.\n   * @param {object} [options] - Additional delete options.\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.\n   */\n  delete(item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const payload = this.deleteParams(item, options, params);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.delete(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, result.Attributes ? {\n            Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : [])\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end if-else\n    });\n  } // end delete\n  /**\n   * Generate parameters for DELETE batch operation\n   * @param {object} item - The keys from item you wish to delete.\n   *\n   * Only Key is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html\n   */\n  deleteBatch(item = {}) {\n    const payload = this.deleteParams(item);\n    return {\n      [payload.TableName]: {\n        DeleteRequest: {\n          Key: payload.Key\n        }\n      }\n    };\n  }\n  /**\n   * Generate parameters for DELETE transaction operation\n   * @param {object} item - The keys from item you wish to delete.\n   * @param {object} [options] - Additional delete options\n   *\n   * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Delete.html\n   */\n  deleteTransaction(item = {}, options = {}) {\n    // Destructure options to check for extraneous arguments\n    const {\n        conditions,\n        // ConditionExpression\n        returnValues\n      } = options,\n      // ReturnValuesOnConditionCheckFailure (none, all_old)\n      args = __rest(options\n      // Error on extraneous arguments\n      , [\"conditions\", \"returnValues\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0) utils_1.error(`Invalid delete transaction options: ${Object.keys(args).join(', ')}`);\n    // Generate the delete parameters\n    let payload = this.deleteParams(item, options);\n    // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n    if ('ReturnValues' in payload) {\n      let {\n          ReturnValues\n        } = payload,\n        _payload = __rest(payload, [\"ReturnValues\"]);\n      payload = Object.assign({}, _payload, {\n        ReturnValuesOnConditionCheckFailure: ReturnValues\n      });\n    }\n    // Return in transaction format\n    return {\n      Delete: payload\n    };\n  }\n  /**\n   * Generate DELETE parameters\n   * @param {object} item - The keys from item you wish to delete.\n   * @param {object} [options] - Additional delete options.\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.\n   */\n  deleteParams(item = {}, options = {}, params = {}) {\n    // Extract schema and merge defaults\n    const {\n      schema,\n      defaults,\n      linked,\n      _table\n    } = this;\n    const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);\n    const {\n        conditions,\n        // ConditionExpression\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        metrics,\n        // ReturnItemCollectionMetrics: (size or none)\n        returnValues\n      } = options,\n      // Return Values (none, all_old)\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid delete options: ${args.join(', ')}`);\n    // Verify metrics\n    if (metrics !== undefined && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase()))) utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify returnValues\n    if (returnValues !== undefined && (typeof returnValues !== 'string' || !['NONE', 'ALL_OLD'].includes(returnValues.toUpperCase()))) utils_1.error(`'returnValues' must be one of 'NONE' OR 'ALL_OLD'`);\n    let ExpressionAttributeNames; // init ExpressionAttributeNames\n    let ExpressionAttributeValues; // init ExpressionAttributeValues\n    let ConditionExpression; // init ConditionExpression\n    // If conditions\n    if (conditions) {\n      // Parse the conditions\n      const {\n        expression,\n        names,\n        values\n      } = expressionBuilder_1.default(conditions, this.table, this.name);\n      if (Object.keys(names).length > 0) {\n        // TODO: alias attribute field names        \n        // Merge names and values and add condition expression\n        ExpressionAttributeNames = names;\n        ExpressionAttributeValues = values;\n        ConditionExpression = expression;\n      } // end if names\n    } // end if filters\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: _table.name,\n      Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)\n    }, ExpressionAttributeNames ? {\n      ExpressionAttributeNames\n    } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? {\n      ExpressionAttributeValues\n    } : null, ConditionExpression ? {\n      ConditionExpression\n    } : null, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, metrics ? {\n      ReturnItemCollectionMetrics: metrics.toUpperCase()\n    } : null, returnValues ? {\n      ReturnValues: returnValues.toUpperCase()\n    } : null, typeof params === 'object' ? params : {});\n    return payload;\n  } // end deleteParams\n  /**\n   * Generate UPDATE parameters and execute operations\n   * @param {object} item - The keys from item you wish to update.\n   * @param {object} [options] - Additional update options.\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the update request.\n   */\n  update(item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload\n      const payload = this.updateParams(item, options, params);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.update(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, result.Attributes ? {\n            Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : [])\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end if-else\n    });\n  } // end delete\n  /**\n   * Generate parameters for UPDATE transaction operation\n   * @param {object} item - The item you wish to update.\n   * @param {object} [options] - Additional update options\n   *\n   * Creates an Update object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Update.html\n   */\n  updateTransaction(item = {}, options = {}) {\n    // Destructure options to check for extraneous arguments\n    const {\n        conditions,\n        // ConditionExpression\n        returnValues\n      } = options,\n      // ReturnValuesOnConditionCheckFailure (none, all_old)\n      args = __rest(options\n      // Error on extraneous arguments\n      , [\"conditions\", \"returnValues\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0) utils_1.error(`Invalid update transaction options: ${Object.keys(args).join(', ')}`);\n    // Generate the update parameters\n    let payload = this.updateParams(item, options);\n    // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n    if ('ReturnValues' in payload) {\n      let {\n          ReturnValues\n        } = payload,\n        _payload = __rest(payload, [\"ReturnValues\"]);\n      payload = Object.assign({}, _payload, {\n        ReturnValuesOnConditionCheckFailure: ReturnValues\n      });\n    }\n    // Return in transaction format (cast as Update since UpdateExpression can't be undefined)\n    return {\n      Update: payload\n    };\n  }\n  // Generate UPDATE Parameters\n  updateParams(item = {}, options = {}, _a = {}) {\n    var {\n        SET = [],\n        REMOVE = [],\n        ADD = [],\n        DELETE = [],\n        ExpressionAttributeNames = {},\n        ExpressionAttributeValues = {}\n      } = _a,\n      params = __rest(_a, [\"SET\", \"REMOVE\", \"ADD\", \"DELETE\", \"ExpressionAttributeNames\", \"ExpressionAttributeValues\"]);\n    // Validate operation types\n    if (!Array.isArray(SET)) utils_1.error('SET must be an array');\n    if (!Array.isArray(REMOVE)) utils_1.error('REMOVE must be an array');\n    if (!Array.isArray(ADD)) utils_1.error('ADD must be an array');\n    if (!Array.isArray(DELETE)) utils_1.error('DELETE must be an array');\n    // Validate attribute names and values\n    if (typeof ExpressionAttributeNames !== 'object' || Array.isArray(ExpressionAttributeNames)) utils_1.error('ExpressionAttributeNames must be an object');\n    if (typeof ExpressionAttributeValues !== 'object' || Array.isArray(ExpressionAttributeValues)) utils_1.error('ExpressionAttributeValues must be an object');\n    // if (ConditionExpression && typeof ConditionExpression !== 'string')\n    //     error(`ConditionExpression must be a string`)\n    // Extract schema and defaults\n    const {\n      schema,\n      defaults,\n      required,\n      linked,\n      _table\n    } = this;\n    // Initialize validateType with the DocumentClient\n    const validateType = validateTypes_1.default(this.DocumentClient);\n    // Merge defaults\n    const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));\n    // Extract valid options\n    const {\n        conditions,\n        // ConditionExpression\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        metrics,\n        // ReturnItemCollectionMetrics: (size or none)\n        returnValues\n      } = options,\n      // Return Values (none, all_old, updated_old, all_new, updated_new)\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid update options: ${args.join(', ')}`);\n    // Verify metrics\n    if (metrics !== undefined && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase()))) utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify returnValues\n    if (returnValues !== undefined && (typeof returnValues !== 'string' || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase()))) utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', OR 'UPDATED_NEW'`);\n    let ConditionExpression; // init ConditionExpression\n    // If conditions\n    if (conditions) {\n      // Parse the conditions\n      const {\n        expression,\n        names,\n        values\n      } = expressionBuilder_1.default(conditions, this.table, this.name);\n      if (Object.keys(names).length > 0) {\n        // TODO: alias attribute field names        \n        // Add names, values and condition expression\n        ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n        ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n        ConditionExpression = expression;\n      } // end if names\n    } // end if conditions\n    // Check for required fields\n    Object.keys(required).forEach(field => required[field] && (data[field] === undefined || data[field] === null) && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check\n    // Get partition and sort keys\n    const Key = getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);\n    // Init names and values\n    const names = {};\n    const values = {};\n    // Loop through valid fields and add appropriate action\n    Object.keys(data).forEach(field => {\n      var _a, _b, _c, _d, _e, _f, _g;\n      const mapping = schema.attributes[field];\n      // Remove attributes\n      if (field === '$remove') {\n        const attrs = Array.isArray(data[field]) ? data[field] : [data[field]];\n        for (const i in attrs) {\n          // Verify attribute\n          if (!schema.attributes[attrs[i]]) utils_1.error(`'${attrs[i]}' is not a valid attribute and cannot be removed`);\n          // Verify attribute is not a pk/sk\n          if (schema.attributes[attrs[i]].partitionKey === true || schema.attributes[attrs[i]].sortKey === true) utils_1.error(`'${attrs[i]}' is the ${schema.attributes[attrs[i]].partitionKey === true ? 'partitionKey' : 'sortKey'} and cannot be removed`);\n          // Grab the attribute name and add to REMOVE and names\n          const attr = schema.attributes[attrs[i]].map || attrs[i];\n          REMOVE.push(`#${attr}`);\n          names[`#${attr}`] = attr;\n        } // end for\n      } else if (this._table._removeNulls === true && (data[field] === null || String(data[field]).trim() === '') && (!mapping.link || mapping.save)) {\n        REMOVE.push(`#${field}`);\n        names[`#${field}`] = field;\n      } else if (\n      // !mapping.partitionKey\n      // && !mapping.sortKey\n      mapping.partitionKey !== true && mapping.sortKey !== true && (mapping.save === undefined || mapping.save === true) && (!mapping.link || mapping.link && mapping.save === true)) {\n        // If a number or a set and adding\n        if (['number', 'set'].includes(mapping.type) && ((_a = data[field]) === null || _a === void 0 ? void 0 : _a.$add) !== undefined && ((_b = data[field]) === null || _b === void 0 ? void 0 : _b.$add) !== null) {\n          ADD.push(`#${field} :${field}`);\n          values[`:${field}`] = validateType(mapping, field, data[field].$add);\n          // Add field to names\n          names[`#${field}`] = field;\n          // if a set and deleting items\n        } else if (mapping.type === 'set' && ((_c = data[field]) === null || _c === void 0 ? void 0 : _c.$delete)) {\n          DELETE.push(`#${field} :${field}`);\n          values[`:${field}`] = validateType(mapping, field, data[field].$delete);\n          // Add field to names\n          names[`#${field}`] = field;\n          // if a list and removing items by index\n        } else if (mapping.type === 'list' && Array.isArray((_d = data[field]) === null || _d === void 0 ? void 0 : _d.$remove)) {\n          data[field].$remove.forEach(i => {\n            if (typeof i !== 'number') utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);\n            REMOVE.push(`#${field}[${i}]`);\n          });\n          // Add field to names\n          names[`#${field}`] = field;\n          // if list and appending or prepending\n        } else if (mapping.type === 'list' && (((_e = data[field]) === null || _e === void 0 ? void 0 : _e.$append) || ((_f = data[field]) === null || _f === void 0 ? void 0 : _f.$prepend))) {\n          if (data[field].$append) {\n            SET.push(`#${field} = list_append(#${field},:${field})`);\n            values[`:${field}`] = validateType(mapping, field, data[field].$append);\n          } else {\n            SET.push(`#${field} = list_append(:${field},#${field})`);\n            values[`:${field}`] = validateType(mapping, field, data[field].$prepend);\n          }\n          // Add field to names\n          names[`#${field}`] = field;\n          // if a list and updating by index\n        } else if (mapping.type === 'list' && !Array.isArray(data[field]) && typeof data[field] === 'object') {\n          Object.keys(data[field]).forEach(i => {\n            if (String(parseInt(i)) !== i) utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);\n            SET.push(`#${field}[${i}] = :${field}_${i}`);\n            values[`:${field}_${i}`] = data[field][i];\n          });\n          // Add field to names\n          names[`#${field}`] = field;\n          // if a map and updating by nested attribute/index\n        } else if (mapping.type === 'map' && ((_g = data[field]) === null || _g === void 0 ? void 0 : _g.$set)) {\n          Object.keys(data[field].$set).forEach(f => {\n            // TODO: handle null values to remove\n            let props = f.split('.');\n            let acc = [`#${field}`];\n            props.forEach((prop, i) => {\n              let id = `${field}_${props.slice(0, i + 1).join('_')}`;\n              // Add names and values\n              names[`#${id.replace(/\\[(\\d+)\\]/, '')}`] = prop.replace(/\\[(\\d+)\\]/, '');\n              // if the final prop, add the SET and values\n              if (i === props.length - 1) {\n                let input = data[field].$set[f];\n                let path = `${acc.join('.')}.#${id}`;\n                let value = `${id.replace(/\\[(\\d+)\\]/, '_$1')}`;\n                if (input === undefined) {\n                  REMOVE.push(`${path}`);\n                } else if (input.$add) {\n                  ADD.push(`${path} :${value}`);\n                  values[`:${value}`] = input.$add;\n                } else if (input.$append) {\n                  SET.push(`${path} = list_append(${path},:${value})`);\n                  values[`:${value}`] = input.$append;\n                } else if (input.$prepend) {\n                  SET.push(`${path} = list_append(:${value},${path})`);\n                  values[`:${value}`] = input.$prepend;\n                } else if (input.$remove) {\n                  // console.log('REMOVE:',input.$remove);\n                  input.$remove.forEach(i => {\n                    if (typeof i !== 'number') utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);\n                    REMOVE.push(`${path}[${i}]`);\n                  });\n                } else {\n                  SET.push(`${path} = :${value}`);\n                  values[`:${value}`] = input;\n                }\n                if (input.$set) {\n                  Object.keys(input.$set).forEach(i => {\n                    if (String(parseInt(i)) !== i) utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);\n                    SET.push(`${path}[${i}] = :${value}_${i}`);\n                    values[`:${value}_${i}`] = input.$set[i];\n                  });\n                }\n              } else {\n                acc.push(`#${id.replace(/\\[(\\d+)\\]/, '')}`);\n              }\n            });\n          });\n          // Add field to names\n          names[`#${field}`] = field;\n          // else add to SET\n        } else {\n          let value = utils_1.transformAttr(mapping, validateType(mapping, field, data[field]), data);\n          // It's possible that defaults can purposely return undefined values\n          // if (hasValue(value)) {\n          if (value !== undefined) {\n            // Push the update to SET\n            // @ts-ignore\n            SET.push(mapping.default !== undefined && item[field] === undefined && !mapping.onUpdate ? `#${field} = if_not_exists(#${field},:${field})` : `#${field} = :${field}`);\n            // Add names and values\n            names[`#${field}`] = field;\n            values[`:${field}`] = value;\n          }\n        }\n      } // end if undefined\n    });\n    // Create the update expression\n    const expression = ((SET.length > 0 ? 'SET ' + SET.join(', ') : '') + (REMOVE.length > 0 ? ' REMOVE ' + REMOVE.join(', ') : '') + (ADD.length > 0 ? ' ADD ' + ADD.join(', ') : '') + (DELETE.length > 0 ? ' DELETE ' + DELETE.join(', ') : '')).trim();\n    // Merge attribute values\n    ExpressionAttributeValues = Object.assign(values, ExpressionAttributeValues);\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: _table.name,\n      Key,\n      UpdateExpression: expression,\n      ExpressionAttributeNames: Object.assign(names, ExpressionAttributeNames)\n    }, typeof params === 'object' ? params : {}, !utils_1.isEmpty(ExpressionAttributeValues) ? {\n      ExpressionAttributeValues\n    } : {}, ConditionExpression ? {\n      ConditionExpression\n    } : {}, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, metrics ? {\n      ReturnItemCollectionMetrics: metrics.toUpperCase()\n    } : null, returnValues ? {\n      ReturnValues: returnValues.toUpperCase()\n    } : null); // end assign\n    return payload;\n    // TODO: Check why primary/secondary GSIs are using if_not_exists\n  } // end updateParams\n  // PUT - put item\n  put(item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload\n      const payload = this.putParams(item, options, params);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.put(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, result.Attributes ? {\n            Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : [])\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end-if\n    });\n  } // end put\n  /**\n   * Generate parameters for PUT batch operation\n   * @param {object} item - The item you wish to put.\n   *\n   * Only Item is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html\n   */\n  putBatch(item = {}) {\n    const payload = this.putParams(item);\n    return {\n      [payload.TableName]: {\n        PutRequest: {\n          Item: payload.Item\n        }\n      }\n    };\n  }\n  /**\n   * Generate parameters for PUT transaction operation\n   * @param {object} item - The item you wish to put.\n   * @param {object} [options] - Additional put options\n   *\n   * Creates a Put object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Put.html\n   */\n  putTransaction(item = {}, options = {}) {\n    // Destructure options to check for extraneous arguments\n    const {\n        conditions,\n        // ConditionExpression\n        returnValues\n      } = options,\n      // ReturnValuesOnConditionCheckFailure (none, all_old)\n      args = __rest(options\n      // Error on extraneous arguments\n      , [\"conditions\", \"returnValues\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0) utils_1.error(`Invalid put transaction options: ${Object.keys(args).join(', ')}`);\n    // Generate the put parameters\n    let payload = this.putParams(item, options);\n    // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n    if ('ReturnValues' in payload) {\n      let {\n          ReturnValues\n        } = payload,\n        _payload = __rest(payload, [\"ReturnValues\"]);\n      payload = Object.assign({}, _payload, {\n        ReturnValuesOnConditionCheckFailure: ReturnValues\n      });\n    }\n    // Return in transaction format\n    return {\n      Put: payload\n    };\n  }\n  // Generate PUT Parameters\n  putParams(item = {}, options = {}, params = {}) {\n    // Extract schema and defaults\n    const {\n      schema,\n      defaults,\n      required,\n      linked,\n      _table\n    } = this;\n    // Initialize validateType with the DocumentClient\n    const validateType = validateTypes_1.default(this.DocumentClient);\n    // Merge defaults\n    const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));\n    // console.log(data);\n    // Extract valid options\n    const {\n        conditions,\n        // ConditionExpression\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        metrics,\n        // ReturnItemCollectionMetrics: (size or none)\n        returnValues\n      } = options,\n      // Return Values (none, all_old, updated_old, all_new, updated_new)\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid put options: ${args.join(', ')}`);\n    // Verify metrics\n    if (metrics !== undefined && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase()))) utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify returnValues\n    // TODO: Check this, conflicts with dynalite\n    if (returnValues !== undefined && (typeof returnValues !== 'string' || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase()))) utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', or 'UPDATED_NEW'`);\n    let ExpressionAttributeNames; // init ExpressionAttributeNames\n    let ExpressionAttributeValues; // init ExpressionAttributeValues\n    let ConditionExpression; // init ConditionExpression\n    // If conditions\n    if (conditions) {\n      // Parse the conditions\n      const {\n        expression,\n        names,\n        values\n      } = expressionBuilder_1.default(conditions, this.table, this.name);\n      if (Object.keys(names).length > 0) {\n        // TODO: alias attribute field names        \n        // Add names, values and condition expression\n        ExpressionAttributeNames = names;\n        ExpressionAttributeValues = values;\n        ConditionExpression = expression;\n      } // end if names\n    } // end if filters\n    // Check for required fields\n    Object.keys(required).forEach(field => required[field] !== undefined && (data[field] === undefined || data[field] === null) && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check\n    // Checks for partition and sort keys\n    getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: _table.name,\n      // Loop through valid fields and add appropriate action\n      Item: Object.keys(data).reduce((acc, field) => {\n        let mapping = schema.attributes[field];\n        let value = validateType(mapping, field, data[field]);\n        return value !== undefined && (mapping.save === undefined || mapping.save === true) && (!mapping.link || mapping.link && mapping.save === true) && (!_table._removeNulls || _table._removeNulls && value !== null) ? Object.assign(acc, {\n          [field]: utils_1.transformAttr(mapping, value, data)\n        }) : acc;\n      }, {})\n    }, ExpressionAttributeNames ? {\n      ExpressionAttributeNames\n    } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? {\n      ExpressionAttributeValues\n    } : null, ConditionExpression ? {\n      ConditionExpression\n    } : null, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, metrics ? {\n      ReturnItemCollectionMetrics: metrics.toUpperCase()\n    } : null, returnValues ? {\n      ReturnValues: returnValues.toUpperCase()\n    } : null, typeof params === 'object' ? params : {});\n    return payload;\n  } // end putParams\n  /**\n   * Generate parameters for ConditionCheck transaction operation\n   * @param {object} item - The keys from item you wish to check.\n   * @param {object} [options] - Additional condition check options\n   *\n   * Creates a ConditionCheck object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ConditionCheck.html\n   */\n  conditionCheck(item = {}, options = {}) {\n    // Destructure options to check for extraneous arguments\n    const {\n        conditions,\n        // ConditionExpression\n        returnValues\n      } = options,\n      // ReturnValuesOnConditionCheckFailure (none, all_old)\n      args = __rest(options\n      // Error on extraneous arguments\n      , [\"conditions\", \"returnValues\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0) utils_1.error(`Invalid conditionCheck options: ${Object.keys(args).join(', ')}`);\n    // Generate the condition parameters (same params as delete)\n    let payload = this.deleteParams(item, options);\n    // Error on missing conditions\n    if (!('ConditionExpression' in payload)) utils_1.error(`'conditions' are required in a conditionCheck`);\n    // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n    if ('ReturnValues' in payload) {\n      let {\n          ReturnValues\n        } = payload,\n        _payload = __rest(payload, [\"ReturnValues\"]);\n      payload = Object.assign({}, _payload, {\n        ReturnValuesOnConditionCheckFailure: ReturnValues\n      });\n    }\n    // Return in transaction format\n    return {\n      ConditionCheck: payload\n    };\n  }\n  // Query pass-through (default entity)\n  query(pk, options = {}, params = {}) {\n    options.entity = this.name;\n    return this.table.query(pk, options, params);\n  }\n  // Scan pass-through (default entity)\n  scan(options = {}, params = {}) {\n    options.entity = this.name;\n    return this.table.scan(options, params);\n  }\n} // end Entity\n// Export the Entity class\nexports.default = Entity;","map":{"version":3,"names":["__awaiter","undefined","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__rest","s","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__importDefault","mod","__esModule","defineProperty","exports","parseEntity_1","require","validateTypes_1","normalizeData_1","formatItem_1","getKey_1","expressionBuilder_1","projectionBuilder_1","utils_1","Entity","constructor","entity","Array","isArray","error","assign","default","table","Table","attributes","_table","name","entities","includes","addEntity","entityField","schema","type","alias","_etAlias","defaults","map","DocumentClient","autoExecute","val","_execute","autoParse","_parse","partitionKey","keys","attribute","sortKey","attr","parse","input","include","_attr","split","linked","data","Item","Items","item","get","options","params","payload","getParams","execute","promise","getBatch","Key","getTransaction","args","join","Get","consistent","capacity","_args","filter","x","toUpperCase","ExpressionAttributeNames","ProjectionExpression","names","projections","TableName","ConsistentRead","ReturnConsumedCapacity","delete","deleteParams","Attributes","deleteBatch","DeleteRequest","deleteTransaction","conditions","returnValues","ReturnValues","_payload","ReturnValuesOnConditionCheckFailure","Delete","metrics","ExpressionAttributeValues","ConditionExpression","expression","values","isEmpty","ReturnItemCollectionMetrics","update","updateParams","updateTransaction","Update","_a","SET","REMOVE","ADD","DELETE","required","validateType","forEach","field","_b","_c","_d","_e","_f","_g","mapping","attrs","push","_removeNulls","String","trim","link","save","$add","$delete","$remove","$append","$prepend","parseInt","$set","f","props","acc","prop","id","slice","replace","path","transformAttr","onUpdate","UpdateExpression","put","putParams","putBatch","PutRequest","putTransaction","Put","reduce","conditionCheck","ConditionCheck","query","pk","scan"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/classes/Entity.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parseEntity_1 = __importDefault(require(\"../lib/parseEntity\"));\nconst validateTypes_1 = __importDefault(require(\"../lib/validateTypes\"));\nconst normalizeData_1 = __importDefault(require(\"../lib/normalizeData\"));\nconst formatItem_1 = __importDefault(require(\"../lib/formatItem\"));\nconst getKey_1 = __importDefault(require(\"../lib/getKey\"));\nconst expressionBuilder_1 = __importDefault(require(\"../lib/expressionBuilder\"));\nconst projectionBuilder_1 = __importDefault(require(\"../lib/projectionBuilder\"));\n// Import error handlers\nconst utils_1 = require(\"../lib/utils\");\n// Declare Entity class\nclass Entity {\n    // Declare constructor (entity config)\n    constructor(entity) {\n        // Sanity check the entity object\n        if (typeof entity !== 'object' || Array.isArray(entity))\n            utils_1.error('Please provide a valid entity definition');\n        // Parse the entity and merge into this\n        Object.assign(this, parseEntity_1.default(entity));\n    } // end construcor\n    // Set the Entity's Table\n    set table(table) {\n        // If a Table\n        if (table.Table && table.Table.attributes) {\n            // If this Entity already has a Table, throw an error\n            if (this._table) {\n                utils_1.error(`This entity is already assigned a Table (${this._table.name})`);\n                // Else if the Entity doesn't exist in the Table, add it\n            }\n            else if (!table.entities.includes(this.name)) {\n                table.addEntity(this);\n            }\n            // Set the Entity's table\n            this._table = table;\n            // If an entity tracking field is enabled, add the attributes, alias and the default\n            if (table.Table.entityField) {\n                this.schema.attributes[table.Table.entityField] = { type: 'string', alias: this._etAlias, default: this.name };\n                this.defaults[table.Table.entityField] = this.name;\n                this.schema.attributes[this._etAlias] = { type: 'string', map: table.Table.entityField, default: this.name };\n                this.defaults[this._etAlias] = this.name;\n            } // end if entity tracking\n            // Throw an error if not a valid Table\n        }\n        else {\n            utils_1.error('Invalid Table');\n        }\n    } // end set table\n    // Returns the Entity's Table\n    get table() {\n        if (this._table) {\n            return this._table;\n        }\n        else {\n            return utils_1.error(`The '${this.name}' entity must be attached to a Table to perform this operation`);\n        }\n    }\n    // Return reference to the DocumentClient\n    get DocumentClient() {\n        if (this.table.DocumentClient) {\n            return this.table.DocumentClient;\n        }\n        else {\n            return utils_1.error('DocumentClient required for this operation');\n        }\n    }\n    // Sets the auto execute mode (default to true)\n    set autoExecute(val) { this._execute = typeof val === 'boolean' ? val : undefined; }\n    // Gets the current auto execute mode\n    get autoExecute() {\n        return typeof this._execute === 'boolean' ? this._execute\n            : typeof this.table.autoExecute === 'boolean' ? this.table.autoExecute\n                : true;\n    }\n    // Sets the auto parse mode (default to true)\n    set autoParse(val) { this._parse = typeof val === 'boolean' ? val : undefined; }\n    // Gets the current auto execute mode\n    get autoParse() {\n        return typeof this._parse === 'boolean' ? this._parse\n            : typeof this.table.autoParse === 'boolean' ? this.table.autoParse\n                : true;\n    }\n    // Primary key getters\n    get partitionKey() {\n        return this.schema.keys.partitionKey ?\n            this.attribute(this.schema.keys.partitionKey)\n            : utils_1.error(`No partitionKey defined`);\n    }\n    get sortKey() {\n        return this.schema.keys.sortKey ?\n            this.attribute(this.schema.keys.sortKey)\n            : null;\n    }\n    // Get mapped attribute name\n    attribute(attr) {\n        return this.schema.attributes[attr] && this.schema.attributes[attr].map ?\n            this.schema.attributes[attr].map\n            : this.schema.attributes[attr] ? attr\n                : utils_1.error(`'${attr}' does not exist or is an invalid alias`);\n    } // end attribute\n    // Parses the item\n    parse(input, include = []) {\n        // TODO: 'include' needs to handle nested maps?\n        // Convert include to roots and de-alias\n        include = include.map(attr => {\n            const _attr = attr.split('.')[0].split('[')[0];\n            return (this.schema.attributes[_attr] && this.schema.attributes[_attr].map) || _attr;\n        });\n        // Load the schema\n        const { schema, linked } = this;\n        // Assume standard response from DynamoDB\n        const data = input.Item || input.Items || input;\n        if (Array.isArray(data)) {\n            return data.map(item => formatItem_1.default(this.DocumentClient)(schema.attributes, linked, item, include));\n        }\n        else {\n            return formatItem_1.default(this.DocumentClient)(schema.attributes, linked, data, include);\n        }\n    } // end parse\n    /**\n     * Generate GET parameters and execute operation\n     * @param {object} item - The keys from item you wish to get.\n     * @param {object} [options] - Additional get options.\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.\n     */\n    get(item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload\n            const payload = this.getParams(item, options, params);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.get(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, result.Item ? { Item: this.parse(result.Item, Array.isArray(options.include) ? options.include : []) } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end if-else\n        });\n    } // end get\n    /**\n     * Generate parameters for GET batch operation\n     * @param {object} item - The keys from item you wish to get.\n     */\n    getBatch(item = {}) {\n        return {\n            Table: this.table,\n            Key: this.getParams(item).Key\n        };\n    }\n    /**\n     * Generate parameters for GET transaction operation\n     * @param {object} item - The keys from item you wish to get.\n     * @param {object} [options] - Additional get options\n     *\n     * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Get.html\n     */\n    getTransaction(item = {}, options = {}) {\n        // Destructure options to check for extraneous arguments\n        const { attributes } = options, // ProjectionExpression\n        args = __rest(options\n        // Error on extraneous arguments\n        , [\"attributes\"]);\n        // Error on extraneous arguments\n        if (Object.keys(args).length > 0)\n            utils_1.error(`Invalid get transaction options: ${Object.keys(args).join(', ')}`);\n        // Generate the get parameters\n        let payload = this.getParams(item, options);\n        // Return in transaction format\n        return {\n            Entity: this,\n            Get: payload\n        };\n    }\n    /**\n     * Generate GET parameters\n     * @param {object} item - The keys from item you wish to get.\n     * @param {object} [options] - Additional get options.\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the get request.\n     */\n    getParams(item = {}, options = {}, params = {}) {\n        // Extract schema and merge defaults\n        const { schema, defaults, linked, _table } = this;\n        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);\n        const { consistent, // ConsistentRead (boolean)\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        attributes } = options, // Projections\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"consistent\", \"capacity\", \"attributes\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid get options: ${args.join(', ')}`);\n        // Verify consistent read\n        if (consistent !== undefined && typeof consistent !== 'boolean')\n            utils_1.error(`'consistent' requires a boolean`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        let ExpressionAttributeNames; // init ExpressionAttributeNames\n        let ProjectionExpression; // init ProjectionExpression\n        // If projections\n        if (attributes) {\n            const { names, projections } = projectionBuilder_1.default(attributes, this.table, this.name);\n            if (Object.keys(names).length > 0) {\n                // Merge names and add projection expression\n                ExpressionAttributeNames = names;\n                ProjectionExpression = projections;\n            } // end if names\n        } // end if projections\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: _table.name,\n            Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)\n        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, ProjectionExpression ? { ProjectionExpression } : null, consistent ? { ConsistentRead: consistent } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, typeof params === 'object' ? params : {});\n        return payload;\n    } // end getParams\n    /**\n     * Generate DELETE parameters and execute operation\n     * @param {object} item - The keys from item you wish to delete.\n     * @param {object} [options] - Additional delete options.\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.\n     */\n    delete(item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const payload = this.deleteParams(item, options, params);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.delete(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end if-else\n        });\n    } // end delete\n    /**\n     * Generate parameters for DELETE batch operation\n     * @param {object} item - The keys from item you wish to delete.\n     *\n     * Only Key is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html\n     */\n    deleteBatch(item = {}) {\n        const payload = this.deleteParams(item);\n        return { [payload.TableName]: { DeleteRequest: { Key: payload.Key } } };\n    }\n    /**\n     * Generate parameters for DELETE transaction operation\n     * @param {object} item - The keys from item you wish to delete.\n     * @param {object} [options] - Additional delete options\n     *\n     * Creates a Delete object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Delete.html\n     */\n    deleteTransaction(item = {}, options = {}) {\n        // Destructure options to check for extraneous arguments\n        const { conditions, // ConditionExpression\n        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)\n        args = __rest(options\n        // Error on extraneous arguments\n        , [\"conditions\", \"returnValues\"]);\n        // Error on extraneous arguments\n        if (Object.keys(args).length > 0)\n            utils_1.error(`Invalid delete transaction options: ${Object.keys(args).join(', ')}`);\n        // Generate the delete parameters\n        let payload = this.deleteParams(item, options);\n        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n        if ('ReturnValues' in payload) {\n            let { ReturnValues } = payload, _payload = __rest(payload, [\"ReturnValues\"]);\n            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });\n        }\n        // Return in transaction format\n        return { Delete: payload };\n    }\n    /**\n     * Generate DELETE parameters\n     * @param {object} item - The keys from item you wish to delete.\n     * @param {object} [options] - Additional delete options.\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the delete request.\n     */\n    deleteParams(item = {}, options = {}, params = {}) {\n        // Extract schema and merge defaults\n        const { schema, defaults, linked, _table } = this;\n        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item), true);\n        const { conditions, // ConditionExpression\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        metrics, // ReturnItemCollectionMetrics: (size or none)\n        returnValues } = options, // Return Values (none, all_old)\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid delete options: ${args.join(', ')}`);\n        // Verify metrics\n        if (metrics !== undefined\n            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))\n            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify returnValues\n        if (returnValues !== undefined\n            && (typeof returnValues !== 'string'\n                || !['NONE', 'ALL_OLD'].includes(returnValues.toUpperCase())))\n            utils_1.error(`'returnValues' must be one of 'NONE' OR 'ALL_OLD'`);\n        let ExpressionAttributeNames; // init ExpressionAttributeNames\n        let ExpressionAttributeValues; // init ExpressionAttributeValues\n        let ConditionExpression; // init ConditionExpression\n        // If conditions\n        if (conditions) {\n            // Parse the conditions\n            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);\n            if (Object.keys(names).length > 0) {\n                // TODO: alias attribute field names        \n                // Merge names and values and add condition expression\n                ExpressionAttributeNames = names;\n                ExpressionAttributeValues = values;\n                ConditionExpression = expression;\n            } // end if names\n        } // end if filters\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: _table.name,\n            Key: getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey)\n        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : null, ConditionExpression ? { ConditionExpression } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null, typeof params === 'object' ? params : {});\n        return payload;\n    } // end deleteParams\n    /**\n     * Generate UPDATE parameters and execute operations\n     * @param {object} item - The keys from item you wish to update.\n     * @param {object} [options] - Additional update options.\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the update request.\n     */\n    update(item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload\n            const payload = this.updateParams(item, options, params);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.update(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end if-else\n        });\n    } // end delete\n    /**\n     * Generate parameters for UPDATE transaction operation\n     * @param {object} item - The item you wish to update.\n     * @param {object} [options] - Additional update options\n     *\n     * Creates an Update object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Update.html\n     */\n    updateTransaction(item = {}, options = {}) {\n        // Destructure options to check for extraneous arguments\n        const { conditions, // ConditionExpression\n        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)\n        args = __rest(options\n        // Error on extraneous arguments\n        , [\"conditions\", \"returnValues\"]);\n        // Error on extraneous arguments\n        if (Object.keys(args).length > 0)\n            utils_1.error(`Invalid update transaction options: ${Object.keys(args).join(', ')}`);\n        // Generate the update parameters\n        let payload = this.updateParams(item, options);\n        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n        if ('ReturnValues' in payload) {\n            let { ReturnValues } = payload, _payload = __rest(payload, [\"ReturnValues\"]);\n            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });\n        }\n        // Return in transaction format (cast as Update since UpdateExpression can't be undefined)\n        return { Update: payload };\n    }\n    // Generate UPDATE Parameters\n    updateParams(item = {}, options = {}, _a = {}) {\n        var { SET = [], REMOVE = [], ADD = [], DELETE = [], ExpressionAttributeNames = {}, ExpressionAttributeValues = {} } = _a, params = __rest(_a, [\"SET\", \"REMOVE\", \"ADD\", \"DELETE\", \"ExpressionAttributeNames\", \"ExpressionAttributeValues\"]);\n        // Validate operation types\n        if (!Array.isArray(SET))\n            utils_1.error('SET must be an array');\n        if (!Array.isArray(REMOVE))\n            utils_1.error('REMOVE must be an array');\n        if (!Array.isArray(ADD))\n            utils_1.error('ADD must be an array');\n        if (!Array.isArray(DELETE))\n            utils_1.error('DELETE must be an array');\n        // Validate attribute names and values\n        if (typeof ExpressionAttributeNames !== 'object'\n            || Array.isArray(ExpressionAttributeNames))\n            utils_1.error('ExpressionAttributeNames must be an object');\n        if (typeof ExpressionAttributeValues !== 'object'\n            || Array.isArray(ExpressionAttributeValues))\n            utils_1.error('ExpressionAttributeValues must be an object');\n        // if (ConditionExpression && typeof ConditionExpression !== 'string')\n        //     error(`ConditionExpression must be a string`)\n        // Extract schema and defaults\n        const { schema, defaults, required, linked, _table } = this;\n        // Initialize validateType with the DocumentClient\n        const validateType = validateTypes_1.default(this.DocumentClient);\n        // Merge defaults\n        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));\n        // Extract valid options\n        const { conditions, // ConditionExpression\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        metrics, // ReturnItemCollectionMetrics: (size or none)\n        returnValues } = options, // Return Values (none, all_old, updated_old, all_new, updated_new)\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid update options: ${args.join(', ')}`);\n        // Verify metrics\n        if (metrics !== undefined\n            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))\n            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify returnValues\n        if (returnValues !== undefined\n            && (typeof returnValues !== 'string'\n                || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase())))\n            utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', OR 'UPDATED_NEW'`);\n        let ConditionExpression; // init ConditionExpression\n        // If conditions\n        if (conditions) {\n            // Parse the conditions\n            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);\n            if (Object.keys(names).length > 0) {\n                // TODO: alias attribute field names        \n                // Add names, values and condition expression\n                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n                ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n                ConditionExpression = expression;\n            } // end if names\n        } // end if conditions\n        // Check for required fields\n        Object.keys(required).forEach(field => required[field] && (data[field] === undefined || data[field] === null)\n            && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check\n        // Get partition and sort keys\n        const Key = getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);\n        // Init names and values\n        const names = {};\n        const values = {};\n        // Loop through valid fields and add appropriate action\n        Object.keys(data).forEach((field) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            const mapping = schema.attributes[field];\n            // Remove attributes\n            if (field === '$remove') {\n                const attrs = Array.isArray(data[field]) ? data[field] : [data[field]];\n                for (const i in attrs) {\n                    // Verify attribute\n                    if (!schema.attributes[attrs[i]])\n                        utils_1.error(`'${attrs[i]}' is not a valid attribute and cannot be removed`);\n                    // Verify attribute is not a pk/sk\n                    if (schema.attributes[attrs[i]].partitionKey === true || schema.attributes[attrs[i]].sortKey === true)\n                        utils_1.error(`'${attrs[i]}' is the ${schema.attributes[attrs[i]].partitionKey === true ? 'partitionKey' : 'sortKey'} and cannot be removed`);\n                    // Grab the attribute name and add to REMOVE and names\n                    const attr = schema.attributes[attrs[i]].map || attrs[i];\n                    REMOVE.push(`#${attr}`);\n                    names[`#${attr}`] = attr;\n                } // end for\n            }\n            else if (this._table._removeNulls === true && (data[field] === null || String(data[field]).trim() === '') && (!mapping.link || mapping.save)) {\n                REMOVE.push(`#${field}`);\n                names[`#${field}`] = field;\n            }\n            else if (\n            // !mapping.partitionKey\n            // && !mapping.sortKey\n            mapping.partitionKey !== true\n                && mapping.sortKey !== true\n                && (mapping.save === undefined || mapping.save === true)\n                && (!mapping.link || (mapping.link && mapping.save === true))) {\n                // If a number or a set and adding\n                if (['number', 'set'].includes(mapping.type) && (((_a = data[field]) === null || _a === void 0 ? void 0 : _a.$add) !== undefined && ((_b = data[field]) === null || _b === void 0 ? void 0 : _b.$add) !== null)) {\n                    ADD.push(`#${field} :${field}`);\n                    values[`:${field}`] = validateType(mapping, field, data[field].$add);\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // if a set and deleting items\n                }\n                else if (mapping.type === 'set' && ((_c = data[field]) === null || _c === void 0 ? void 0 : _c.$delete)) {\n                    DELETE.push(`#${field} :${field}`);\n                    values[`:${field}`] = validateType(mapping, field, data[field].$delete);\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // if a list and removing items by index\n                }\n                else if (mapping.type === 'list' && Array.isArray((_d = data[field]) === null || _d === void 0 ? void 0 : _d.$remove)) {\n                    data[field].$remove.forEach((i) => {\n                        if (typeof i !== 'number')\n                            utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);\n                        REMOVE.push(`#${field}[${i}]`);\n                    });\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // if list and appending or prepending\n                }\n                else if (mapping.type === 'list' && (((_e = data[field]) === null || _e === void 0 ? void 0 : _e.$append) || ((_f = data[field]) === null || _f === void 0 ? void 0 : _f.$prepend))) {\n                    if (data[field].$append) {\n                        SET.push(`#${field} = list_append(#${field},:${field})`);\n                        values[`:${field}`] = validateType(mapping, field, data[field].$append);\n                    }\n                    else {\n                        SET.push(`#${field} = list_append(:${field},#${field})`);\n                        values[`:${field}`] = validateType(mapping, field, data[field].$prepend);\n                    }\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // if a list and updating by index\n                }\n                else if (mapping.type === 'list' && !Array.isArray(data[field]) && typeof data[field] === 'object') {\n                    Object.keys(data[field]).forEach(i => {\n                        if (String(parseInt(i)) !== i)\n                            utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);\n                        SET.push(`#${field}[${i}] = :${field}_${i}`);\n                        values[`:${field}_${i}`] = data[field][i];\n                    });\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // if a map and updating by nested attribute/index\n                }\n                else if (mapping.type === 'map' && ((_g = data[field]) === null || _g === void 0 ? void 0 : _g.$set)) {\n                    Object.keys(data[field].$set).forEach(f => {\n                        // TODO: handle null values to remove\n                        let props = f.split('.');\n                        let acc = [`#${field}`];\n                        props.forEach((prop, i) => {\n                            let id = `${field}_${props.slice(0, i + 1).join('_')}`;\n                            // Add names and values\n                            names[`#${id.replace(/\\[(\\d+)\\]/, '')}`] = prop.replace(/\\[(\\d+)\\]/, '');\n                            // if the final prop, add the SET and values\n                            if (i === props.length - 1) {\n                                let input = data[field].$set[f];\n                                let path = `${acc.join('.')}.#${id}`;\n                                let value = `${id.replace(/\\[(\\d+)\\]/, '_$1')}`;\n                                if (input === undefined) {\n                                    REMOVE.push(`${path}`);\n                                }\n                                else if (input.$add) {\n                                    ADD.push(`${path} :${value}`);\n                                    values[`:${value}`] = input.$add;\n                                }\n                                else if (input.$append) {\n                                    SET.push(`${path} = list_append(${path},:${value})`);\n                                    values[`:${value}`] = input.$append;\n                                }\n                                else if (input.$prepend) {\n                                    SET.push(`${path} = list_append(:${value},${path})`);\n                                    values[`:${value}`] = input.$prepend;\n                                }\n                                else if (input.$remove) {\n                                    // console.log('REMOVE:',input.$remove);\n                                    input.$remove.forEach((i) => {\n                                        if (typeof i !== 'number')\n                                            utils_1.error(`Remove array for '${field}' must only contain numeric indexes`);\n                                        REMOVE.push(`${path}[${i}]`);\n                                    });\n                                }\n                                else {\n                                    SET.push(`${path} = :${value}`);\n                                    values[`:${value}`] = input;\n                                }\n                                if (input.$set) {\n                                    Object.keys(input.$set).forEach(i => {\n                                        if (String(parseInt(i)) !== i)\n                                            utils_1.error(`Properties must be numeric to update specific list items in '${field}'`);\n                                        SET.push(`${path}[${i}] = :${value}_${i}`);\n                                        values[`:${value}_${i}`] = input.$set[i];\n                                    });\n                                }\n                            }\n                            else {\n                                acc.push(`#${id.replace(/\\[(\\d+)\\]/, '')}`);\n                            }\n                        });\n                    });\n                    // Add field to names\n                    names[`#${field}`] = field;\n                    // else add to SET\n                }\n                else {\n                    let value = utils_1.transformAttr(mapping, validateType(mapping, field, data[field]), data);\n                    // It's possible that defaults can purposely return undefined values\n                    // if (hasValue(value)) {\n                    if (value !== undefined) {\n                        // Push the update to SET\n                        // @ts-ignore\n                        SET.push(mapping.default !== undefined && item[field] === undefined && !mapping.onUpdate ?\n                            `#${field} = if_not_exists(#${field},:${field})`\n                            : `#${field} = :${field}`);\n                        // Add names and values\n                        names[`#${field}`] = field;\n                        values[`:${field}`] = value;\n                    }\n                }\n            } // end if undefined\n        });\n        // Create the update expression\n        const expression = ((SET.length > 0 ? 'SET ' + SET.join(', ') : '')\n            + (REMOVE.length > 0 ? ' REMOVE ' + REMOVE.join(', ') : '')\n            + (ADD.length > 0 ? ' ADD ' + ADD.join(', ') : '')\n            + (DELETE.length > 0 ? ' DELETE ' + DELETE.join(', ') : '')).trim();\n        // Merge attribute values\n        ExpressionAttributeValues = Object.assign(values, ExpressionAttributeValues);\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: _table.name,\n            Key,\n            UpdateExpression: expression,\n            ExpressionAttributeNames: Object.assign(names, ExpressionAttributeNames)\n        }, typeof params === 'object' ? params : {}, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : {}, ConditionExpression ? { ConditionExpression } : {}, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null); // end assign\n        return payload;\n        // TODO: Check why primary/secondary GSIs are using if_not_exists\n    } // end updateParams\n    // PUT - put item\n    put(item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload\n            const payload = this.putParams(item, options, params);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.put(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, result.Attributes ? { Attributes: this.parse(result.Attributes, Array.isArray(options.include) ? options.include : []) } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end-if\n        });\n    } // end put\n    /**\n     * Generate parameters for PUT batch operation\n     * @param {object} item - The item you wish to put.\n     *\n     * Only Item is supported (e.g. no conditions) https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html\n     */\n    putBatch(item = {}) {\n        const payload = this.putParams(item);\n        return { [payload.TableName]: { PutRequest: { Item: payload.Item } } };\n    }\n    /**\n     * Generate parameters for PUT transaction operation\n     * @param {object} item - The item you wish to put.\n     * @param {object} [options] - Additional put options\n     *\n     * Creates a Put object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Put.html\n     */\n    putTransaction(item = {}, options = {}) {\n        // Destructure options to check for extraneous arguments\n        const { conditions, // ConditionExpression\n        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)\n        args = __rest(options\n        // Error on extraneous arguments\n        , [\"conditions\", \"returnValues\"]);\n        // Error on extraneous arguments\n        if (Object.keys(args).length > 0)\n            utils_1.error(`Invalid put transaction options: ${Object.keys(args).join(', ')}`);\n        // Generate the put parameters\n        let payload = this.putParams(item, options);\n        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n        if ('ReturnValues' in payload) {\n            let { ReturnValues } = payload, _payload = __rest(payload, [\"ReturnValues\"]);\n            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });\n        }\n        // Return in transaction format\n        return { Put: payload };\n    }\n    // Generate PUT Parameters\n    putParams(item = {}, options = {}, params = {}) {\n        // Extract schema and defaults\n        const { schema, defaults, required, linked, _table } = this;\n        // Initialize validateType with the DocumentClient\n        const validateType = validateTypes_1.default(this.DocumentClient);\n        // Merge defaults\n        const data = normalizeData_1.default(this.DocumentClient)(schema.attributes, linked, Object.assign({}, defaults, item));\n        // console.log(data);\n        // Extract valid options\n        const { conditions, // ConditionExpression\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        metrics, // ReturnItemCollectionMetrics: (size or none)\n        returnValues } = options, // Return Values (none, all_old, updated_old, all_new, updated_new)\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"conditions\", \"capacity\", \"metrics\", \"returnValues\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid put options: ${args.join(', ')}`);\n        // Verify metrics\n        if (metrics !== undefined\n            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))\n            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify returnValues\n        // TODO: Check this, conflicts with dynalite\n        if (returnValues !== undefined\n            && (typeof returnValues !== 'string'\n                || !['NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', 'UPDATED_NEW'].includes(returnValues.toUpperCase())))\n            utils_1.error(`'returnValues' must be one of 'NONE', 'ALL_OLD', 'UPDATED_OLD', 'ALL_NEW', or 'UPDATED_NEW'`);\n        let ExpressionAttributeNames; // init ExpressionAttributeNames\n        let ExpressionAttributeValues; // init ExpressionAttributeValues\n        let ConditionExpression; // init ConditionExpression\n        // If conditions\n        if (conditions) {\n            // Parse the conditions\n            const { expression, names, values } = expressionBuilder_1.default(conditions, this.table, this.name);\n            if (Object.keys(names).length > 0) {\n                // TODO: alias attribute field names        \n                // Add names, values and condition expression\n                ExpressionAttributeNames = names;\n                ExpressionAttributeValues = values;\n                ConditionExpression = expression;\n            } // end if names\n        } // end if filters\n        // Check for required fields\n        Object.keys(required).forEach(field => required[field] !== undefined && (data[field] === undefined || data[field] === null)\n            && utils_1.error(`'${field}${this.schema.attributes[field].alias ? `/${this.schema.attributes[field].alias}` : ''}' is a required field`)); // end required field check\n        // Checks for partition and sort keys\n        getKey_1.default(this.DocumentClient)(data, schema.attributes, schema.keys.partitionKey, schema.keys.sortKey);\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: _table.name,\n            // Loop through valid fields and add appropriate action\n            Item: Object.keys(data).reduce((acc, field) => {\n                let mapping = schema.attributes[field];\n                let value = validateType(mapping, field, data[field]);\n                return value !== undefined\n                    && (mapping.save === undefined || mapping.save === true)\n                    && (!mapping.link || (mapping.link && mapping.save === true))\n                    && (!_table._removeNulls || (_table._removeNulls && value !== null))\n                    ? Object.assign(acc, {\n                        [field]: utils_1.transformAttr(mapping, value, data)\n                    }) : acc;\n            }, {})\n        }, ExpressionAttributeNames ? { ExpressionAttributeNames } : null, !utils_1.isEmpty(ExpressionAttributeValues) ? { ExpressionAttributeValues } : null, ConditionExpression ? { ConditionExpression } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, returnValues ? { ReturnValues: returnValues.toUpperCase() } : null, typeof params === 'object' ? params : {});\n        return payload;\n    } // end putParams\n    /**\n     * Generate parameters for ConditionCheck transaction operation\n     * @param {object} item - The keys from item you wish to check.\n     * @param {object} [options] - Additional condition check options\n     *\n     * Creates a ConditionCheck object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ConditionCheck.html\n     */\n    conditionCheck(item = {}, options = {}) {\n        // Destructure options to check for extraneous arguments\n        const { conditions, // ConditionExpression\n        returnValues } = options, // ReturnValuesOnConditionCheckFailure (none, all_old)\n        args = __rest(options\n        // Error on extraneous arguments\n        , [\"conditions\", \"returnValues\"]);\n        // Error on extraneous arguments\n        if (Object.keys(args).length > 0)\n            utils_1.error(`Invalid conditionCheck options: ${Object.keys(args).join(', ')}`);\n        // Generate the condition parameters (same params as delete)\n        let payload = this.deleteParams(item, options);\n        // Error on missing conditions\n        if (!('ConditionExpression' in payload))\n            utils_1.error(`'conditions' are required in a conditionCheck`);\n        // If ReturnValues exists, replace with ReturnValuesOnConditionCheckFailure\n        if ('ReturnValues' in payload) {\n            let { ReturnValues } = payload, _payload = __rest(payload, [\"ReturnValues\"]);\n            payload = Object.assign({}, _payload, { ReturnValuesOnConditionCheckFailure: ReturnValues });\n        }\n        // Return in transaction format\n        return { ConditionCheck: payload };\n    }\n    // Query pass-through (default entity)\n    query(pk, options = {}, params = {}) {\n        options.entity = this.name;\n        return this.table.query(pk, options, params);\n    }\n    // Scan pass-through (default entity)\n    scan(options = {}, params = {}) {\n        options.entity = this.name;\n        return this.table.scan(options, params);\n    }\n} // end Entity\n// Export the Entity class\nexports.default = Entity;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}