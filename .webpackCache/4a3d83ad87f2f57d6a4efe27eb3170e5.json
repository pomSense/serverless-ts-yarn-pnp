{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// TODO: Check duplicate entity names code\n// Import libraries, types, and classes\nconst Entity_1 = __importDefault(require(\"./Entity\"));\nconst parseTable_1 = require(\"../lib/parseTable\");\nconst expressionBuilder_1 = __importDefault(require(\"../lib/expressionBuilder\"));\nconst validateTypes_1 = __importDefault(require(\"../lib/validateTypes\"));\nconst projectionBuilder_1 = __importDefault(require(\"../lib/projectionBuilder\"));\n// Import standard error handler\nconst utils_1 = require(\"../lib/utils\");\n// Declare Table class\nclass Table {\n  // Declare constructor (table config and optional entities)\n  constructor(table) {\n    this._execute = true;\n    this._parse = true;\n    this._removeNulls = true;\n    this._entities = [];\n    // Sanity check the table definition\n    if (typeof table !== 'object' || Array.isArray(table)) utils_1.error('Please provide a valid table definition');\n    // Parse the table and merge into this\n    Object.assign(this, parseTable_1.parseTable(table));\n  } // end constructor\n  // Sets the auto execute mode (default to true)\n  set autoExecute(val) {\n    this._execute = typeof val === 'boolean' ? val : true;\n  }\n  // Gets the current auto execute mode\n  get autoExecute() {\n    return this._execute;\n  }\n  // Sets the auto parse mode (default to true)\n  set autoParse(val) {\n    this._parse = typeof val === 'boolean' ? val : true;\n  }\n  // Gets the current auto execute mode\n  get autoParse() {\n    return this._parse;\n  }\n  // Sets the auto execute mode (default to true)\n  set removeNullAttributes(val) {\n    this._removeNulls = typeof val === 'boolean' ? val : true;\n  }\n  // Gets the current auto execute mode\n  get removeNullAttributes() {\n    return this._removeNulls;\n  }\n  // Retrieves the document client\n  get DocumentClient() {\n    return this._docClient;\n  }\n  // Validate and sets the document client (extend with options.convertEmptyValues because it's not typed)\n  set DocumentClient(docClient) {\n    // If a valid document client\n    if (docClient && docClient.get && docClient.put && docClient.delete && docClient.update) {\n      // Automatically set convertEmptyValues to true, unless false\n      if (docClient.options.convertEmptyValues !== false) docClient.options.convertEmptyValues = true;\n      this._docClient = docClient;\n    } else {\n      utils_1.error('Invalid DocumentClient');\n    }\n  } // end DocumentClient\n  /**\n   * Adds an entity to the table\n   * @param {Entity|Entity[]} Entity - An Entity or array of Entities to add to the table.\n  */\n  addEntity(entity) {\n    // Coerce entity to array\n    let entities = Array.isArray(entity) ? entity : [entity];\n    // Loop through entities\n    for (let i in entities) {\n      let entity = entities[i];\n      // If an instance of Entity, add it\n      if (entity instanceof Entity_1.default) {\n        // Check for existing entity name\n        if (this._entities && this._entities.includes(entity.name)) {\n          utils_1.error(`Entity name '${entity.name}' already exists`);\n        }\n        // Generate the reserved words list\n        const reservedWords = Object.getOwnPropertyNames(this).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(this)));\n        // Check for reserved word\n        if (reservedWords.includes(entity.name)) {\n          utils_1.error(`'${entity.name}' is a reserved word and cannot be used to name an Entity`);\n        }\n        // Check for sortKeys (if applicable)\n        if (!this.Table.sortKey && entity.schema.keys.sortKey) {\n          utils_1.error(`${entity.name} entity contains a sortKey, but the Table does not`);\n        } else if (this.Table.sortKey && !entity.schema.keys.sortKey) {\n          utils_1.error(`${entity.name} entity does not have a sortKey defined`);\n        }\n        // Process Entity index keys\n        for (const key in entity.schema.keys) {\n          // Set the value of the key\n          const attr = entity.schema.keys[key];\n          // Switch based on key type (pk, sk, or index)\n          switch (key) {\n            // For the primary index\n            case 'partitionKey':\n            case 'sortKey':\n              // If the attribute's name doesn't match the table's pk/sk name\n              if (attr !== this.Table[key] && this.Table[key]) {\n                // If the table's index attribute name does not conflict with another entity attribute\n                if (!entity.schema.attributes[this.Table[key]]) {\n                  // FIX: better way to do this?\n                  // Add the attribute using the same config and add alias\n                  entity.schema.attributes[this.Table[key]] = Object.assign({}, entity.schema.attributes[attr], {\n                    alias: attr\n                  }); // end assign\n                  // Add a map from the attribute to the new index attribute\n                  entity.schema.attributes[attr].map = this.Table[key];\n                  // Otherwise, throw an error\n                } else {\n                  utils_1.error(`The Table's ${key} name (${this.Table[key]}) conflicts with an Entity attribute name`);\n                } // end if-else\n              } // end if\n              break;\n            // For secondary indexes\n            default:\n              // Verify that the table has this index\n              if (!this.Table.indexes[key]) utils_1.error(`'${key}' is not a valid secondary index name`);\n              // Loop through the key types (pk/sk) defined in the key mapping\n              for (const keyType in attr) {\n                // Make sure the table index contains the defined key types\n                // @ts-ignore\n                if (!this.Table.indexes[key][keyType]) utils_1.error(`${entity.name} contains a ${keyType}, but it is not used by ${key}`);\n                // console.log(key,keyType,this.Table.indexes[key])\n                // If the attribute's name doesn't match the indexes attribute name\n                // @ts-ignore\n                if (attr[keyType] !== this.Table.indexes[key][keyType]) {\n                  // If the indexes attribute name does not conflict with another entity attribute\n                  // @ts-ignore\n                  if (!entity.schema.attributes[this.Table.indexes[key][keyType]]) {\n                    // If there is already a mapping for this attribute, make sure they match\n                    // TODO: Figure out if this is even possible anymore. I don't think it is.\n                    if (entity.schema.attributes[attr[keyType]].map\n                    // @ts-ignore\n                    && entity.schema.attributes[attr[keyType]].map !== this.Table.indexes[key][keyType]) utils_1.error(`${key}'s ${keyType} cannot map to the '${attr[keyType]}' alias because it is already mapped to another table attribute`);\n                    // Add the index attribute using the same config and add alias\n                    // @ts-ignore\n                    entity.schema.attributes[this.Table.indexes[key][keyType]] = Object.assign({}, entity.schema.attributes[attr[keyType]], {\n                      alias: attr[keyType]\n                    }); // end assign\n                    // Add a map from the attribute to the new index attribute\n                    // @ts-ignore\n                    entity.schema.attributes[attr[keyType]].map = this.Table.indexes[key][keyType];\n                  } else {\n                    // @ts-ignore\n                    const config = entity.schema.attributes[this.Table.indexes[key][keyType]];\n                    // If the existing attribute isn't used by this index\n                    if (!config.partitionKey && !config.sortKey || config.partitionKey && !config.partitionKey.includes(key) || config.sortKey && !config.sortKey.includes(key)) {\n                      // @ts-ignore\n                      utils_1.error(`${key}'s ${keyType} name (${this.Table.indexes[key][keyType]}) conflicts with another Entity attribute name`);\n                    } // end if\n                  } // end if-else\n                } // end if\n              } // end for\n              // Check that composite keys define both keys\n              // TODO: This only checks for the attribute, not the explicit assignment\n              if (this.Table.indexes[key].partitionKey && this.Table.indexes[key].sortKey && (!entity.schema.attributes[this.Table.indexes[key].partitionKey] || !entity.schema.attributes[this.Table.indexes[key].sortKey])) {\n                utils_1.error(`${key} requires mappings for both the partitionKey and the sortKey`);\n              }\n              break;\n          } // end switch\n        } // end for\n        // Loop through the Entity's attributes and validate their types against the Table definition\n        // Add attribute to table if not defined\n        for (let attr in entity.schema.attributes) {\n          // If an entity field conflicts with the entityField or its alias, throw an error\n          if (this.Table.entityField && (attr === this.Table.entityField || attr === entity._etAlias)) {\n            utils_1.error(`Attribute or alias '${attr}' conflicts with the table's 'entityField' mapping or entity alias`);\n            // If the atribute already exists in the table definition\n          } else if (this.Table.attributes[attr]) {\n            // If type is specified, check for attribute match\n            if (this.Table.attributes[attr].type && this.Table.attributes[attr].type !== entity.schema.attributes[attr].type) utils_1.error(`${entity.name} attribute type for '${attr}' (${entity.schema.attributes[attr].type}) does not match table's type (${this.Table.attributes[attr].type})`);\n            // Add entity mappings\n            this.Table.attributes[attr].mappings[entity.name] = Object.assign({\n              [entity.schema.attributes[attr].alias || attr]: entity.schema.attributes[attr].type\n            },\n            // Add setType if type 'set'\n            entity.schema.attributes[attr].type === 'set' ? {\n              _setType: entity.schema.attributes[attr].setType\n            } : {});\n            // else if the attribute doesn't exist\n          } else if (!entity.schema.attributes[attr].map) {\n            // Add type and entity map\n            this.Table.attributes[attr] = Object.assign({\n              mappings: {\n                [entity.name]: Object.assign({\n                  [entity.schema.attributes[attr].alias || attr]: entity.schema.attributes[attr].type\n                },\n                // Add setType if type 'set'\n                entity.schema.attributes[attr].type === 'set' ? {\n                  _setType: entity.schema.attributes[attr].setType\n                } : {})\n              }\n            }, entity.schema.attributes[attr].partitionKey || entity.schema.attributes[attr].sortKey ? {\n              type: entity.schema.attributes[attr].type\n            } : null); // end assign\n          } // end if-else Table attribute exists\n        } // end for loop to check/add attributes\n        // Add the Entity to the Table's entities list\n        this._entities.push(entity.name);\n        // Add the entity to the Table object\n        this[entity.name] = entity;\n        // Set the Entity's table by reference\n        entity.table = this;\n      } else {\n        utils_1.error('Invalid Entity');\n      }\n    } // end for\n  } // end addEntity\n  // Deprecation notice\n  set entities(entity) {\n    this.addEntity(entity);\n    //error(`Setting entities by assignment has been deprecated. Please use 'addEntity' instead.`)  \n  }\n\n  get entities() {\n    return this._entities;\n  }\n  // ----------------------------------------------------------------//\n  // Table actions\n  // ----------------------------------------------------------------//\n  query(pk, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate query parameters with projection data\n      const {\n        payload,\n        EntityProjections,\n        TableProjections\n      } = this.queryParams(pk, options, params, true);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.query(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, {\n            Items: result.Items && result.Items.map(item => {\n              if (this[item[String(this.Table.entityField)]]) {\n                return this[item[String(this.Table.entityField)]].parse(item,\n                // Array.isArray(options.omit) ? options.omit : [],\n                EntityProjections[item[String(this.Table.entityField)]] ? EntityProjections[item[String(this.Table.entityField)]] : TableProjections ? TableProjections : []);\n              } else {\n                return item;\n              }\n            })\n          },\n          // If last evaluated key, return a next function\n          result.LastEvaluatedKey ? {\n            next: () => {\n              return this.query(pk, Object.assign(options, {\n                startKey: result.LastEvaluatedKey\n              }), params);\n            }\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end if-else\n    });\n  }\n  // Query the table\n  queryParams(pk, options = {}, params = {}, projections = false) {\n    // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.KeyConditionExpressions\n    // Deconstruct valid options\n    const {\n        index,\n        limit,\n        reverse,\n        // ScanIndexForward\n        consistent,\n        // ConsistentRead (boolean)\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        select,\n        // Select (all_attributes, all_projected_attributes, specific_attributes, count)\n        eq,\n        // =\n        lt,\n        // <\n        lte,\n        // <=\n        gt,\n        // >\n        gte,\n        // >=\n        between,\n        // between\n        beginsWith,\n        // begins_with,\n        filters,\n        // filter object,\n        attributes,\n        // Projections\n        startKey,\n        entity\n      } = options,\n      // optional entity name to filter aliases\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"index\", \"limit\", \"reverse\", \"consistent\", \"capacity\", \"select\", \"eq\", \"lt\", \"lte\", \"gt\", \"gte\", \"between\", \"beginsWith\", \"filters\", \"attributes\", \"startKey\", \"entity\"]) // capture extra arguments\n    ;\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid query options: ${args.join(', ')}`);\n    // Verify pk\n    if (typeof pk !== 'string' && typeof pk !== 'number' || typeof pk === 'string' && pk.trim().length === 0) utils_1.error(`Query requires a string, number or binary 'partitionKey' as its first parameter`);\n    // Verify index\n    if (index !== undefined && !this.Table.indexes[index]) utils_1.error(`'${index}' is not a valid index name`);\n    // Verify limit\n    if (limit !== undefined && (!Number.isInteger(limit) || limit < 0)) utils_1.error(`'limit' must be a positive integer`);\n    // Verify reverse\n    if (reverse !== undefined && typeof reverse !== 'boolean') utils_1.error(`'reverse' requires a boolean`);\n    // Verify consistent read\n    if (consistent !== undefined && typeof consistent !== 'boolean') utils_1.error(`'consistent' requires a boolean`);\n    // Verify select\n    // TODO: Make dependent on whether or not an index is supplied\n    if (select !== undefined && (typeof select !== 'string' || !['ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', 'COUNT'].includes(select.toUpperCase()))) utils_1.error(`'select' must be one of 'ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', OR 'COUNT'`);\n    // Verify entity\n    if (entity !== undefined && (typeof entity !== 'string' || !(entity in this))) utils_1.error(`'entity' must be a string and a valid table Entity name`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify startKey\n    // TODO: validate startKey shape\n    if (startKey && (typeof startKey !== 'object' || Array.isArray(startKey))) utils_1.error(`'startKey' requires a valid object`);\n    // Default names and values\n    let ExpressionAttributeNames = {\n      '#pk': index && this.Table.indexes[index].partitionKey || this.Table.partitionKey\n    };\n    let ExpressionAttributeValues = {\n      ':pk': pk\n    };\n    let KeyConditionExpression = '#pk = :pk';\n    let FilterExpression; // init FilterExpression\n    let ProjectionExpression; // init ProjectionExpression\n    let EntityProjections = {};\n    let TableProjections; // FIXME: removed default\n    // Parse sortKey condition operator and value\n    let operator,\n      value,\n      f = '';\n    if (eq) {\n      value = eq;\n      f = 'eq';\n      operator = '=';\n    }\n    if (lt) {\n      value = value ? utils_1.conditonError(f) : lt;\n      f = 'lt';\n      operator = '<';\n    }\n    if (lte) {\n      value = value ? utils_1.conditonError(f) : lte;\n      f = 'lte';\n      operator = '<=';\n    }\n    if (gt) {\n      value = value ? utils_1.conditonError(f) : gt;\n      f = 'gt';\n      operator = '>';\n    }\n    if (gte) {\n      value = value ? utils_1.conditonError(f) : gte;\n      f = 'gte';\n      operator = '>=';\n    }\n    if (beginsWith) {\n      value = value ? utils_1.conditonError(f) : beginsWith;\n      f = 'beginsWith';\n      operator = 'BEGINS_WITH';\n    }\n    if (between) {\n      value = value ? utils_1.conditonError(f) : between;\n      f = 'between';\n      operator = 'BETWEEN';\n    }\n    // If a sortKey condition was set\n    if (operator) {\n      // Get sortKey configuration\n      const sk = index ? this.Table.indexes[index].sortKey ? this.Table.attributes[this.Table.indexes[index].sortKey] || {\n        type: 'string'\n      } : utils_1.error(`Conditional expressions require the index to have a sortKey`) : this.Table.sortKey ? this.Table.attributes[this.Table.sortKey] : utils_1.error(`Conditional expressions require the table to have a sortKey`);\n      // Init validateType\n      const validateType = validateTypes_1.default(this.DocumentClient);\n      // Add the sortKey attribute name\n      ExpressionAttributeNames['#sk'] = index && this.Table.indexes[index].sortKey || this.Table.sortKey;\n      // If between operation\n      if (operator === 'BETWEEN') {\n        // Verify array input\n        if (!Array.isArray(value) || value.length !== 2) utils_1.error(`'between' conditions requires an array with two values.`);\n        // Add values and special key condition\n        ExpressionAttributeValues[':sk0'] = validateType(sk, f + '[0]', value[0]);\n        ExpressionAttributeValues[':sk1'] = validateType(sk, f + '[1]', value[1]);\n        KeyConditionExpression += ' and #sk between :sk0 and :sk1';\n      } else {\n        // Add value\n        ExpressionAttributeValues[':sk'] = validateType(sk, f, value);\n        // If begins_with, add special key condition\n        if (operator === 'BEGINS_WITH') {\n          KeyConditionExpression += ' and begins_with(#sk,:sk)';\n        } else {\n          KeyConditionExpression += ` and #sk ${operator} :sk`;\n        }\n      } // end if-else    \n    } // end if operator\n    // If filter expressions\n    if (filters) {\n      // Parse the filter\n      const {\n        expression,\n        names,\n        values\n      } = expressionBuilder_1.default(filters, this, entity);\n      if (Object.keys(names).length > 0) {\n        // TODO: alias attribute field names\n        // console.log(names)\n        // Merge names and values and add filter expression\n        ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n        ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n        FilterExpression = expression;\n      } // end if names\n    } // end if filters\n    // If projections\n    if (attributes) {\n      const {\n        names,\n        projections,\n        entities,\n        tableAttrs\n      } = projectionBuilder_1.default(attributes, this, entity, true);\n      if (Object.keys(names).length > 0) {\n        // Merge names and add projection expression\n        ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n        ProjectionExpression = projections;\n        EntityProjections = entities;\n        TableProjections = tableAttrs;\n      } // end if names\n    } // end if projections\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: this.name,\n      KeyConditionExpression,\n      ExpressionAttributeNames,\n      ExpressionAttributeValues\n    }, FilterExpression ? {\n      FilterExpression\n    } : null, ProjectionExpression ? {\n      ProjectionExpression\n    } : null, index ? {\n      IndexName: index\n    } : null, limit ? {\n      Limit: String(limit)\n    } : null, reverse ? {\n      ScanIndexForward: !reverse\n    } : null, consistent ? {\n      ConsistentRead: consistent\n    } : null, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, select ? {\n      Select: select.toUpperCase()\n    } : null, startKey ? {\n      ExclusiveStartKey: startKey\n    } : null, typeof params === 'object' ? params : null);\n    return projections ? {\n      payload,\n      EntityProjections,\n      TableProjections\n    } : payload;\n  } // end query\n  // SCAN the table\n  scan(options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate query parameters with meta data\n      const {\n        payload,\n        EntityProjections,\n        TableProjections\n      } = this.scanParams(options, params, true);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.scan(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return Object.assign(result, {\n            Items: result.Items && result.Items.map(item => {\n              if (this[item[String(this.Table.entityField)]]) {\n                return this[item[String(this.Table.entityField)]].parse(item, EntityProjections[item[String(this.Table.entityField)]] ? EntityProjections[item[String(this.Table.entityField)]] : TableProjections ? TableProjections : []);\n              } else {\n                return item;\n              }\n            })\n          },\n          // If last evaluated key, return a next function\n          result.LastEvaluatedKey ? {\n            next: () => {\n              return this.scan(Object.assign(options, {\n                startKey: result.LastEvaluatedKey\n              }), params);\n            }\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end if-else\n    });\n  }\n  // Generate SCAN Parameters\n  scanParams(options = {}, params = {}, meta = false) {\n    // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.KeyConditionExpressions\n    // Deconstruct valid options\n    const {\n        index,\n        limit,\n        consistent,\n        // ConsistentRead (boolean)\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        select,\n        // Select (all_attributes, all_projected_attributes, specific_attributes, count)\n        filters,\n        // filter object,\n        attributes,\n        // Projections\n        segments,\n        // Segments,\n        segment,\n        // Segment\n        startKey,\n        entity\n      } = options,\n      // optional entity name to filter aliases\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"index\", \"limit\", \"consistent\", \"capacity\", \"select\", \"filters\", \"attributes\", \"segments\", \"segment\", \"startKey\", \"entity\"]) // capture extra arguments\n    ;\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid scan options: ${args.join(', ')}`);\n    // Verify index\n    if (index !== undefined && !this.Table.indexes[index]) utils_1.error(`'${index}' is not a valid index name`);\n    // Verify limit\n    if (limit !== undefined && (!Number.isInteger(limit) || limit < 0)) utils_1.error(`'limit' must be a positive integer`);\n    // Verify consistent read\n    if (consistent !== undefined && typeof consistent !== 'boolean') utils_1.error(`'consistent' requires a boolean`);\n    // Verify select\n    // TODO: Make dependent on whether or not an index is supplied\n    if (select !== undefined && (typeof select !== 'string' || !['ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', 'COUNT'].includes(select.toUpperCase()))) utils_1.error(`'select' must be one of 'ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', OR 'COUNT'`);\n    // Verify entity\n    if (entity !== undefined && (typeof entity !== 'string' || !(entity in this))) utils_1.error(`'entity' must be a string and a valid table Entity name`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify startKey\n    // TODO: validate startKey shape\n    if (startKey && (typeof startKey !== 'object' || Array.isArray(startKey))) utils_1.error(`'startKey' requires a valid object`);\n    // Verify consistent segments\n    if (segments !== undefined && (!Number.isInteger(segments) || segments < 1)) utils_1.error(`'segments' must be an integer greater than 1`);\n    if (segment !== undefined && (!Number.isInteger(segment) || segment < 0 || segment >= segments)) utils_1.error(`'segment' must be an integer greater than or equal to 0 and less than the total number of segments`);\n    if (segments !== undefined && segment === undefined || segments === undefined && segment !== undefined) utils_1.error(`Both 'segments' and 'segment' must be provided`);\n    // Default names and values\n    let ExpressionAttributeNames = {};\n    let ExpressionAttributeValues = {};\n    let FilterExpression; // init FilterExpression\n    let ProjectionExpression; // init ProjectionExpression\n    let EntityProjections = {};\n    let TableProjections;\n    // If filter expressions\n    if (filters) {\n      // Parse the filter\n      const {\n        expression,\n        names,\n        values\n      } = expressionBuilder_1.default(filters, this, entity);\n      if (Object.keys(names).length > 0) {\n        // TODO: alias attribute field names\n        // console.log(names)\n        // Merge names and values and add filter expression\n        ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n        ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n        FilterExpression = expression;\n      } // end if names\n    } // end if filters\n    // If projections\n    if (attributes) {\n      const {\n        names,\n        projections,\n        entities,\n        tableAttrs\n      } = projectionBuilder_1.default(attributes, this, entity, true);\n      if (Object.keys(names).length > 0) {\n        // Merge names and add projection expression\n        ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n        ProjectionExpression = projections;\n        EntityProjections = entities;\n        TableProjections = tableAttrs;\n      } // end if names\n    } // end if projections\n    // Generate the payload\n    const payload = Object.assign({\n      TableName: this.name\n    }, Object.keys(ExpressionAttributeNames).length ? {\n      ExpressionAttributeNames\n    } : null, Object.keys(ExpressionAttributeValues).length ? {\n      ExpressionAttributeValues\n    } : null, FilterExpression ? {\n      FilterExpression\n    } : null, ProjectionExpression ? {\n      ProjectionExpression\n    } : null, index ? {\n      IndexName: index\n    } : null, segments ? {\n      TotalSegments: segments\n    } : null, Number.isInteger(segment) ? {\n      Segment: segment\n    } : null, limit ? {\n      Limit: String(limit)\n    } : null, consistent ? {\n      ConsistentRead: consistent\n    } : null, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, select ? {\n      Select: select.toUpperCase()\n    } : null, startKey ? {\n      ExclusiveStartKey: startKey\n    } : null, typeof params === 'object' ? params : null);\n    return meta ? {\n      payload,\n      EntityProjections,\n      TableProjections\n    } : payload;\n  } // end query\n  // BatchGet Items\n  batchGet(items, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload with meta information\n      const {\n        payload,\n        // batchGet payload\n        Tables,\n        // table reference\n        EntityProjections,\n        TableProjections\n      } = this.batchGetParams(items, options, params, true);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.batchGet(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          // TODO: Left in for testing. Needs to be removed\n          // result.UnprocessedKeys = testUnprocessedKeys\n          return this.parseBatchGetResponse(result, Tables, EntityProjections, TableProjections, options);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end-if\n    });\n  } // end batchGet\n  parseBatchGetResponse(result, Tables, EntityProjections, TableProjections, options = {}) {\n    return Object.assign(result,\n    // If reponses exist\n    result.Responses ? {\n      // Loop through the tables \n      Responses: Object.keys(result.Responses).reduce((acc, table) => {\n        // Merge in tables\n        return Object.assign(acc, {\n          // Map over the items\n          [Tables[table] && Tables[table].alias || table]: result.Responses[table].map(item => {\n            // Check that the table has a reference, the entityField exists, and that the entity type exists on the table\n            if (Tables[table] && Tables[table][item[String(Tables[table].Table.entityField)]]) {\n              // Parse the item and pass in projection references\n              return Tables[table][item[String(Tables[table].Table.entityField)]].parse(item, EntityProjections[table] && EntityProjections[table][item[String(Tables[table].Table.entityField)]] ? EntityProjections[table][item[String(Tables[table].Table.entityField)]] : TableProjections[table] ? TableProjections[table] : []);\n              // Else, just return the original item\n            } else {\n              return item;\n            }\n          }) // end item map\n        }); // end assign\n      }, {}) // end table reduce\n    } : null,\n    // end if Responses\n    // If UnprocessedKeys, return a next function\n    result.UnprocessedKeys && Object.keys(result.UnprocessedKeys).length > 0 ? {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        const nextResult = yield this.DocumentClient.batchGet(Object.assign({\n          RequestItems: result.UnprocessedKeys\n        }, options.capacity ? {\n          ReturnConsumedCapacity: options.capacity.toUpperCase()\n        } : null)).promise();\n        return this.parseBatchGetResponse(nextResult, Tables, EntityProjections, TableProjections, options);\n      })\n    } : {\n      next: () => false\n    } // TODO: How should this return?\n    ); // end parse assign\n  } // end parseBatchGetResponse\n  // Generate BatchGet Params\n  batchGetParams(_items, options = {}, params = {}, meta = false) {\n    let items = Array.isArray(_items) ? _items : [_items];\n    // Error on no items\n    if (items.length === 0) utils_1.error(`No items supplied`);\n    const {\n        capacity,\n        consistent,\n        attributes\n      } = options,\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"capacity\", \"consistent\", \"attributes\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid batchGet options: ${args.join(', ')}`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Init RequestItems and Tables reference\n    let RequestItems = {};\n    let Tables = {};\n    let TableAliases = {};\n    let EntityProjections = {};\n    let TableProjections = {};\n    // // Loop through items\n    for (const i in items) {\n      const item = items[i];\n      // Check item for Table reference and key\n      if (item && item.Table && item.Table.Table && item.Key && typeof item.Key === 'object' && !Array.isArray(item.Key)) {\n        // Set the table\n        const table = item.Table.name;\n        // If it doesn't exist\n        if (!RequestItems[table]) {\n          // Create a table property with an empty array\n          RequestItems[table] = {\n            Keys: []\n          };\n          // Add the table/table alias reference\n          Tables[table] = item.Table;\n          if (item.Table.alias) TableAliases[item.Table.alias] = table;\n        }\n        // Push request onto the table array\n        RequestItems[table].Keys.push(item.Key);\n      } else {\n        utils_1.error(`Item references must contain a valid Table object and Key`);\n      }\n    } // end item loop\n    // Parse 'consistent' option\n    if (consistent) {\n      // If true, add to all table mappings\n      if (consistent === true) {\n        for (const tbl in RequestItems) RequestItems[tbl].ConsistentRead = true;\n      } else if (typeof consistent === 'object' && !Array.isArray(consistent)) {\n        for (const tbl in consistent) {\n          const tbl_name = TableAliases[tbl] || tbl;\n          if (RequestItems[tbl_name]) {\n            if (typeof consistent[tbl] === 'boolean') {\n              RequestItems[tbl_name].ConsistentRead = consistent[tbl];\n            } else {\n              utils_1.error(`'consistent' values must be booleans (${tbl})`);\n            }\n          } else {\n            utils_1.error(`There are no items for the table or table alias: ${tbl}`);\n          }\n        } // end if\n      } else {\n        utils_1.error(`'consistent' must be a boolean or an map of table names`);\n      }\n    } // end consistent\n    // If projections\n    if (attributes) {\n      let attrs = attributes;\n      // If an Array, ensure single table and convert to standard format\n      if (Array.isArray(attributes)) {\n        if (Object.keys(RequestItems).length === 1) {\n          attrs = {\n            [Object.keys(RequestItems)[0]]: attributes\n          };\n        } else {\n          utils_1.error(`'attributes' must use a table map when requesting items from multiple tables`);\n        }\n      } // end if array\n      for (const tbl in attrs) {\n        const tbl_name = TableAliases[tbl] || tbl;\n        if (Tables[tbl_name]) {\n          const {\n            names,\n            projections,\n            entities,\n            tableAttrs\n          } = projectionBuilder_1.default(attrs[tbl], Tables[tbl_name], null, true);\n          RequestItems[tbl_name].ExpressionAttributeNames = names;\n          RequestItems[tbl_name].ProjectionExpression = projections;\n          EntityProjections[tbl_name] = entities;\n          TableProjections[tbl_name] = tableAttrs;\n        } else {\n          utils_1.error(`There are no items for the table: ${tbl}`);\n        }\n      }\n    } // end if projections\n    const payload = Object.assign({\n      RequestItems\n    }, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, typeof params === 'object' ? params : null);\n    return meta ? {\n      payload,\n      Tables,\n      EntityProjections,\n      TableProjections\n    } : payload;\n  } // batchGetParams\n  // BatchWrite Items\n  batchWrite(items, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload with meta information\n      const payload = this.batchWriteParams(items, options, params);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.batchWrite(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          // TODO: Left in for testing. Needs to be removed\n          // result.UnprocessedKeys = testUnprocessedKeys\n          return this.parseBatchWriteResponse(result, options);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end-if\n    });\n  } // end put\n  parseBatchWriteResponse(result, options = {}) {\n    return Object.assign(result,\n    // If UnprocessedItems, return a next function\n    result.UnprocessedItems && Object.keys(result.UnprocessedItems).length > 0 ? {\n      next: () => __awaiter(this, void 0, void 0, function* () {\n        const nextResult = yield this.DocumentClient.batchWrite(Object.assign({\n          RequestItems: result.UnprocessedItems\n        }, options.capacity ? {\n          ReturnConsumedCapacity: options.capacity.toUpperCase()\n        } : null, options.metrics ? {\n          ReturnItemCollectionMetrics: options.metrics.toUpperCase()\n        } : null)).promise();\n        return this.parseBatchWriteResponse(nextResult, options);\n      })\n    } : {\n      next: () => false\n    } // TODO: How should this return?\n    ); // end parse assign\n  } // end parseBatchWriteResponse\n  /**\n   * Generates parameters for a batchWrite\n   * @param {object} items - An array of objects generated from putBatch and/or deleteBatch entity calls.\n   * @param {object} [options] - Additional batchWrite options\n   * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the batchWrite request.\n   * @param {boolean} [meta] - Internal flag to enable entity parsing\n   *\n  */\n  batchWriteParams(_items, options = {}, params = {}, meta = false) {\n    // Convert items to array\n    let items = (Array.isArray(_items) ? _items : [_items]).filter(x => x);\n    // Error on no items\n    if (items.length === 0) utils_1.error(`No items supplied`);\n    const {\n        capacity,\n        metrics\n      } = options,\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"capacity\", \"metrics\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid batchWrite options: ${args.join(', ')}`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify metrics\n    if (metrics !== undefined && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase()))) utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n    // Init RequestItems\n    const RequestItems = {};\n    // Loop through items\n    for (const i in items) {\n      const item = items[i];\n      const table = Object.keys(item)[0];\n      // Create a table property with an empty array if it doesn't exist\n      if (!RequestItems[table]) RequestItems[table] = [];\n      // TODO: Add some validation here?\n      // Push request onto the table array\n      RequestItems[table].push(item[table]);\n    }\n    const payload = Object.assign({\n      RequestItems\n    }, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, metrics ? {\n      ReturnItemCollectionMetrics: metrics.toUpperCase()\n    } : null, typeof params === 'object' ? params : null);\n    const Tables = {};\n    return meta ? {\n      payload,\n      Tables\n    } : payload;\n  } // batchWriteParams\n  /**\n   * Performs a transactGet operation\n   * @param {object} items - An array of objects generated from getTransaction entity calls.\n   * @param {object} [options] - Additional transactGet options\n   *\n  */\n  transactGet(items = [], options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload with meta information\n      const {\n        payload,\n        Entities\n      } = this.transactGetParams(items, options, true);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.transactGet(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          // Parse the items using the appropriate entity\n          return Object.assign(result, result.Responses ? {\n            Responses: result.Responses.map((res, i) => {\n              if (res.Item) {\n                return {\n                  Item: Entities[i].parse ? Entities[i].parse(res.Item) : res.Item\n                };\n              } else {\n                return {};\n              }\n            })\n          } : null);\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end-if\n    });\n  } // end transactGet\n  transactGetParams(_items, options = {}, meta = false) {\n    let items = Array.isArray(_items) ? _items : _items ? [_items] : [];\n    // Error on no items\n    if (items.length === 0) utils_1.error(`No items supplied`);\n    // Extract valid options\n    const {\n        capacity\n      } = options,\n      // ReturnConsumedCapacity (none, total, or indexes)\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"capacity\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid transactGet options: ${args.join(', ')}`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    let Entities = [];\n    // Generate the payload\n    const payload = Object.assign({\n      // Loop through items and verify transaction objects\n      TransactItems: items.map(item => {\n        let {\n            Entity\n          } = item,\n          _item = __rest(item, [\"Entity\"]);\n        Entities.push(Entity);\n        if (!('Get' in _item) || Object.keys(_item).length > 1) utils_1.error(`Invalid transaction item. Use the 'getTransaction' method on an entity.`);\n        return _item;\n      })\n    }, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null);\n    // Return transact items\n    return meta ? {\n      Entities,\n      payload\n    } : payload;\n  } // end transactGetParams\n  /**\n   * Performs a transactWrite operation\n   * @param {object} items - An array of objects generated from putTransaction, updateTransaction, or deleteTransaction entity calls.\n   * @param {object} [options] - Additional transactWrite options\n   *\n  */\n  transactWrite(items, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Generate the payload with meta information\n      const payload = this.transactWriteParams(items, options);\n      // If auto execute enabled\n      if (options.execute || this.autoExecute && options.execute !== false) {\n        const result = yield this.DocumentClient.transactWrite(payload).promise();\n        // If auto parse enable\n        if (options.parse || this.autoParse && options.parse !== false) {\n          return result;\n        } else {\n          return result;\n        }\n      } else {\n        return payload;\n      } // end-if\n    });\n  } // end transactGet\n  /**\n   * Generates parameters for a transactWrite operation\n   * @param {object} items - An array of objects generated from putTransaction, updateTransaction, or deleteTransaction entity calls.\n   * @param {object} [options] - Additional options\n   *\n   * Creates a TransactWriteItems object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactWriteItems.html\n   */\n  transactWriteParams(_items, options = {}) {\n    let items = Array.isArray(_items) ? _items : _items ? [_items] : [];\n    // Error on no items\n    if (items.length === 0) utils_1.error(`No items supplied`);\n    // Extract valid options\n    const {\n        capacity,\n        // ReturnConsumedCapacity (none, total, or indexes)\n        metrics,\n        // ReturnItemCollectionMetrics (size or none)\n        token\n      } = options,\n      // ClientRequestToken (1-36 characters)\n      _args = __rest(options\n      // Remove other valid options from options\n      , [\"capacity\", \"metrics\", \"token\"]);\n    // Remove other valid options from options\n    const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n    // Error on extraneous arguments\n    if (args.length > 0) utils_1.error(`Invalid transactWrite options: ${args.join(', ')}`);\n    // Verify capacity\n    if (capacity !== undefined && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase()))) utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n    // Verify metrics\n    if (metrics !== undefined && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase()))) utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n    // Verify token\n    if (token !== undefined && (typeof token !== 'string' || token.trim().length === 0 || token.trim().length > 36)) utils_1.error(`'token' must be a string up to 36 characters long `);\n    // Generate the payload\n    const payload = Object.assign({\n      // Loop through items\n      TransactItems: items.map(item => {\n        if (\n        // Check for valid transaction object\n        !('ConditionCheck' in item) && !('Delete' in item) && !('Put' in item) && !('Update' in item) || Object.keys(item).length > 1) utils_1.error(`Invalid transaction item. Use the 'putTransaction', 'updateTransaction', 'deleteTransaction', or 'conditionCheck' methods on an entity.`);\n        return item;\n      })\n    }, capacity ? {\n      ReturnConsumedCapacity: capacity.toUpperCase()\n    } : null, metrics ? {\n      ReturnItemCollectionMetrics: metrics.toUpperCase()\n    } : null, token ? {\n      ClientRequestToken: token.trim()\n    } : null);\n    return payload;\n  } // end transactWriteParams\n  // Entity operation references\n  parse(entity, input, include = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this[entity]) utils_1.error(`'${entity}' is not a valid Entity`);\n      return this[entity].parse(input, include);\n    });\n  }\n  get(entity, item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this[entity]) utils_1.error(`'${entity}' is not a valid Entity`);\n      return this[entity].get(item, options, params);\n    });\n  }\n  delete(entity, item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this[entity]) utils_1.error(`'${entity}' is not a valid Entity`);\n      return this[entity].delete(item, options, params);\n    });\n  }\n  update(entity, item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this[entity]) utils_1.error(`'${entity}' is not a valid Entity`);\n      return this[entity].update(item, options, params);\n    });\n  }\n  put(entity, item = {}, options = {}, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this[entity]) utils_1.error(`'${entity}' is not a valid Entity`);\n      return this[entity].put(item, options, params);\n    });\n  }\n} // end Table class\n// Export the Table class\nexports.default = Table;","map":{"version":3,"names":["__awaiter","undefined","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__rest","s","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__importDefault","mod","__esModule","defineProperty","exports","Entity_1","require","parseTable_1","expressionBuilder_1","validateTypes_1","projectionBuilder_1","utils_1","Table","constructor","table","_execute","_parse","_removeNulls","_entities","Array","isArray","error","assign","parseTable","autoExecute","val","autoParse","removeNullAttributes","DocumentClient","_docClient","docClient","get","put","delete","update","options","convertEmptyValues","addEntity","entity","entities","default","includes","name","reservedWords","getOwnPropertyNames","concat","getPrototypeOf","sortKey","schema","keys","key","attr","attributes","alias","map","indexes","keyType","config","partitionKey","entityField","_etAlias","type","mappings","_setType","setType","push","query","pk","params","payload","EntityProjections","TableProjections","queryParams","execute","promise","parse","Items","item","String","LastEvaluatedKey","startKey","projections","index","limit","reverse","consistent","capacity","select","eq","lt","lte","gt","gte","between","beginsWith","filters","_args","args","filter","x","join","trim","Number","isInteger","toUpperCase","ExpressionAttributeNames","ExpressionAttributeValues","KeyConditionExpression","FilterExpression","ProjectionExpression","operator","f","conditonError","sk","validateType","expression","names","values","tableAttrs","TableName","IndexName","Limit","ScanIndexForward","ConsistentRead","ReturnConsumedCapacity","Select","ExclusiveStartKey","scan","scanParams","meta","segments","segment","TotalSegments","Segment","batchGet","items","Tables","batchGetParams","parseBatchGetResponse","Responses","reduce","acc","UnprocessedKeys","nextResult","RequestItems","_items","TableAliases","Key","Keys","tbl","tbl_name","attrs","batchWrite","batchWriteParams","parseBatchWriteResponse","UnprocessedItems","metrics","ReturnItemCollectionMetrics","transactGet","Entities","transactGetParams","res","Item","TransactItems","Entity","_item","transactWrite","transactWriteParams","token","ClientRequestToken","input","include"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/classes/Table.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: Check duplicate entity names code\n// Import libraries, types, and classes\nconst Entity_1 = __importDefault(require(\"./Entity\"));\nconst parseTable_1 = require(\"../lib/parseTable\");\nconst expressionBuilder_1 = __importDefault(require(\"../lib/expressionBuilder\"));\nconst validateTypes_1 = __importDefault(require(\"../lib/validateTypes\"));\nconst projectionBuilder_1 = __importDefault(require(\"../lib/projectionBuilder\"));\n// Import standard error handler\nconst utils_1 = require(\"../lib/utils\");\n// Declare Table class\nclass Table {\n    // Declare constructor (table config and optional entities)\n    constructor(table) {\n        this._execute = true;\n        this._parse = true;\n        this._removeNulls = true;\n        this._entities = [];\n        // Sanity check the table definition\n        if (typeof table !== 'object' || Array.isArray(table))\n            utils_1.error('Please provide a valid table definition');\n        // Parse the table and merge into this\n        Object.assign(this, parseTable_1.parseTable(table));\n    } // end constructor\n    // Sets the auto execute mode (default to true)\n    set autoExecute(val) { this._execute = typeof val === 'boolean' ? val : true; }\n    // Gets the current auto execute mode\n    get autoExecute() { return this._execute; }\n    // Sets the auto parse mode (default to true)\n    set autoParse(val) { this._parse = typeof val === 'boolean' ? val : true; }\n    // Gets the current auto execute mode\n    get autoParse() { return this._parse; }\n    // Sets the auto execute mode (default to true)\n    set removeNullAttributes(val) { this._removeNulls = typeof val === 'boolean' ? val : true; }\n    // Gets the current auto execute mode\n    get removeNullAttributes() { return this._removeNulls; }\n    // Retrieves the document client\n    get DocumentClient() { return this._docClient; }\n    // Validate and sets the document client (extend with options.convertEmptyValues because it's not typed)\n    set DocumentClient(docClient) {\n        // If a valid document client\n        if (docClient && docClient.get && docClient.put && docClient.delete && docClient.update) {\n            // Automatically set convertEmptyValues to true, unless false\n            if (docClient.options.convertEmptyValues !== false)\n                docClient.options.convertEmptyValues = true;\n            this._docClient = docClient;\n        }\n        else {\n            utils_1.error('Invalid DocumentClient');\n        }\n    } // end DocumentClient\n    /**\n     * Adds an entity to the table\n     * @param {Entity|Entity[]} Entity - An Entity or array of Entities to add to the table.\n    */\n    addEntity(entity) {\n        // Coerce entity to array\n        let entities = Array.isArray(entity) ? entity : [entity];\n        // Loop through entities\n        for (let i in entities) {\n            let entity = entities[i];\n            // If an instance of Entity, add it\n            if (entity instanceof Entity_1.default) {\n                // Check for existing entity name\n                if (this._entities && this._entities.includes(entity.name)) {\n                    utils_1.error(`Entity name '${entity.name}' already exists`);\n                }\n                // Generate the reserved words list\n                const reservedWords = Object.getOwnPropertyNames(this)\n                    .concat(Object.getOwnPropertyNames(Object.getPrototypeOf(this)));\n                // Check for reserved word\n                if (reservedWords.includes(entity.name)) {\n                    utils_1.error(`'${entity.name}' is a reserved word and cannot be used to name an Entity`);\n                }\n                // Check for sortKeys (if applicable)\n                if (!this.Table.sortKey && entity.schema.keys.sortKey) {\n                    utils_1.error(`${entity.name} entity contains a sortKey, but the Table does not`);\n                }\n                else if (this.Table.sortKey && !entity.schema.keys.sortKey) {\n                    utils_1.error(`${entity.name} entity does not have a sortKey defined`);\n                }\n                // Process Entity index keys\n                for (const key in entity.schema.keys) {\n                    // Set the value of the key\n                    const attr = entity.schema.keys[key];\n                    // Switch based on key type (pk, sk, or index)\n                    switch (key) {\n                        // For the primary index\n                        case 'partitionKey':\n                        case 'sortKey':\n                            // If the attribute's name doesn't match the table's pk/sk name\n                            if (attr !== this.Table[key] && this.Table[key]) {\n                                // If the table's index attribute name does not conflict with another entity attribute\n                                if (!entity.schema.attributes[this.Table[key]]) { // FIX: better way to do this?\n                                    // Add the attribute using the same config and add alias\n                                    entity.schema.attributes[this.Table[key]] = Object.assign({}, entity.schema.attributes[attr], { alias: attr }); // end assign\n                                    // Add a map from the attribute to the new index attribute\n                                    entity.schema.attributes[attr].map = this.Table[key];\n                                    // Otherwise, throw an error\n                                }\n                                else {\n                                    utils_1.error(`The Table's ${key} name (${this.Table[key]}) conflicts with an Entity attribute name`);\n                                } // end if-else\n                            } // end if\n                            break;\n                        // For secondary indexes\n                        default:\n                            // Verify that the table has this index\n                            if (!this.Table.indexes[key])\n                                utils_1.error(`'${key}' is not a valid secondary index name`);\n                            // Loop through the key types (pk/sk) defined in the key mapping\n                            for (const keyType in attr) {\n                                // Make sure the table index contains the defined key types\n                                // @ts-ignore\n                                if (!this.Table.indexes[key][keyType])\n                                    utils_1.error(`${entity.name} contains a ${keyType}, but it is not used by ${key}`);\n                                // console.log(key,keyType,this.Table.indexes[key])\n                                // If the attribute's name doesn't match the indexes attribute name\n                                // @ts-ignore\n                                if (attr[keyType] !== this.Table.indexes[key][keyType]) {\n                                    // If the indexes attribute name does not conflict with another entity attribute\n                                    // @ts-ignore\n                                    if (!entity.schema.attributes[this.Table.indexes[key][keyType]]) {\n                                        // If there is already a mapping for this attribute, make sure they match\n                                        // TODO: Figure out if this is even possible anymore. I don't think it is.\n                                        if (entity.schema.attributes[attr[keyType]].map\n                                            // @ts-ignore\n                                            && entity.schema.attributes[attr[keyType]].map !== this.Table.indexes[key][keyType])\n                                            utils_1.error(`${key}'s ${keyType} cannot map to the '${attr[keyType]}' alias because it is already mapped to another table attribute`);\n                                        // Add the index attribute using the same config and add alias\n                                        // @ts-ignore\n                                        entity.schema.attributes[this.Table.indexes[key][keyType]] = Object.assign({}, entity.schema.attributes[attr[keyType]], { alias: attr[keyType] }); // end assign\n                                        // Add a map from the attribute to the new index attribute\n                                        // @ts-ignore\n                                        entity.schema.attributes[attr[keyType]].map = this.Table.indexes[key][keyType];\n                                    }\n                                    else {\n                                        // @ts-ignore\n                                        const config = entity.schema.attributes[this.Table.indexes[key][keyType]];\n                                        // If the existing attribute isn't used by this index\n                                        if ((!config.partitionKey && !config.sortKey)\n                                            || (config.partitionKey && !config.partitionKey.includes(key))\n                                            || (config.sortKey && !config.sortKey.includes(key))) {\n                                            // @ts-ignore\n                                            utils_1.error(`${key}'s ${keyType} name (${this.Table.indexes[key][keyType]}) conflicts with another Entity attribute name`);\n                                        } // end if\n                                    } // end if-else\n                                } // end if\n                            } // end for\n                            // Check that composite keys define both keys\n                            // TODO: This only checks for the attribute, not the explicit assignment\n                            if (this.Table.indexes[key].partitionKey && this.Table.indexes[key].sortKey\n                                && (!entity.schema.attributes[this.Table.indexes[key].partitionKey]\n                                    || !entity.schema.attributes[this.Table.indexes[key].sortKey])) {\n                                utils_1.error(`${key} requires mappings for both the partitionKey and the sortKey`);\n                            }\n                            break;\n                    } // end switch\n                } // end for\n                // Loop through the Entity's attributes and validate their types against the Table definition\n                // Add attribute to table if not defined\n                for (let attr in entity.schema.attributes) {\n                    // If an entity field conflicts with the entityField or its alias, throw an error\n                    if (this.Table.entityField && (attr === this.Table.entityField || attr === entity._etAlias)) {\n                        utils_1.error(`Attribute or alias '${attr}' conflicts with the table's 'entityField' mapping or entity alias`);\n                        // If the atribute already exists in the table definition\n                    }\n                    else if (this.Table.attributes[attr]) {\n                        // If type is specified, check for attribute match\n                        if (this.Table.attributes[attr].type\n                            && this.Table.attributes[attr].type !== entity.schema.attributes[attr].type)\n                            utils_1.error(`${entity.name} attribute type for '${attr}' (${entity.schema.attributes[attr].type}) does not match table's type (${this.Table.attributes[attr].type})`);\n                        // Add entity mappings\n                        this.Table.attributes[attr].mappings[entity.name] = Object.assign({\n                            [entity.schema.attributes[attr].alias || attr]: entity.schema.attributes[attr].type\n                        }, \n                        // Add setType if type 'set'\n                        entity.schema.attributes[attr].type === 'set'\n                            ? { _setType: entity.schema.attributes[attr].setType }\n                            : {});\n                        // else if the attribute doesn't exist\n                    }\n                    else if (!entity.schema.attributes[attr].map) {\n                        // Add type and entity map\n                        this.Table.attributes[attr] = Object.assign({\n                            mappings: {\n                                [entity.name]: Object.assign({\n                                    [entity.schema.attributes[attr].alias || attr]: entity.schema.attributes[attr].type\n                                }, \n                                // Add setType if type 'set'\n                                entity.schema.attributes[attr].type === 'set'\n                                    ? { _setType: entity.schema.attributes[attr].setType }\n                                    : {})\n                            }\n                        }, entity.schema.attributes[attr].partitionKey || entity.schema.attributes[attr].sortKey\n                            ? { type: entity.schema.attributes[attr].type } : null); // end assign\n                    } // end if-else Table attribute exists\n                } // end for loop to check/add attributes\n                // Add the Entity to the Table's entities list\n                this._entities.push(entity.name);\n                // Add the entity to the Table object\n                this[entity.name] = entity;\n                // Set the Entity's table by reference\n                entity.table = this;\n            }\n            else {\n                utils_1.error('Invalid Entity');\n            }\n        } // end for\n    } // end addEntity\n    // Deprecation notice\n    set entities(entity) {\n        this.addEntity(entity);\n        //error(`Setting entities by assignment has been deprecated. Please use 'addEntity' instead.`)  \n    }\n    get entities() {\n        return this._entities;\n    }\n    // ----------------------------------------------------------------//\n    // Table actions\n    // ----------------------------------------------------------------//\n    query(pk, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate query parameters with projection data\n            const { payload, EntityProjections, TableProjections } = this.queryParams(pk, options, params, true);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.query(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, {\n                        Items: result.Items && result.Items.map(item => {\n                            if (this[item[String(this.Table.entityField)]]) {\n                                return this[item[String(this.Table.entityField)]].parse(item, \n                                // Array.isArray(options.omit) ? options.omit : [],\n                                EntityProjections[item[String(this.Table.entityField)]] ? EntityProjections[item[String(this.Table.entityField)]]\n                                    : TableProjections ? TableProjections\n                                        : []);\n                            }\n                            else {\n                                return item;\n                            }\n                        })\n                    }, \n                    // If last evaluated key, return a next function\n                    result.LastEvaluatedKey ? {\n                        next: () => {\n                            return this.query(pk, Object.assign(options, { startKey: result.LastEvaluatedKey }), params);\n                        }\n                    } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end if-else\n        });\n    }\n    // Query the table\n    queryParams(pk, options = {}, params = {}, projections = false) {\n        // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.KeyConditionExpressions\n        // Deconstruct valid options\n        const { index, limit, reverse, // ScanIndexForward\n        consistent, // ConsistentRead (boolean)\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        select, // Select (all_attributes, all_projected_attributes, specific_attributes, count)\n        eq, // =\n        lt, // <\n        lte, // <=\n        gt, // >\n        gte, // >=\n        between, // between\n        beginsWith, // begins_with,\n        filters, // filter object,\n        attributes, // Projections\n        startKey, entity } = options, // optional entity name to filter aliases\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"index\", \"limit\", \"reverse\", \"consistent\", \"capacity\", \"select\", \"eq\", \"lt\", \"lte\", \"gt\", \"gte\", \"between\", \"beginsWith\", \"filters\", \"attributes\", \"startKey\", \"entity\"]) // capture extra arguments\n        ;\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid query options: ${args.join(', ')}`);\n        // Verify pk\n        if ((typeof pk !== 'string' && typeof pk !== 'number') || (typeof pk === 'string' && pk.trim().length === 0))\n            utils_1.error(`Query requires a string, number or binary 'partitionKey' as its first parameter`);\n        // Verify index\n        if (index !== undefined && !this.Table.indexes[index])\n            utils_1.error(`'${index}' is not a valid index name`);\n        // Verify limit\n        if (limit !== undefined && (!Number.isInteger(limit) || limit < 0))\n            utils_1.error(`'limit' must be a positive integer`);\n        // Verify reverse\n        if (reverse !== undefined && typeof reverse !== 'boolean')\n            utils_1.error(`'reverse' requires a boolean`);\n        // Verify consistent read\n        if (consistent !== undefined && typeof consistent !== 'boolean')\n            utils_1.error(`'consistent' requires a boolean`);\n        // Verify select\n        // TODO: Make dependent on whether or not an index is supplied\n        if (select !== undefined\n            && (typeof select !== 'string'\n                || !['ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', 'COUNT'].includes(select.toUpperCase())))\n            utils_1.error(`'select' must be one of 'ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', OR 'COUNT'`);\n        // Verify entity\n        if (entity !== undefined && (typeof entity !== 'string' || !(entity in this)))\n            utils_1.error(`'entity' must be a string and a valid table Entity name`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify startKey\n        // TODO: validate startKey shape\n        if (startKey && (typeof startKey !== 'object' || Array.isArray(startKey)))\n            utils_1.error(`'startKey' requires a valid object`);\n        // Default names and values\n        let ExpressionAttributeNames = { '#pk': (index && this.Table.indexes[index].partitionKey) || this.Table.partitionKey };\n        let ExpressionAttributeValues = { ':pk': pk };\n        let KeyConditionExpression = '#pk = :pk';\n        let FilterExpression; // init FilterExpression\n        let ProjectionExpression; // init ProjectionExpression\n        let EntityProjections = {};\n        let TableProjections; // FIXME: removed default\n        // Parse sortKey condition operator and value\n        let operator, value, f = '';\n        if (eq) {\n            value = eq;\n            f = 'eq';\n            operator = '=';\n        }\n        if (lt) {\n            value = value ? utils_1.conditonError(f) : lt;\n            f = 'lt';\n            operator = '<';\n        }\n        if (lte) {\n            value = value ? utils_1.conditonError(f) : lte;\n            f = 'lte';\n            operator = '<=';\n        }\n        if (gt) {\n            value = value ? utils_1.conditonError(f) : gt;\n            f = 'gt';\n            operator = '>';\n        }\n        if (gte) {\n            value = value ? utils_1.conditonError(f) : gte;\n            f = 'gte';\n            operator = '>=';\n        }\n        if (beginsWith) {\n            value = value ? utils_1.conditonError(f) : beginsWith;\n            f = 'beginsWith';\n            operator = 'BEGINS_WITH';\n        }\n        if (between) {\n            value = value ? utils_1.conditonError(f) : between;\n            f = 'between';\n            operator = 'BETWEEN';\n        }\n        // If a sortKey condition was set\n        if (operator) {\n            // Get sortKey configuration\n            const sk = index ?\n                (this.Table.indexes[index].sortKey ? (this.Table.attributes[this.Table.indexes[index].sortKey] || { type: 'string' })\n                    : utils_1.error(`Conditional expressions require the index to have a sortKey`))\n                : this.Table.sortKey ? this.Table.attributes[this.Table.sortKey]\n                    : utils_1.error(`Conditional expressions require the table to have a sortKey`);\n            // Init validateType\n            const validateType = validateTypes_1.default(this.DocumentClient);\n            // Add the sortKey attribute name\n            ExpressionAttributeNames['#sk'] = (index && this.Table.indexes[index].sortKey) || this.Table.sortKey;\n            // If between operation\n            if (operator === 'BETWEEN') {\n                // Verify array input\n                if (!Array.isArray(value) || value.length !== 2)\n                    utils_1.error(`'between' conditions requires an array with two values.`);\n                // Add values and special key condition\n                ExpressionAttributeValues[':sk0'] = validateType(sk, f + '[0]', value[0]);\n                ExpressionAttributeValues[':sk1'] = validateType(sk, f + '[1]', value[1]);\n                KeyConditionExpression += ' and #sk between :sk0 and :sk1';\n            }\n            else {\n                // Add value\n                ExpressionAttributeValues[':sk'] = validateType(sk, f, value);\n                // If begins_with, add special key condition\n                if (operator === 'BEGINS_WITH') {\n                    KeyConditionExpression += ' and begins_with(#sk,:sk)';\n                }\n                else {\n                    KeyConditionExpression += ` and #sk ${operator} :sk`;\n                }\n            } // end if-else    \n        } // end if operator\n        // If filter expressions\n        if (filters) {\n            // Parse the filter\n            const { expression, names, values } = expressionBuilder_1.default(filters, this, entity);\n            if (Object.keys(names).length > 0) {\n                // TODO: alias attribute field names\n                // console.log(names)\n                // Merge names and values and add filter expression\n                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n                ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n                FilterExpression = expression;\n            } // end if names\n        } // end if filters\n        // If projections\n        if (attributes) {\n            const { names, projections, entities, tableAttrs } = projectionBuilder_1.default(attributes, this, entity, true);\n            if (Object.keys(names).length > 0) {\n                // Merge names and add projection expression\n                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n                ProjectionExpression = projections;\n                EntityProjections = entities;\n                TableProjections = tableAttrs;\n            } // end if names\n        } // end if projections\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: this.name,\n            KeyConditionExpression,\n            ExpressionAttributeNames,\n            ExpressionAttributeValues\n        }, FilterExpression ? { FilterExpression } : null, ProjectionExpression ? { ProjectionExpression } : null, index ? { IndexName: index } : null, limit ? { Limit: String(limit) } : null, reverse ? { ScanIndexForward: !reverse } : null, consistent ? { ConsistentRead: consistent } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, select ? { Select: select.toUpperCase() } : null, startKey ? { ExclusiveStartKey: startKey } : null, typeof params === 'object' ? params : null);\n        return projections ? { payload, EntityProjections, TableProjections } : payload;\n    } // end query\n    // SCAN the table\n    scan(options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate query parameters with meta data\n            const { payload, EntityProjections, TableProjections } = this.scanParams(options, params, true);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.scan(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return Object.assign(result, {\n                        Items: result.Items && result.Items.map(item => {\n                            if (this[item[String(this.Table.entityField)]]) {\n                                return this[item[String(this.Table.entityField)]].parse(item, EntityProjections[item[String(this.Table.entityField)]] ? EntityProjections[item[String(this.Table.entityField)]]\n                                    : TableProjections ? TableProjections\n                                        : []);\n                            }\n                            else {\n                                return item;\n                            }\n                        })\n                    }, \n                    // If last evaluated key, return a next function\n                    result.LastEvaluatedKey ? {\n                        next: () => {\n                            return this.scan(Object.assign(options, { startKey: result.LastEvaluatedKey }), params);\n                        }\n                    } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end if-else\n        });\n    }\n    // Generate SCAN Parameters\n    scanParams(options = {}, params = {}, meta = false) {\n        // https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.KeyConditionExpressions\n        // Deconstruct valid options\n        const { index, limit, consistent, // ConsistentRead (boolean)\n        capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        select, // Select (all_attributes, all_projected_attributes, specific_attributes, count)\n        filters, // filter object,\n        attributes, // Projections\n        segments, // Segments,\n        segment, // Segment\n        startKey, entity } = options, // optional entity name to filter aliases\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"index\", \"limit\", \"consistent\", \"capacity\", \"select\", \"filters\", \"attributes\", \"segments\", \"segment\", \"startKey\", \"entity\"]) // capture extra arguments\n        ;\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid scan options: ${args.join(', ')}`);\n        // Verify index\n        if (index !== undefined && !this.Table.indexes[index])\n            utils_1.error(`'${index}' is not a valid index name`);\n        // Verify limit\n        if (limit !== undefined && (!Number.isInteger(limit) || limit < 0))\n            utils_1.error(`'limit' must be a positive integer`);\n        // Verify consistent read\n        if (consistent !== undefined && typeof consistent !== 'boolean')\n            utils_1.error(`'consistent' requires a boolean`);\n        // Verify select\n        // TODO: Make dependent on whether or not an index is supplied\n        if (select !== undefined\n            && (typeof select !== 'string'\n                || !['ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', 'COUNT'].includes(select.toUpperCase())))\n            utils_1.error(`'select' must be one of 'ALL_ATTRIBUTES', 'ALL_PROJECTED_ATTRIBUTES', 'SPECIFIC_ATTRIBUTES', OR 'COUNT'`);\n        // Verify entity\n        if (entity !== undefined && (typeof entity !== 'string' || !(entity in this)))\n            utils_1.error(`'entity' must be a string and a valid table Entity name`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify startKey\n        // TODO: validate startKey shape\n        if (startKey && (typeof startKey !== 'object' || Array.isArray(startKey)))\n            utils_1.error(`'startKey' requires a valid object`);\n        // Verify consistent segments\n        if (segments !== undefined && (!Number.isInteger(segments) || segments < 1))\n            utils_1.error(`'segments' must be an integer greater than 1`);\n        if (segment !== undefined && (!Number.isInteger(segment) || segment < 0 || segment >= segments))\n            utils_1.error(`'segment' must be an integer greater than or equal to 0 and less than the total number of segments`);\n        if ((segments !== undefined && segment === undefined) || (segments === undefined && segment !== undefined))\n            utils_1.error(`Both 'segments' and 'segment' must be provided`);\n        // Default names and values\n        let ExpressionAttributeNames = {};\n        let ExpressionAttributeValues = {};\n        let FilterExpression; // init FilterExpression\n        let ProjectionExpression; // init ProjectionExpression\n        let EntityProjections = {};\n        let TableProjections;\n        // If filter expressions\n        if (filters) {\n            // Parse the filter\n            const { expression, names, values } = expressionBuilder_1.default(filters, this, entity);\n            if (Object.keys(names).length > 0) {\n                // TODO: alias attribute field names\n                // console.log(names)\n                // Merge names and values and add filter expression\n                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n                ExpressionAttributeValues = Object.assign(ExpressionAttributeValues, values);\n                FilterExpression = expression;\n            } // end if names\n        } // end if filters\n        // If projections\n        if (attributes) {\n            const { names, projections, entities, tableAttrs } = projectionBuilder_1.default(attributes, this, entity, true);\n            if (Object.keys(names).length > 0) {\n                // Merge names and add projection expression\n                ExpressionAttributeNames = Object.assign(ExpressionAttributeNames, names);\n                ProjectionExpression = projections;\n                EntityProjections = entities;\n                TableProjections = tableAttrs;\n            } // end if names\n        } // end if projections\n        // Generate the payload\n        const payload = Object.assign({\n            TableName: this.name,\n        }, Object.keys(ExpressionAttributeNames).length ? { ExpressionAttributeNames } : null, Object.keys(ExpressionAttributeValues).length ? { ExpressionAttributeValues } : null, FilterExpression ? { FilterExpression } : null, ProjectionExpression ? { ProjectionExpression } : null, index ? { IndexName: index } : null, segments ? { TotalSegments: segments } : null, Number.isInteger(segment) ? { Segment: segment } : null, limit ? { Limit: String(limit) } : null, consistent ? { ConsistentRead: consistent } : null, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, select ? { Select: select.toUpperCase() } : null, startKey ? { ExclusiveStartKey: startKey } : null, typeof params === 'object' ? params : null);\n        return meta ? { payload, EntityProjections, TableProjections } : payload;\n    } // end query\n    // BatchGet Items\n    batchGet(items, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload with meta information\n            const { payload, // batchGet payload\n            Tables, // table reference\n            EntityProjections, TableProjections } = this.batchGetParams(items, options, params, true);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.batchGet(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    // TODO: Left in for testing. Needs to be removed\n                    // result.UnprocessedKeys = testUnprocessedKeys\n                    return this.parseBatchGetResponse(result, Tables, EntityProjections, TableProjections, options);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end-if\n        });\n    } // end batchGet\n    parseBatchGetResponse(result, Tables, EntityProjections, TableProjections, options = {}) {\n        return Object.assign(result, \n        // If reponses exist\n        result.Responses ? {\n            // Loop through the tables \n            Responses: Object.keys(result.Responses).reduce((acc, table) => {\n                // Merge in tables\n                return Object.assign(acc, {\n                    // Map over the items\n                    [(Tables[table] && Tables[table].alias) || table]: result.Responses[table].map((item) => {\n                        // Check that the table has a reference, the entityField exists, and that the entity type exists on the table\n                        if (Tables[table] && Tables[table][item[String(Tables[table].Table.entityField)]]) {\n                            // Parse the item and pass in projection references\n                            return Tables[table][item[String(Tables[table].Table.entityField)]].parse(item, EntityProjections[table] && EntityProjections[table][item[String(Tables[table].Table.entityField)]] ? EntityProjections[table][item[String(Tables[table].Table.entityField)]]\n                                : TableProjections[table] ? TableProjections[table]\n                                    : []);\n                            // Else, just return the original item\n                        }\n                        else {\n                            return item;\n                        }\n                    }) // end item map\n                }); // end assign\n            }, {}) // end table reduce\n        } : null, // end if Responses\n        // If UnprocessedKeys, return a next function\n        result.UnprocessedKeys && Object.keys(result.UnprocessedKeys).length > 0 ? {\n            next: () => __awaiter(this, void 0, void 0, function* () {\n                const nextResult = yield this.DocumentClient.batchGet(Object.assign({ RequestItems: result.UnprocessedKeys }, options.capacity ? { ReturnConsumedCapacity: options.capacity.toUpperCase() } : null)).promise();\n                return this.parseBatchGetResponse(nextResult, Tables, EntityProjections, TableProjections, options);\n            })\n        } : { next: () => false } // TODO: How should this return?\n        ); // end parse assign\n    } // end parseBatchGetResponse\n    // Generate BatchGet Params\n    batchGetParams(_items, options = {}, params = {}, meta = false) {\n        let items = Array.isArray(_items) ? _items : [_items];\n        // Error on no items\n        if (items.length === 0)\n            utils_1.error(`No items supplied`);\n        const { capacity, consistent, attributes } = options, _args = __rest(options\n        // Remove other valid options from options\n        , [\"capacity\", \"consistent\", \"attributes\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid batchGet options: ${args.join(', ')}`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Init RequestItems and Tables reference\n        let RequestItems = {};\n        let Tables = {};\n        let TableAliases = {};\n        let EntityProjections = {};\n        let TableProjections = {};\n        // // Loop through items\n        for (const i in items) {\n            const item = items[i];\n            // Check item for Table reference and key\n            if (item\n                && item.Table\n                && item.Table.Table\n                && item.Key\n                && typeof item.Key === 'object'\n                && !Array.isArray(item.Key)) {\n                // Set the table\n                const table = item.Table.name;\n                // If it doesn't exist\n                if (!RequestItems[table]) {\n                    // Create a table property with an empty array\n                    RequestItems[table] = { Keys: [] };\n                    // Add the table/table alias reference\n                    Tables[table] = item.Table;\n                    if (item.Table.alias)\n                        TableAliases[item.Table.alias] = table;\n                }\n                // Push request onto the table array\n                RequestItems[table].Keys.push(item.Key);\n            }\n            else {\n                utils_1.error(`Item references must contain a valid Table object and Key`);\n            }\n        } // end item loop\n        // Parse 'consistent' option\n        if (consistent) {\n            // If true, add to all table mappings\n            if (consistent === true) {\n                for (const tbl in RequestItems)\n                    RequestItems[tbl].ConsistentRead = true;\n            }\n            else if (typeof consistent === 'object' && !Array.isArray(consistent)) {\n                for (const tbl in consistent) {\n                    const tbl_name = TableAliases[tbl] || tbl;\n                    if (RequestItems[tbl_name]) {\n                        if (typeof consistent[tbl] === 'boolean') {\n                            RequestItems[tbl_name].ConsistentRead = consistent[tbl];\n                        }\n                        else {\n                            utils_1.error(`'consistent' values must be booleans (${tbl})`);\n                        }\n                    }\n                    else {\n                        utils_1.error(`There are no items for the table or table alias: ${tbl}`);\n                    }\n                } // end if\n            }\n            else {\n                utils_1.error(`'consistent' must be a boolean or an map of table names`);\n            }\n        } // end consistent\n        // If projections\n        if (attributes) {\n            let attrs = attributes;\n            // If an Array, ensure single table and convert to standard format\n            if (Array.isArray(attributes)) {\n                if (Object.keys(RequestItems).length === 1) {\n                    attrs = { [Object.keys(RequestItems)[0]]: attributes };\n                }\n                else {\n                    utils_1.error(`'attributes' must use a table map when requesting items from multiple tables`);\n                }\n            } // end if array\n            for (const tbl in attrs) {\n                const tbl_name = TableAliases[tbl] || tbl;\n                if (Tables[tbl_name]) {\n                    const { names, projections, entities, tableAttrs } = projectionBuilder_1.default(attrs[tbl], Tables[tbl_name], null, true);\n                    RequestItems[tbl_name].ExpressionAttributeNames = names;\n                    RequestItems[tbl_name].ProjectionExpression = projections;\n                    EntityProjections[tbl_name] = entities;\n                    TableProjections[tbl_name] = tableAttrs;\n                }\n                else {\n                    utils_1.error(`There are no items for the table: ${tbl}`);\n                }\n            }\n        } // end if projections\n        const payload = Object.assign({ RequestItems }, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, typeof params === 'object' ? params : null);\n        return meta ? {\n            payload,\n            Tables,\n            EntityProjections,\n            TableProjections\n        } : payload;\n    } // batchGetParams\n    // BatchWrite Items\n    batchWrite(items, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload with meta information\n            const payload = this.batchWriteParams(items, options, params);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.batchWrite(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    // TODO: Left in for testing. Needs to be removed\n                    // result.UnprocessedKeys = testUnprocessedKeys\n                    return this.parseBatchWriteResponse(result, options);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end-if\n        });\n    } // end put\n    parseBatchWriteResponse(result, options = {}) {\n        return Object.assign(result, \n        // If UnprocessedItems, return a next function\n        result.UnprocessedItems && Object.keys(result.UnprocessedItems).length > 0 ? {\n            next: () => __awaiter(this, void 0, void 0, function* () {\n                const nextResult = yield this.DocumentClient.batchWrite(Object.assign({ RequestItems: result.UnprocessedItems }, options.capacity ? { ReturnConsumedCapacity: options.capacity.toUpperCase() } : null, options.metrics ? { ReturnItemCollectionMetrics: options.metrics.toUpperCase() } : null)).promise();\n                return this.parseBatchWriteResponse(nextResult, options);\n            })\n        } : { next: () => false } // TODO: How should this return?\n        ); // end parse assign\n    } // end parseBatchWriteResponse\n    /**\n     * Generates parameters for a batchWrite\n     * @param {object} items - An array of objects generated from putBatch and/or deleteBatch entity calls.\n     * @param {object} [options] - Additional batchWrite options\n     * @param {object} [params] - Additional DynamoDB parameters you wish to pass to the batchWrite request.\n     * @param {boolean} [meta] - Internal flag to enable entity parsing\n     *\n    */\n    batchWriteParams(_items, options = {}, params = {}, meta = false) {\n        // Convert items to array\n        let items = (Array.isArray(_items) ? _items : [_items]).filter(x => x);\n        // Error on no items\n        if (items.length === 0)\n            utils_1.error(`No items supplied`);\n        const { capacity, metrics } = options, _args = __rest(options\n        // Remove other valid options from options\n        , [\"capacity\", \"metrics\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid batchWrite options: ${args.join(', ')}`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify metrics\n        if (metrics !== undefined\n            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))\n            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n        // Init RequestItems\n        const RequestItems = {};\n        // Loop through items\n        for (const i in items) {\n            const item = items[i];\n            const table = Object.keys(item)[0];\n            // Create a table property with an empty array if it doesn't exist\n            if (!RequestItems[table])\n                RequestItems[table] = [];\n            // TODO: Add some validation here?\n            // Push request onto the table array\n            RequestItems[table].push(item[table]);\n        }\n        const payload = Object.assign({ RequestItems }, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, typeof params === 'object' ? params : null);\n        const Tables = {};\n        return meta ? { payload, Tables } : payload;\n    } // batchWriteParams\n    /**\n     * Performs a transactGet operation\n     * @param {object} items - An array of objects generated from getTransaction entity calls.\n     * @param {object} [options] - Additional transactGet options\n     *\n    */\n    transactGet(items = [], options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload with meta information\n            const { payload, Entities } = this.transactGetParams(items, options, true);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.transactGet(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    // Parse the items using the appropriate entity\n                    return Object.assign(result, result.Responses ? {\n                        Responses: result.Responses.map((res, i) => {\n                            if (res.Item) {\n                                return { Item: Entities[i].parse ? Entities[i].parse(res.Item) : res.Item };\n                            }\n                            else {\n                                return {};\n                            }\n                        })\n                    } : null);\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end-if\n        });\n    } // end transactGet\n    transactGetParams(_items, options = {}, meta = false) {\n        let items = Array.isArray(_items) ? _items : _items ? [_items] : [];\n        // Error on no items\n        if (items.length === 0)\n            utils_1.error(`No items supplied`);\n        // Extract valid options\n        const { capacity } = options, // ReturnConsumedCapacity (none, total, or indexes)\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"capacity\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid transactGet options: ${args.join(', ')}`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        let Entities = [];\n        // Generate the payload\n        const payload = Object.assign({\n            // Loop through items and verify transaction objects\n            TransactItems: items.map(item => {\n                let { Entity } = item, _item = __rest(item, [\"Entity\"]);\n                Entities.push(Entity);\n                if (!('Get' in _item) || Object.keys(_item).length > 1)\n                    utils_1.error(`Invalid transaction item. Use the 'getTransaction' method on an entity.`);\n                return _item;\n            })\n        }, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null);\n        // Return transact items\n        return (meta) ? { Entities, payload } : payload;\n    } // end transactGetParams\n    /**\n     * Performs a transactWrite operation\n     * @param {object} items - An array of objects generated from putTransaction, updateTransaction, or deleteTransaction entity calls.\n     * @param {object} [options] - Additional transactWrite options\n     *\n    */\n    transactWrite(items, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Generate the payload with meta information\n            const payload = this.transactWriteParams(items, options);\n            // If auto execute enabled\n            if (options.execute || (this.autoExecute && options.execute !== false)) {\n                const result = yield this.DocumentClient.transactWrite(payload).promise();\n                // If auto parse enable\n                if (options.parse || (this.autoParse && options.parse !== false)) {\n                    return result;\n                }\n                else {\n                    return result;\n                }\n            }\n            else {\n                return payload;\n            } // end-if\n        });\n    } // end transactGet\n    /**\n     * Generates parameters for a transactWrite operation\n     * @param {object} items - An array of objects generated from putTransaction, updateTransaction, or deleteTransaction entity calls.\n     * @param {object} [options] - Additional options\n     *\n     * Creates a TransactWriteItems object: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactWriteItems.html\n     */\n    transactWriteParams(_items, options = {}) {\n        let items = Array.isArray(_items) ? _items : _items ? [_items] : [];\n        // Error on no items\n        if (items.length === 0)\n            utils_1.error(`No items supplied`);\n        // Extract valid options\n        const { capacity, // ReturnConsumedCapacity (none, total, or indexes)\n        metrics, // ReturnItemCollectionMetrics (size or none)\n        token } = options, // ClientRequestToken (1-36 characters)\n        _args = __rest(options\n        // Remove other valid options from options\n        , [\"capacity\", \"metrics\", \"token\"]);\n        // Remove other valid options from options\n        const args = Object.keys(_args).filter(x => !['execute', 'parse'].includes(x));\n        // Error on extraneous arguments\n        if (args.length > 0)\n            utils_1.error(`Invalid transactWrite options: ${args.join(', ')}`);\n        // Verify capacity\n        if (capacity !== undefined\n            && (typeof capacity !== 'string' || !['NONE', 'TOTAL', 'INDEXES'].includes(capacity.toUpperCase())))\n            utils_1.error(`'capacity' must be one of 'NONE','TOTAL', OR 'INDEXES'`);\n        // Verify metrics\n        if (metrics !== undefined\n            && (typeof metrics !== 'string' || !['NONE', 'SIZE'].includes(metrics.toUpperCase())))\n            utils_1.error(`'metrics' must be one of 'NONE' OR 'SIZE'`);\n        // Verify token\n        if (token !== undefined\n            && (typeof token !== 'string' || token.trim().length === 0 || token.trim().length > 36))\n            utils_1.error(`'token' must be a string up to 36 characters long `);\n        // Generate the payload\n        const payload = Object.assign({\n            // Loop through items\n            TransactItems: items.map(item => {\n                if (( // Check for valid transaction object\n                !('ConditionCheck' in item)\n                    && !('Delete' in item)\n                    && !('Put' in item)\n                    && !('Update' in item))\n                    || Object.keys(item).length > 1)\n                    utils_1.error(`Invalid transaction item. Use the 'putTransaction', 'updateTransaction', 'deleteTransaction', or 'conditionCheck' methods on an entity.`);\n                return item;\n            })\n        }, capacity ? { ReturnConsumedCapacity: capacity.toUpperCase() } : null, metrics ? { ReturnItemCollectionMetrics: metrics.toUpperCase() } : null, token ? { ClientRequestToken: token.trim() } : null);\n        return payload;\n    } // end transactWriteParams\n    // Entity operation references\n    parse(entity, input, include = []) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this[entity])\n                utils_1.error(`'${entity}' is not a valid Entity`);\n            return this[entity].parse(input, include);\n        });\n    }\n    get(entity, item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this[entity])\n                utils_1.error(`'${entity}' is not a valid Entity`);\n            return this[entity].get(item, options, params);\n        });\n    }\n    delete(entity, item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this[entity])\n                utils_1.error(`'${entity}' is not a valid Entity`);\n            return this[entity].delete(item, options, params);\n        });\n    }\n    update(entity, item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this[entity])\n                utils_1.error(`'${entity}' is not a valid Entity`);\n            return this[entity].update(item, options, params);\n        });\n    }\n    put(entity, item = {}, options = {}, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this[entity])\n                utils_1.error(`'${entity}' is not a valid Entity`);\n            return this[entity].put(item, options, params);\n        });\n    }\n} // end Table class\n// Export the Table class\nexports.default = Table;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}