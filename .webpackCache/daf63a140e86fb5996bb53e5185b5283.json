{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchema = void 0;\nconst definitions_1 = require(\"./definitions\");\nconst graphql_1 = require(\"graphql\");\nconst values_1 = require(\"./values\");\nconst introspection_1 = require(\"./introspection\");\nconst types_1 = require(\"./types\");\nconst error_1 = require(\"./error\");\nfunction validateSchema(schema) {\n  return new Validator(schema).validate();\n}\nexports.validateSchema = validateSchema;\nclass InputObjectCircularRefsValidator {\n  constructor(onError) {\n    this.onError = onError;\n    this.visitedTypes = new Set();\n    this.fieldPath = [];\n    this.fieldPathIndexByTypeName = new Map();\n  }\n  detectCycles(type) {\n    if (this.visitedTypes.has(type.name)) {\n      return;\n    }\n    this.visitedTypes.add(type.name);\n    this.fieldPathIndexByTypeName.set(type.name, this.fieldPath.length);\n    for (const field of type.fields()) {\n      if ((0, definitions_1.isNonNullType)(field.type) && (0, definitions_1.isInputObjectType)(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = this.fieldPathIndexByTypeName.get(fieldType.name);\n        this.fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          this.detectCycles(fieldType);\n        } else {\n          const cyclePath = this.fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map(fieldObj => fieldObj.name).join('.');\n          this.onError(`Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`, {\n            nodes: (0, definitions_1.sourceASTs)(...cyclePath)\n          });\n        }\n        this.fieldPath.pop();\n      }\n    }\n    this.fieldPathIndexByTypeName.delete(type.name);\n  }\n}\nclass Validator {\n  constructor(schema) {\n    this.schema = schema;\n    this.emptyVariables = new definitions_1.VariableDefinitions();\n    this.hasMissingTypes = false;\n    this.errors = [];\n  }\n  validate() {\n    for (const type of this.schema.types()) {\n      if (!introspection_1.introspectionTypeNames.includes(type.name)) {\n        this.validateName(type);\n      }\n      switch (type.kind) {\n        case 'ObjectType':\n        case 'InterfaceType':\n          this.validateObjectOrInterfaceType(type);\n          break;\n        case 'InputObjectType':\n          this.validateInputObjectType(type);\n          break;\n        case 'UnionType':\n          this.validateUnionType(type);\n          break;\n        case 'EnumType':\n          this.validateEnumType(type);\n          break;\n      }\n    }\n    for (const directive of this.schema.allDirectives()) {\n      this.validateName(directive);\n      for (const arg of directive.arguments()) {\n        this.validateArg(arg);\n      }\n      for (const application of directive.applications()) {\n        this.validateDirectiveApplication(directive, application);\n      }\n    }\n    if (!this.hasMissingTypes) {\n      const refsValidator = new InputObjectCircularRefsValidator((msg, opts) => this.addError(msg, opts));\n      for (const type of this.schema.types()) {\n        switch (type.kind) {\n          case 'ObjectType':\n          case 'InterfaceType':\n            this.validateImplementedInterfaces(type);\n            break;\n          case 'InputObjectType':\n            refsValidator.detectCycles(type);\n            break;\n        }\n      }\n    }\n    return this.errors;\n  }\n  addError(message, options) {\n    this.errors.push(error_1.ERRORS.INVALID_GRAPHQL.err(message, options));\n  }\n  validateHasType(elt) {\n    if (!elt.type) {\n      this.addError(`Element ${elt.coordinate} does not have a type set`, {\n        nodes: elt.sourceAST\n      });\n      this.hasMissingTypes = false;\n    }\n    return !!elt.type;\n  }\n  validateName(elt) {\n    if ((0, introspection_1.isIntrospectionName)(elt.name)) {\n      this.addError(`Name \"${elt.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`, elt.sourceAST ? {\n        nodes: elt.sourceAST\n      } : {});\n      return;\n    }\n    try {\n      (0, graphql_1.assertName)(elt.name);\n    } catch (e) {\n      this.addError(e.message, elt.sourceAST ? {\n        nodes: elt.sourceAST\n      } : {});\n    }\n  }\n  validateObjectOrInterfaceType(type) {\n    if (!type.hasFields()) {\n      this.addError(`Type ${type.name} must define one or more fields.`, {\n        nodes: type.sourceAST\n      });\n    }\n    for (const field of type.fields()) {\n      this.validateName(field);\n      this.validateHasType(field);\n      for (const arg of field.arguments()) {\n        this.validateArg(arg);\n      }\n    }\n  }\n  validateImplementedInterfaces(type) {\n    if (type.implementsInterface(type.name)) {\n      this.addError(`Type ${type} cannot implement itself because it would create a circular reference.`, {\n        nodes: (0, definitions_1.sourceASTs)(type, type.interfaceImplementation(type.name))\n      });\n    }\n    for (const itf of type.interfaces()) {\n      for (const itfField of itf.fields()) {\n        const field = type.field(itfField.name);\n        if (!field) {\n          this.addError(`Interface field ${itfField.coordinate} expected but ${type} does not provide it.`, {\n            nodes: (0, definitions_1.sourceASTs)(itfField, type)\n          });\n          continue;\n        }\n        if (this.validateHasType(itfField) && !(0, types_1.isSubtype)(itfField.type, field.type)) {\n          this.addError(`Interface field ${itfField.coordinate} expects type ${itfField.type} but ${field.coordinate} of type ${field.type} is not a proper subtype.`, {\n            nodes: (0, definitions_1.sourceASTs)(itfField, field)\n          });\n        }\n        for (const itfArg of itfField.arguments()) {\n          const arg = field.argument(itfArg.name);\n          if (!arg) {\n            this.addError(`Interface field argument ${itfArg.coordinate} expected but ${field.coordinate} does not provide it.`, {\n              nodes: (0, definitions_1.sourceASTs)(itfArg, field)\n            });\n            continue;\n          }\n          if (this.validateHasType(itfArg) && !(0, types_1.sameType)(itfArg.type, arg.type)) {\n            this.addError(`Interface field argument ${itfArg.coordinate} expects type ${itfArg.type} but ${arg.coordinate} is type ${arg.type}.`, {\n              nodes: (0, definitions_1.sourceASTs)(itfArg, arg)\n            });\n          }\n        }\n        for (const arg of field.arguments()) {\n          if (itfField.argument(arg.name)) {\n            continue;\n          }\n          if (arg.isRequired()) {\n            this.addError(`Field ${field.coordinate} includes required argument ${arg.name} that is missing from the Interface field ${itfField.coordinate}.`, {\n              nodes: (0, definitions_1.sourceASTs)(arg, itfField)\n            });\n          }\n        }\n      }\n      for (const itfOfItf of itf.interfaces()) {\n        if (!type.implementsInterface(itfOfItf)) {\n          if (itfOfItf === type) {\n            this.addError(`Type ${type} cannot implement ${itf} because it would create a circular reference.`, {\n              nodes: (0, definitions_1.sourceASTs)(type, itf)\n            });\n          } else {\n            this.addError(`Type ${type} must implement ${itfOfItf} because it is implemented by ${itf}.`, {\n              nodes: (0, definitions_1.sourceASTs)(type, itf, itfOfItf)\n            });\n          }\n        }\n      }\n    }\n  }\n  validateInputObjectType(type) {\n    if (!type.hasFields()) {\n      this.addError(`Input Object type ${type.name} must define one or more fields.`, {\n        nodes: type.sourceAST\n      });\n    }\n    for (const field of type.fields()) {\n      this.validateName(field);\n      if (!this.validateHasType(field)) {\n        continue;\n      }\n      if (field.isRequired() && field.isDeprecated()) {\n        this.addError(`Required input field ${field.coordinate} cannot be deprecated.`, {\n          nodes: (0, definitions_1.sourceASTs)(field.appliedDirectivesOf('deprecated')[0], field)\n        });\n      }\n      if (field.defaultValue !== undefined && !(0, values_1.isValidValue)(field.defaultValue, field, new definitions_1.VariableDefinitions())) {\n        this.addError(`Invalid default value (got: ${(0, values_1.valueToString)(field.defaultValue)}) provided for input field ${field.coordinate} of type ${field.type}.`, {\n          nodes: (0, definitions_1.sourceASTs)(field)\n        });\n      }\n    }\n  }\n  validateArg(arg) {\n    this.validateName(arg);\n    if (!this.validateHasType(arg)) {\n      return;\n    }\n    if (arg.isRequired() && arg.isDeprecated()) {\n      this.addError(`Required argument ${arg.coordinate} cannot be deprecated.`, {\n        nodes: (0, definitions_1.sourceASTs)(arg.appliedDirectivesOf('deprecated')[0], arg)\n      });\n    }\n    if (arg.defaultValue !== undefined && !(0, values_1.isValidValue)(arg.defaultValue, arg, new definitions_1.VariableDefinitions())) {\n      this.addError(`Invalid default value (got: ${(0, values_1.valueToString)(arg.defaultValue)}) provided for argument ${arg.coordinate} of type ${arg.type}.`, {\n        nodes: (0, definitions_1.sourceASTs)(arg)\n      });\n    }\n  }\n  validateUnionType(type) {\n    if (type.membersCount() === 0) {\n      this.addError(`Union type ${type.coordinate} must define one or more member types.`, {\n        nodes: type.sourceAST\n      });\n    }\n  }\n  validateEnumType(type) {\n    if (type.values.length === 0) {\n      this.addError(`Enum type ${type.coordinate} must define one or more values.`, {\n        nodes: type.sourceAST\n      });\n    }\n    for (const value of type.values) {\n      this.validateName(value);\n      if (value.name === 'true' || value.name === 'false' || value.name === 'null') {\n        this.addError(`Enum type ${type.coordinate} cannot include value: ${value}.`, {\n          nodes: value.sourceAST\n        });\n      }\n    }\n  }\n  validateDirectiveApplication(definition, application) {\n    for (const argument of definition.arguments()) {\n      const value = application.arguments()[argument.name];\n      if (!value) {\n        continue;\n      }\n      if (argument.type && !(0, values_1.isValidValue)(value, argument, this.emptyVariables)) {\n        const parent = application.parent;\n        const parentDesc = parent instanceof definitions_1.NamedSchemaElement ? parent.coordinate : 'schema';\n        this.addError(`Invalid value for \"${argument.coordinate}\" of type \"${argument.type}\" in application of \"${definition.coordinate}\" to \"${parentDesc}\".`, {\n          nodes: (0, definitions_1.sourceASTs)(application, argument)\n        });\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["definitions_1","require","graphql_1","values_1","introspection_1","types_1","error_1","validateSchema","schema","Validator","validate","exports","InputObjectCircularRefsValidator","constructor","onError","visitedTypes","Set","fieldPath","fieldPathIndexByTypeName","Map","detectCycles","type","has","name","add","set","length","field","fields","isNonNullType","isInputObjectType","ofType","fieldType","cycleIndex","get","push","undefined","cyclePath","slice","pathStr","map","fieldObj","join","nodes","sourceASTs","pop","delete","emptyVariables","VariableDefinitions","hasMissingTypes","errors","types","introspectionTypeNames","includes","validateName","kind","validateObjectOrInterfaceType","validateInputObjectType","validateUnionType","validateEnumType","directive","allDirectives","arg","arguments","validateArg","application","applications","validateDirectiveApplication","refsValidator","msg","opts","addError","validateImplementedInterfaces","message","options","ERRORS","INVALID_GRAPHQL","err","validateHasType","elt","coordinate","sourceAST","isIntrospectionName","assertName","e","hasFields","implementsInterface","interfaceImplementation","itf","interfaces","itfField","isSubtype","itfArg","argument","sameType","isRequired","itfOfItf","isDeprecated","appliedDirectivesOf","defaultValue","isValidValue","valueToString","membersCount","values","value","definition","parent","parentDesc","NamedSchemaElement"],"sourceRoot":"","sources":["../src/validate.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}