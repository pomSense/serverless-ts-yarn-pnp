{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.builtTypeReference = exports.buildSchemaFromAST = exports.buildSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst values_1 = require(\"./values\");\nconst definitions_1 = require(\"./definitions\");\nconst error_1 = require(\"./error\");\nconst introspection_1 = require(\"./introspection\");\nfunction buildValue(value) {\n  return value ? (0, values_1.valueFromASTUntyped)(value) : undefined;\n}\nfunction buildSchema(source, options) {\n  return buildSchemaFromAST((0, graphql_1.parse)(source), options);\n}\nexports.buildSchema = buildSchema;\nfunction buildSchemaFromAST(documentNode, options) {\n  var _a;\n  const errors = [];\n  const schema = new definitions_1.Schema(options === null || options === void 0 ? void 0 : options.blueprint);\n  const {\n    directiveDefinitions,\n    typeDefinitions,\n    typeExtensions,\n    schemaDefinitions,\n    schemaExtensions\n  } = buildNamedTypeAndDirectivesShallow(documentNode, schema, errors);\n  for (const typeNode of typeDefinitions) {\n    if (typeNode.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION) {\n      buildEnumTypeValuesWithoutDirectiveApplications(typeNode, schema.type(typeNode.name.value));\n    }\n  }\n  for (const typeExtensionNode of typeExtensions) {\n    if (typeExtensionNode.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n      const toExtend = schema.type(typeExtensionNode.name.value);\n      const extension = toExtend.newExtension();\n      extension.sourceAST = typeExtensionNode;\n      buildEnumTypeValuesWithoutDirectiveApplications(typeExtensionNode, schema.type(typeExtensionNode.name.value), extension);\n    }\n  }\n  for (const directiveDefinitionNode of directiveDefinitions) {\n    buildDirectiveDefinitionInnerWithoutDirectiveApplications(directiveDefinitionNode, schema.directive(directiveDefinitionNode.name.value), errors);\n  }\n  for (const schemaDefinition of schemaDefinitions) {\n    buildSchemaDefinitionInner(schemaDefinition, schema.schemaDefinition, errors);\n  }\n  for (const schemaExtension of schemaExtensions) {\n    buildSchemaDefinitionInner(schemaExtension, schema.schemaDefinition, errors, schema.schemaDefinition.newExtension());\n  }\n  errors.push(...schema.blueprint.onDirectiveDefinitionAndSchemaParsed(schema));\n  for (const directiveDefinitionNode of directiveDefinitions) {\n    buildDirectiveApplicationsInDirectiveDefinition(directiveDefinitionNode, schema.directive(directiveDefinitionNode.name.value), errors);\n  }\n  for (const typeNode of typeDefinitions) {\n    buildNamedTypeInner(typeNode, schema.type(typeNode.name.value), schema.blueprint, errors);\n  }\n  for (const typeExtensionNode of typeExtensions) {\n    const toExtend = schema.type(typeExtensionNode.name.value);\n    const extension = toExtend.newExtension();\n    extension.sourceAST = typeExtensionNode;\n    buildNamedTypeInner(typeExtensionNode, toExtend, schema.blueprint, errors, extension);\n  }\n  if (errors.length > 0) {\n    throw (0, definitions_1.ErrGraphQLValidationFailed)(errors);\n  }\n  if ((_a = options === null || options === void 0 ? void 0 : options.validate) !== null && _a !== void 0 ? _a : true) {\n    schema.validate();\n  }\n  return schema;\n}\nexports.buildSchemaFromAST = buildSchemaFromAST;\nfunction buildNamedTypeAndDirectivesShallow(documentNode, schema, errors) {\n  const directiveDefinitions = [];\n  const typeDefinitions = [];\n  const typeExtensions = [];\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  for (const definitionNode of documentNode.definitions) {\n    switch (definitionNode.kind) {\n      case 'OperationDefinition':\n      case 'FragmentDefinition':\n        errors.push(error_1.ERRORS.INVALID_GRAPHQL.err(\"Invalid executable definition found while building schema\", {\n          nodes: definitionNode\n        }));\n        continue;\n      case 'SchemaDefinition':\n        schemaDefinitions.push(definitionNode);\n        schema.schemaDefinition.preserveEmptyDefinition = true;\n        break;\n      case 'SchemaExtension':\n        schemaExtensions.push(definitionNode);\n        break;\n      case 'ScalarTypeDefinition':\n      case 'ObjectTypeDefinition':\n      case 'InterfaceTypeDefinition':\n      case 'UnionTypeDefinition':\n      case 'EnumTypeDefinition':\n      case 'InputObjectTypeDefinition':\n        if (introspection_1.introspectionTypeNames.includes(definitionNode.name.value)) {\n          continue;\n        }\n        typeDefinitions.push(definitionNode);\n        let type = schema.type(definitionNode.name.value);\n        if (!type || type.isBuiltIn) {\n          type = schema.addType((0, definitions_1.newNamedType)(withoutTrailingDefinition(definitionNode.kind), definitionNode.name.value));\n        } else if (type.preserveEmptyDefinition) {\n          throw error_1.ERRORS.INVALID_GRAPHQL.err(`There can be only one type named \"${definitionNode.name.value}\"`);\n        }\n        type.preserveEmptyDefinition = true;\n        break;\n      case 'ScalarTypeExtension':\n      case 'ObjectTypeExtension':\n      case 'InterfaceTypeExtension':\n      case 'UnionTypeExtension':\n      case 'EnumTypeExtension':\n      case 'InputObjectTypeExtension':\n        if (introspection_1.introspectionTypeNames.includes(definitionNode.name.value)) {\n          continue;\n        }\n        typeExtensions.push(definitionNode);\n        const existing = schema.type(definitionNode.name.value);\n        if (!existing) {\n          schema.addType((0, definitions_1.newNamedType)(withoutTrailingDefinition(definitionNode.kind), definitionNode.name.value));\n        } else if (existing.isBuiltIn) {\n          throw error_1.ERRORS.INVALID_GRAPHQL.err(`Cannot extend built-in type \"${definitionNode.name.value}\"`);\n        }\n        break;\n      case 'DirectiveDefinition':\n        directiveDefinitions.push(definitionNode);\n        schema.addDirectiveDefinition(definitionNode.name.value);\n        break;\n    }\n  }\n  return {\n    directiveDefinitions,\n    typeDefinitions,\n    typeExtensions,\n    schemaDefinitions,\n    schemaExtensions\n  };\n}\nfunction withoutTrailingDefinition(str) {\n  const endString = str.endsWith('Definition') ? 'Definition' : 'Extension';\n  return str.slice(0, str.length - endString.length);\n}\nfunction getReferencedType(node, schema) {\n  const type = schema.type(node.name.value);\n  if (!type) {\n    throw error_1.ERRORS.INVALID_GRAPHQL.err(`Unknown type ${node.name.value}`, {\n      nodes: node\n    });\n  }\n  return type;\n}\nfunction withNodeAttachedToError(operation, node, errors) {\n  try {\n    operation();\n  } catch (e) {\n    const causes = (0, error_1.errorCauses)(e);\n    if (causes) {\n      for (const cause of causes) {\n        const allNodes = cause.nodes ? [node, ...cause.nodes] : node;\n        errors.push((0, error_1.withModifiedErrorNodes)(cause, allNodes));\n      }\n    } else {\n      throw e;\n    }\n  }\n}\nfunction buildSchemaDefinitionInner(schemaNode, schemaDefinition, errors, extension) {\n  var _a, _b;\n  for (const opTypeNode of (_a = schemaNode.operationTypes) !== null && _a !== void 0 ? _a : []) {\n    withNodeAttachedToError(() => schemaDefinition.setRoot(opTypeNode.operation, opTypeNode.type.name.value).setOfExtension(extension), opTypeNode, errors);\n  }\n  schemaDefinition.sourceAST = schemaNode;\n  if ('description' in schemaNode) {\n    schemaDefinition.description = (_b = schemaNode.description) === null || _b === void 0 ? void 0 : _b.value;\n  }\n  buildAppliedDirectives(schemaNode, schemaDefinition, errors, extension);\n}\nfunction buildAppliedDirectives(elementNode, element, errors, extension) {\n  var _a;\n  for (const directive of (_a = elementNode.directives) !== null && _a !== void 0 ? _a : []) {\n    withNodeAttachedToError(() => {\n      if (element !== element.schema().schemaDefinition || directive.name.value === 'link' || !element.schema().blueprint.applyDirectivesAfterParsing()) {\n        const d = element.applyDirective(directive.name.value, buildArgs(directive));\n        d.setOfExtension(extension);\n        d.sourceAST = directive;\n      } else {\n        element.addUnappliedDirective({\n          extension,\n          directive,\n          args: buildArgs(directive),\n          nameOrDef: directive.name.value\n        });\n      }\n    }, directive, errors);\n  }\n}\nfunction buildArgs(argumentsNode) {\n  var _a;\n  const args = Object.create(null);\n  for (const argNode of (_a = argumentsNode.arguments) !== null && _a !== void 0 ? _a : []) {\n    args[argNode.name.value] = buildValue(argNode.value);\n  }\n  return args;\n}\nfunction buildNamedTypeInner(definitionNode, type, blueprint, errors, extension) {\n  var _a, _b, _c, _d, _e;\n  switch (definitionNode.kind) {\n    case 'EnumTypeDefinition':\n    case 'EnumTypeExtension':\n      const enumType = type;\n      for (const enumVal of (_a = definitionNode.values) !== null && _a !== void 0 ? _a : []) {\n        buildAppliedDirectives(enumVal, enumType.value(enumVal.name.value), errors);\n      }\n      break;\n    case 'ObjectTypeDefinition':\n    case 'ObjectTypeExtension':\n    case 'InterfaceTypeDefinition':\n    case 'InterfaceTypeExtension':\n      const fieldBasedType = type;\n      for (const fieldNode of (_b = definitionNode.fields) !== null && _b !== void 0 ? _b : []) {\n        if (blueprint.ignoreParsedField(type, fieldNode.name.value)) {\n          continue;\n        }\n        const field = fieldBasedType.addField(fieldNode.name.value);\n        field.setOfExtension(extension);\n        buildFieldDefinitionInner(fieldNode, field, errors);\n      }\n      for (const itfNode of (_c = definitionNode.interfaces) !== null && _c !== void 0 ? _c : []) {\n        withNodeAttachedToError(() => {\n          const itfName = itfNode.name.value;\n          if (fieldBasedType.implementsInterface(itfName)) {\n            throw error_1.ERRORS.INVALID_GRAPHQL.err(`Type \"${type}\" can only implement \"${itfName}\" once.`);\n          }\n          fieldBasedType.addImplementedInterface(itfName).setOfExtension(extension);\n        }, itfNode, errors);\n      }\n      break;\n    case 'UnionTypeDefinition':\n    case 'UnionTypeExtension':\n      const unionType = type;\n      for (const namedType of (_d = definitionNode.types) !== null && _d !== void 0 ? _d : []) {\n        withNodeAttachedToError(() => {\n          const name = namedType.name.value;\n          if (unionType.hasTypeMember(name)) {\n            throw error_1.ERRORS.INVALID_GRAPHQL.err(`Union type \"${unionType}\" can only include type \"${name}\" once.`);\n          }\n          unionType.addType(name).setOfExtension(extension);\n        }, namedType, errors);\n      }\n      break;\n    case 'InputObjectTypeDefinition':\n    case 'InputObjectTypeExtension':\n      const inputObjectType = type;\n      for (const fieldNode of (_e = definitionNode.fields) !== null && _e !== void 0 ? _e : []) {\n        const field = inputObjectType.addField(fieldNode.name.value);\n        field.setOfExtension(extension);\n        buildInputFieldDefinitionInner(fieldNode, field, errors);\n      }\n      break;\n  }\n  buildAppliedDirectives(definitionNode, type, errors, extension);\n  buildDescriptionAndSourceAST(definitionNode, type);\n}\nfunction buildEnumTypeValuesWithoutDirectiveApplications(definitionNode, type, extension) {\n  var _a;\n  const enumType = type;\n  for (const enumVal of (_a = definitionNode.values) !== null && _a !== void 0 ? _a : []) {\n    const v = enumType.addValue(enumVal.name.value);\n    if (enumVal.description) {\n      v.description = enumVal.description.value;\n    }\n    v.setOfExtension(extension);\n  }\n  buildDescriptionAndSourceAST(definitionNode, type);\n}\nfunction buildDescriptionAndSourceAST(definitionNode, dest) {\n  if (definitionNode.description) {\n    dest.description = definitionNode.description.value;\n  }\n  dest.sourceAST = definitionNode;\n}\nfunction buildFieldDefinitionInner(fieldNode, field, errors) {\n  var _a, _b;\n  const type = buildTypeReferenceFromAST(fieldNode.type, field.schema());\n  field.type = validateOutputType(type, field.coordinate, fieldNode, errors);\n  for (const inputValueDef of (_a = fieldNode.arguments) !== null && _a !== void 0 ? _a : []) {\n    buildArgumentDefinitionInner(inputValueDef, field.addArgument(inputValueDef.name.value), errors, true);\n  }\n  buildAppliedDirectives(fieldNode, field, errors);\n  field.description = (_b = fieldNode.description) === null || _b === void 0 ? void 0 : _b.value;\n  field.sourceAST = fieldNode;\n}\nfunction validateOutputType(type, what, node, errors) {\n  if ((0, definitions_1.isOutputType)(type)) {\n    return type;\n  } else {\n    errors.push(error_1.ERRORS.INVALID_GRAPHQL.err(`The type of \"${what}\" must be Output Type but got \"${type}\", a ${type.kind}.`, {\n      nodes: node\n    }));\n    return undefined;\n  }\n}\nfunction validateInputType(type, what, node, errors) {\n  if ((0, definitions_1.isInputType)(type)) {\n    return type;\n  } else {\n    errors.push(error_1.ERRORS.INVALID_GRAPHQL.err(`The type of \"${what}\" must be Input Type but got \"${type}\", a ${type.kind}.`, {\n      nodes: node\n    }));\n    return undefined;\n  }\n}\nfunction builtTypeReference(encodedType, schema) {\n  return buildTypeReferenceFromAST((0, graphql_1.parseType)(encodedType), schema);\n}\nexports.builtTypeReference = builtTypeReference;\nfunction buildTypeReferenceFromAST(typeNode, schema) {\n  switch (typeNode.kind) {\n    case graphql_1.Kind.LIST_TYPE:\n      return new definitions_1.ListType(buildTypeReferenceFromAST(typeNode.type, schema));\n    case graphql_1.Kind.NON_NULL_TYPE:\n      const wrapped = buildTypeReferenceFromAST(typeNode.type, schema);\n      if (wrapped.kind == graphql_1.Kind.NON_NULL_TYPE) {\n        throw error_1.ERRORS.INVALID_GRAPHQL.err(`Cannot apply the non-null operator (!) twice to the same type`, {\n          nodes: typeNode\n        });\n      }\n      return new definitions_1.NonNullType(wrapped);\n    default:\n      return getReferencedType(typeNode, schema);\n  }\n}\nfunction buildArgumentDefinitionInner(inputNode, arg, errors, includeDirectiveApplication) {\n  var _a;\n  const type = buildTypeReferenceFromAST(inputNode.type, arg.schema());\n  arg.type = validateInputType(type, arg.coordinate, inputNode, errors);\n  arg.defaultValue = buildValue(inputNode.defaultValue);\n  if (includeDirectiveApplication) {\n    buildAppliedDirectives(inputNode, arg, errors);\n  }\n  arg.description = (_a = inputNode.description) === null || _a === void 0 ? void 0 : _a.value;\n  arg.sourceAST = inputNode;\n}\nfunction buildInputFieldDefinitionInner(fieldNode, field, errors) {\n  var _a;\n  const type = buildTypeReferenceFromAST(fieldNode.type, field.schema());\n  field.type = validateInputType(type, field.coordinate, fieldNode, errors);\n  field.defaultValue = buildValue(fieldNode.defaultValue);\n  buildAppliedDirectives(fieldNode, field, errors);\n  field.description = (_a = fieldNode.description) === null || _a === void 0 ? void 0 : _a.value;\n  field.sourceAST = fieldNode;\n}\nfunction buildDirectiveDefinitionInnerWithoutDirectiveApplications(directiveNode, directive, errors) {\n  var _a;\n  for (const inputValueDef of (_a = directiveNode.arguments) !== null && _a !== void 0 ? _a : []) {\n    buildArgumentDefinitionInner(inputValueDef, directive.addArgument(inputValueDef.name.value), errors, false);\n  }\n  directive.repeatable = directiveNode.repeatable;\n  const locations = directiveNode.locations.map(({\n    value\n  }) => value);\n  directive.addLocations(...locations);\n  buildDescriptionAndSourceAST(directiveNode, directive);\n}\nfunction buildDirectiveApplicationsInDirectiveDefinition(directiveNode, directive, errors) {\n  var _a;\n  for (const inputValueDef of (_a = directiveNode.arguments) !== null && _a !== void 0 ? _a : []) {\n    buildAppliedDirectives(inputValueDef, directive.argument(inputValueDef.name.value), errors);\n  }\n}","map":{"version":3,"mappings":"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","names":["graphql_1","require","values_1","definitions_1","error_1","introspection_1","buildValue","value","valueFromASTUntyped","undefined","buildSchema","source","options","buildSchemaFromAST","parse","exports","documentNode","errors","schema","Schema","blueprint","directiveDefinitions","typeDefinitions","typeExtensions","schemaDefinitions","schemaExtensions","buildNamedTypeAndDirectivesShallow","typeNode","kind","Kind","ENUM_TYPE_DEFINITION","buildEnumTypeValuesWithoutDirectiveApplications","type","name","typeExtensionNode","ENUM_TYPE_EXTENSION","toExtend","extension","newExtension","sourceAST","directiveDefinitionNode","buildDirectiveDefinitionInnerWithoutDirectiveApplications","directive","schemaDefinition","buildSchemaDefinitionInner","schemaExtension","push","onDirectiveDefinitionAndSchemaParsed","buildDirectiveApplicationsInDirectiveDefinition","buildNamedTypeInner","length","ErrGraphQLValidationFailed","_a","validate","definitionNode","definitions","ERRORS","INVALID_GRAPHQL","err","nodes","preserveEmptyDefinition","introspectionTypeNames","includes","isBuiltIn","addType","newNamedType","withoutTrailingDefinition","existing","addDirectiveDefinition","str","endString","endsWith","slice","getReferencedType","node","withNodeAttachedToError","operation","e","causes","errorCauses","cause","allNodes","withModifiedErrorNodes","schemaNode","opTypeNode","operationTypes","setRoot","setOfExtension","description","_b","buildAppliedDirectives","elementNode","element","directives","applyDirectivesAfterParsing","d","applyDirective","buildArgs","addUnappliedDirective","args","nameOrDef","argumentsNode","Object","create","argNode","arguments","enumType","enumVal","values","fieldBasedType","fieldNode","fields","ignoreParsedField","field","addField","buildFieldDefinitionInner","itfNode","_c","interfaces","itfName","implementsInterface","addImplementedInterface","unionType","namedType","_d","types","hasTypeMember","inputObjectType","_e","buildInputFieldDefinitionInner","buildDescriptionAndSourceAST","v","addValue","dest","buildTypeReferenceFromAST","validateOutputType","coordinate","inputValueDef","buildArgumentDefinitionInner","addArgument","what","isOutputType","validateInputType","isInputType","builtTypeReference","encodedType","parseType","LIST_TYPE","ListType","NON_NULL_TYPE","wrapped","NonNullType","inputNode","arg","includeDirectiveApplication","defaultValue","directiveNode","repeatable","locations","map","addLocations","argument"],"sourceRoot":"","sources":["../src/buildSchema.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}