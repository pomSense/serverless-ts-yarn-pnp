{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"./utils\");\n// Parse and validate mapping config\nexports.default = (field, config, track) => {\n  // Validate props\n  Object.keys(config).forEach(prop => {\n    switch (prop) {\n      case 'type':\n      case 'default':\n        break;\n      case 'dependsOn':\n        if (typeof config[prop] !== 'string' && !Array.isArray(config[prop])) utils_1.error(`'dependsOn' must be the string name of an attribute or alias`);\n        break;\n      case 'transform':\n        if (typeof config[prop] !== 'function') utils_1.error(`'${prop}' must be a function`);\n        break;\n      case 'coerce':\n      case 'onUpdate':\n      case 'hidden':\n      case 'save':\n        if (typeof config[prop] !== 'boolean') utils_1.error(`'${prop}' must be a boolean`);\n        break;\n      case 'required':\n        if (typeof config[prop] !== 'boolean' && config[prop] !== 'always') utils_1.error(`'required' must be a boolean or set to 'always'`);\n        break;\n      case 'alias':\n      case 'map':\n        if (typeof config[prop] !== 'string' || track.fields.includes((config[prop] || '').trim()) || (config[prop] || '').trim().length === 0) utils_1.error(`'${prop}' must be a unique string`);\n        break;\n      case 'setType':\n        if (config.type !== 'set') utils_1.error(`'setType' is only valid for type 'set'`);\n        if (!['string', 'number', 'binary'].includes(config[prop] || '')) utils_1.error(`Invalid 'setType', must be 'string', 'number', or 'binary'`);\n        break;\n      case 'delimiter':\n        if (typeof config[prop] !== 'string' || (config[prop] || '').trim().length === 0) utils_1.error(`'delimiter' must be a 'string'`);\n        config[prop] = (config[prop] || '').trim();\n        break;\n      case 'prefix':\n      case 'suffix':\n        if (config.type && config.type !== 'string') utils_1.error(`'${prop}' can only be used on 'string' types`);\n        if (typeof config[prop] !== 'string' || (config[prop] || '').trim().length === 0) utils_1.error(`'${prop}' must be a 'string'`);\n        break;\n      case 'partitionKey':\n      case 'sortKey':\n        if (config.map || config.alias) utils_1.error(`Attributes with a ${prop} cannot have a 'map' or 'alias' associated`);\n        if (typeof config[prop] === 'boolean' || typeof config[prop] === 'string' || Array.isArray(config[prop])) {\n          // Coerce/cast to an array of strings/booleans\n          const indexes = Array.isArray(config[prop]) ? config[prop] : [config[prop]];\n          // Loop through values and track keys\n          for (let i in indexes) {\n            // If a boolean, set primary pk/sk\n            if (typeof indexes[i] === 'boolean') {\n              // Check that another prop isn't already a key\n              if (track.keys[prop]) utils_1.error(`'${track.keys[prop]}' has already been declared as the ${prop}`);\n              // If true, add the field as the key\n              if (indexes[i]) track.keys[prop] = field;\n              // If the partionKey is the same as the sortKey, throw an error\n              if (track.keys.partitionKey && track.keys.partitionKey === track.keys.sortKey) utils_1.error(`'${field}' attribute cannot be both the partitionKey and sortKey`);\n              // If string, set index pk/sk\n            } else if (typeof indexes[i] === 'string') {\n              const index = indexes[i];\n              // If the index isn't being tracked yet, add it\n              if (!track.keys[index]) track.keys[index] = {};\n              // If the index's pk/sk already exist\n              if (track.keys[index][prop]) {\n                utils_1.error(`'${track.keys[index][prop]}' has already been declared as the ${prop} for the ${index} index`);\n              }\n              track.keys[index][prop] = field;\n              if (track.keys[index].partitionKey === track.keys[index].sortKey) utils_1.error(`'${field}' attribute cannot be both the partitionKey and sortKey for the ${index} index`);\n            } else {\n              utils_1.error(`Index assignments for '${field}' must be string or boolean values`);\n            }\n          } // end for\n        } else {\n          utils_1.error(`'${prop}' must be a boolean, string, or array`);\n        }\n        break;\n      default:\n        utils_1.error(`'${prop}' is not a valid property type`);\n    }\n  });\n  // Error on alias and map\n  if (config.alias && config.map) utils_1.error(`'${field}' cannot contain both an alias and a map`);\n  // Default the type\n  if (!config.type) config.type = 'string';\n  // Default coerce based on type\n  if (['string', 'boolean', 'number'].includes(config.type) && typeof config.coerce === 'undefined') config.coerce = true;\n  // Set defaults\n  if (config.default !== undefined) track.defaults[field] = config.default;\n  // Track required settings\n  if (config.required === true) track.required[config.map || field] = false;\n  if (config.required === 'always') track.required[config.map || field] = true;\n  // Destructure the config to pull out map and alias\n  const {\n      map,\n      alias\n    } = config,\n    _config = __rest(config\n    // Return the original config\n    , [\"map\", \"alias\"]);\n  // Return the original config\n  return Object.assign({\n    [field]: config\n  }, alias ? {\n    [alias]: Object.assign({}, _config, {\n      map: field\n    })\n  } : {}, map ? {\n    [map]: Object.assign({}, _config, {\n      alias: field\n    })\n  } : {}); // end assign\n};","map":{"version":3,"names":["__rest","undefined","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","defineProperty","exports","value","utils_1","require","default","field","config","track","keys","forEach","prop","Array","isArray","error","fields","includes","trim","type","map","alias","indexes","partitionKey","sortKey","index","coerce","defaults","required","_config","assign"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/parseMapping.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// Parse and validate mapping config\nexports.default = (field, config, track) => {\n    // Validate props\n    Object.keys(config).forEach(prop => {\n        switch (prop) {\n            case 'type':\n            case 'default':\n                break;\n            case 'dependsOn':\n                if (typeof config[prop] !== 'string' && !Array.isArray(config[prop]))\n                    utils_1.error(`'dependsOn' must be the string name of an attribute or alias`);\n                break;\n            case 'transform':\n                if (typeof config[prop] !== 'function')\n                    utils_1.error(`'${prop}' must be a function`);\n                break;\n            case 'coerce':\n            case 'onUpdate':\n            case 'hidden':\n            case 'save':\n                if (typeof config[prop] !== 'boolean')\n                    utils_1.error(`'${prop}' must be a boolean`);\n                break;\n            case 'required':\n                if (typeof config[prop] !== 'boolean' && config[prop] !== 'always')\n                    utils_1.error(`'required' must be a boolean or set to 'always'`);\n                break;\n            case 'alias':\n            case 'map':\n                if (typeof config[prop] !== 'string'\n                    || track.fields.includes((config[prop] || '').trim())\n                    || (config[prop] || '').trim().length === 0)\n                    utils_1.error(`'${prop}' must be a unique string`);\n                break;\n            case 'setType':\n                if (config.type !== 'set')\n                    utils_1.error(`'setType' is only valid for type 'set'`);\n                if (!['string', 'number', 'binary'].includes((config[prop] || '')))\n                    utils_1.error(`Invalid 'setType', must be 'string', 'number', or 'binary'`);\n                break;\n            case 'delimiter':\n                if (typeof config[prop] !== 'string' || (config[prop] || '').trim().length === 0)\n                    utils_1.error(`'delimiter' must be a 'string'`);\n                config[prop] = (config[prop] || '').trim();\n                break;\n            case 'prefix':\n            case 'suffix':\n                if (config.type && config.type !== 'string')\n                    utils_1.error(`'${prop}' can only be used on 'string' types`);\n                if (typeof config[prop] !== 'string' || (config[prop] || '').trim().length === 0)\n                    utils_1.error(`'${prop}' must be a 'string'`);\n                break;\n            case 'partitionKey':\n            case 'sortKey':\n                if (config.map || config.alias)\n                    utils_1.error(`Attributes with a ${prop} cannot have a 'map' or 'alias' associated`);\n                if (typeof config[prop] === 'boolean' || typeof config[prop] === 'string' || Array.isArray(config[prop])) {\n                    // Coerce/cast to an array of strings/booleans\n                    const indexes = (Array.isArray(config[prop]) ? config[prop] : [config[prop]]);\n                    // Loop through values and track keys\n                    for (let i in indexes) {\n                        // If a boolean, set primary pk/sk\n                        if (typeof indexes[i] === 'boolean') {\n                            // Check that another prop isn't already a key\n                            if (track.keys[prop])\n                                utils_1.error(`'${track.keys[prop]}' has already been declared as the ${prop}`);\n                            // If true, add the field as the key\n                            if (indexes[i])\n                                track.keys[prop] = field;\n                            // If the partionKey is the same as the sortKey, throw an error\n                            if (track.keys.partitionKey && track.keys.partitionKey === track.keys.sortKey)\n                                utils_1.error(`'${field}' attribute cannot be both the partitionKey and sortKey`);\n                            // If string, set index pk/sk\n                        }\n                        else if (typeof indexes[i] === 'string') {\n                            const index = indexes[i];\n                            // If the index isn't being tracked yet, add it\n                            if (!track.keys[index])\n                                track.keys[index] = {};\n                            // If the index's pk/sk already exist\n                            if (track.keys[index][prop]) {\n                                utils_1.error(`'${track.keys[index][prop]}' has already been declared as the ${prop} for the ${index} index`);\n                            }\n                            track.keys[index][prop] = field;\n                            if (track.keys[index].partitionKey === track.keys[index].sortKey)\n                                utils_1.error(`'${field}' attribute cannot be both the partitionKey and sortKey for the ${index} index`);\n                        }\n                        else {\n                            utils_1.error(`Index assignments for '${field}' must be string or boolean values`);\n                        }\n                    } // end for\n                }\n                else {\n                    utils_1.error(`'${prop}' must be a boolean, string, or array`);\n                }\n                break;\n            default:\n                utils_1.error(`'${prop}' is not a valid property type`);\n        }\n    });\n    // Error on alias and map\n    if (config.alias && config.map)\n        utils_1.error(`'${field}' cannot contain both an alias and a map`);\n    // Default the type\n    if (!config.type)\n        config.type = 'string';\n    // Default coerce based on type\n    if (['string', 'boolean', 'number'].includes(config.type)\n        && typeof config.coerce === 'undefined')\n        config.coerce = true;\n    // Set defaults\n    if (config.default !== undefined)\n        track.defaults[field] = config.default;\n    // Track required settings\n    if (config.required === true)\n        track.required[config.map || field] = false;\n    if (config.required === 'always')\n        track.required[config.map || field] = true;\n    // Destructure the config to pull out map and alias\n    const { map, alias } = config, _config = __rest(config\n    // Return the original config\n    , [\"map\", \"alias\"]);\n    // Return the original config\n    return Object.assign({\n        [field]: config\n    }, alias ? {\n        [alias]: Object.assign({}, _config, { map: field })\n    } : {}, map ? {\n        [map]: Object.assign({}, _config, { alias: field })\n    } : {}); // end assign\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}