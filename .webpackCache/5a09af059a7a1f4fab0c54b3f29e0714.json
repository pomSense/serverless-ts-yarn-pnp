{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeInaccessibleElements = exports.INACCESSIBLE_VERSIONS = exports.InaccessibleSpecDefinition = exports.inaccessibleIdentity = void 0;\nconst coreSpec_1 = require(\"./coreSpec\");\nconst definitions_1 = require(\"./definitions\");\nconst graphql_1 = require(\"graphql\");\nconst knownCoreFeatures_1 = require(\"./knownCoreFeatures\");\nconst error_1 = require(\"./error\");\nconst directiveAndTypeSpecification_1 = require(\"./directiveAndTypeSpecification\");\nconst utils_1 = require(\"./utils\");\nexports.inaccessibleIdentity = 'https://specs.apollo.dev/inaccessible';\nclass InaccessibleSpecDefinition extends coreSpec_1.FeatureDefinition {\n  constructor(version, minimumFederationVersion) {\n    super(new coreSpec_1.FeatureUrl(exports.inaccessibleIdentity, 'inaccessible', version), minimumFederationVersion);\n    this.inaccessibleLocations = [graphql_1.DirectiveLocation.FIELD_DEFINITION, graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE, graphql_1.DirectiveLocation.UNION];\n    this.printedInaccessibleDefinition = 'directive @inaccessible on FIELD_DEFINITION | INTERFACE | OBJECT | UNION';\n    if (!this.isV01()) {\n      this.inaccessibleLocations.push(graphql_1.DirectiveLocation.ARGUMENT_DEFINITION, graphql_1.DirectiveLocation.SCALAR, graphql_1.DirectiveLocation.ENUM, graphql_1.DirectiveLocation.ENUM_VALUE, graphql_1.DirectiveLocation.INPUT_OBJECT, graphql_1.DirectiveLocation.INPUT_FIELD_DEFINITION);\n      this.printedInaccessibleDefinition = 'directive @inaccessible on FIELD_DEFINITION | INTERFACE | OBJECT | UNION | ARGUMENT_DEFINITION | SCALAR | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION';\n    }\n    this.inaccessibleDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({\n      name: 'inaccessible',\n      locations: this.inaccessibleLocations,\n      composes: true,\n      supergraphSpecification: fedVersion => exports.INACCESSIBLE_VERSIONS.getMinimumRequiredVersion(fedVersion)\n    });\n    this.registerDirective(this.inaccessibleDirectiveSpec);\n  }\n  isV01() {\n    return this.version.equals(new coreSpec_1.FeatureVersion(0, 1));\n  }\n  inaccessibleDirective(schema) {\n    return this.directive(schema, 'inaccessible');\n  }\n  checkCompatibleDirective(definition) {\n    const hasUnknownArguments = Object.keys(definition.arguments()).length > 0;\n    const hasRepeatable = definition.repeatable;\n    const hasValidLocations = definition.locations.every(loc => this.inaccessibleLocations.includes(loc));\n    if (hasUnknownArguments || hasRepeatable || !hasValidLocations) {\n      return error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Found invalid @inaccessible directive definition. Please ensure the directive definition in your schema's definitions matches the following:\\n\\t${this.printedInaccessibleDefinition}`);\n    }\n    return undefined;\n  }\n  get defaultCorePurpose() {\n    return 'SECURITY';\n  }\n}\nexports.InaccessibleSpecDefinition = InaccessibleSpecDefinition;\nexports.INACCESSIBLE_VERSIONS = new coreSpec_1.FeatureDefinitions(exports.inaccessibleIdentity).add(new InaccessibleSpecDefinition(new coreSpec_1.FeatureVersion(0, 1))).add(new InaccessibleSpecDefinition(new coreSpec_1.FeatureVersion(0, 2), new coreSpec_1.FeatureVersion(2, 0)));\n(0, knownCoreFeatures_1.registerKnownFeature)(exports.INACCESSIBLE_VERSIONS);\nfunction removeInaccessibleElements(schema) {\n  schema.validate();\n  const coreFeatures = schema.coreFeatures;\n  if (!coreFeatures) {\n    return;\n  }\n  const inaccessibleFeature = coreFeatures.getByIdentity(exports.inaccessibleIdentity);\n  if (!inaccessibleFeature) {\n    return;\n  }\n  const inaccessibleSpec = exports.INACCESSIBLE_VERSIONS.find(inaccessibleFeature.url.version);\n  if (!inaccessibleSpec) {\n    throw (0, definitions_1.ErrGraphQLAPISchemaValidationFailed)([new graphql_1.GraphQLError(`Cannot remove inaccessible elements: the schema uses unsupported` + ` inaccessible spec version ${inaccessibleFeature.url.version}` + ` (supported versions: ${exports.INACCESSIBLE_VERSIONS.versions().join(', ')})`)]);\n  }\n  const inaccessibleDirective = inaccessibleSpec.inaccessibleDirective(schema);\n  if (!inaccessibleDirective) {\n    throw (0, definitions_1.ErrGraphQLAPISchemaValidationFailed)([new graphql_1.GraphQLError(`Invalid schema: declares ${inaccessibleSpec.url} spec but does not` + ` define a @inaccessible directive.`)]);\n  }\n  const incompatibleError = inaccessibleSpec.checkCompatibleDirective(inaccessibleDirective);\n  if (incompatibleError) {\n    throw (0, definitions_1.ErrGraphQLAPISchemaValidationFailed)([incompatibleError]);\n  }\n  validateInaccessibleElements(schema, coreFeatures, inaccessibleSpec, inaccessibleDirective);\n  removeInaccessibleElementsAssumingValid(schema, inaccessibleDirective);\n}\nexports.removeInaccessibleElements = removeInaccessibleElements;\nfunction validateInaccessibleElements(schema, coreFeatures, inaccessibleSpec, inaccessibleDirective) {\n  var _a, _b, _c;\n  function isInaccessible(element) {\n    return element.hasAppliedDirective(inaccessibleDirective);\n  }\n  const featureList = [...coreFeatures.allFeatures()];\n  function isFeatureDefinition(element) {\n    return featureList.some(feature => feature.isFeatureDefinition(element));\n  }\n  function isInAPISchema(element) {\n    if (!(element instanceof definitions_1.DirectiveDefinition) && isInaccessible(element)) return false;\n    if (element instanceof definitions_1.ObjectType || element instanceof definitions_1.InterfaceType || element instanceof definitions_1.UnionType || element instanceof definitions_1.ScalarType || element instanceof definitions_1.EnumType || element instanceof definitions_1.InputObjectType || element instanceof definitions_1.DirectiveDefinition) {\n      return true;\n    } else if (element instanceof definitions_1.FieldDefinition || element instanceof definitions_1.ArgumentDefinition || element instanceof definitions_1.InputFieldDefinition || element instanceof definitions_1.EnumValue) {\n      return isInAPISchema(element.parent);\n    }\n    (0, utils_1.assert)(false, \"Unreachable code, element is of unknown type.\");\n  }\n  function fetchInaccessibleElementsDeep(element) {\n    const inaccessibleElements = [];\n    if (isInaccessible(element)) {\n      inaccessibleElements.push(element);\n    }\n    if (element instanceof definitions_1.ObjectType || element instanceof definitions_1.InterfaceType || element instanceof definitions_1.InputObjectType) {\n      for (const field of element.fields()) {\n        inaccessibleElements.push(...fetchInaccessibleElementsDeep(field));\n      }\n      return inaccessibleElements;\n    } else if (element instanceof definitions_1.EnumType) {\n      for (const enumValue of element.values) {\n        inaccessibleElements.push(...fetchInaccessibleElementsDeep(enumValue));\n      }\n      return inaccessibleElements;\n    } else if (element instanceof definitions_1.DirectiveDefinition || element instanceof definitions_1.FieldDefinition) {\n      for (const argument of element.arguments()) {\n        inaccessibleElements.push(...fetchInaccessibleElementsDeep(argument));\n      }\n      return inaccessibleElements;\n    } else if (element instanceof definitions_1.UnionType || element instanceof definitions_1.ScalarType || element instanceof definitions_1.ArgumentDefinition || element instanceof definitions_1.InputFieldDefinition || element instanceof definitions_1.EnumValue) {\n      return inaccessibleElements;\n    }\n    (0, utils_1.assert)(false, \"Unreachable code, element is of unknown type.\");\n  }\n  const errors = [];\n  let defaultValueReferencers = undefined;\n  if (!inaccessibleSpec.isV01()) {\n    defaultValueReferencers = computeDefaultValueReferencers(schema);\n  }\n  for (const type of schema.allTypes()) {\n    if (hasBuiltInName(type)) {\n      const inaccessibleElements = fetchInaccessibleElementsDeep(type);\n      if (inaccessibleElements.length > 0) {\n        errors.push(error_1.ERRORS.DISALLOWED_INACCESSIBLE.err(`Built-in type \"${type.coordinate}\" cannot use @inaccessible.`, {\n          nodes: type.sourceAST,\n          extensions: {\n            inaccessible_elements: inaccessibleElements.map(element => element.coordinate),\n            inaccessible_referencers: [type.coordinate]\n          }\n        }));\n      }\n    } else if (isFeatureDefinition(type)) {\n      const inaccessibleElements = fetchInaccessibleElementsDeep(type);\n      if (inaccessibleElements.length > 0) {\n        errors.push(error_1.ERRORS.DISALLOWED_INACCESSIBLE.err(`Core feature type \"${type.coordinate}\" cannot use @inaccessible.`, {\n          nodes: type.sourceAST,\n          extensions: {\n            inaccessible_elements: inaccessibleElements.map(element => element.coordinate),\n            inaccessible_referencers: [type.coordinate]\n          }\n        }));\n      }\n    } else if (isInaccessible(type)) {\n      const referencers = type.referencers();\n      for (const referencer of referencers) {\n        if (referencer instanceof definitions_1.FieldDefinition || referencer instanceof definitions_1.ArgumentDefinition || referencer instanceof definitions_1.InputFieldDefinition) {\n          if (isInAPISchema(referencer)) {\n            errors.push(error_1.ERRORS.REFERENCED_INACCESSIBLE.err(`Type \"${type.coordinate}\" is @inaccessible but is referenced` + ` by \"${referencer.coordinate}\", which is in the API schema.`, {\n              nodes: type.sourceAST,\n              extensions: {\n                inaccessible_elements: [type.coordinate],\n                inaccessible_referencers: [referencer.coordinate]\n              }\n            }));\n          }\n        } else if (referencer instanceof definitions_1.SchemaDefinition) {\n          if (type === referencer.rootType('query')) {\n            errors.push(error_1.ERRORS.QUERY_ROOT_TYPE_INACCESSIBLE.err(`Type \"${type.coordinate}\" is @inaccessible but is the root` + ` query type, which must be in the API schema.`, {\n              nodes: type.sourceAST,\n              extensions: {\n                inaccessible_elements: [type.coordinate]\n              }\n            }));\n          }\n        }\n      }\n    } else {\n      if (type instanceof definitions_1.ObjectType || type instanceof definitions_1.InterfaceType || type instanceof definitions_1.InputObjectType) {\n        let isEmpty = true;\n        for (const field of type.fields()) {\n          if (!isInaccessible(field)) isEmpty = false;\n        }\n        if (isEmpty) {\n          errors.push(error_1.ERRORS.ONLY_INACCESSIBLE_CHILDREN.err(`Type \"${type.coordinate}\" is in the API schema but all of its` + ` ${type instanceof definitions_1.InputObjectType ? 'input ' : ''}fields` + ` are @inaccessible.`, {\n            nodes: type.sourceAST,\n            extensions: {\n              inaccessible_elements: type.fields().map(field => field.coordinate),\n              inaccessible_referencers: [type.coordinate]\n            }\n          }));\n        }\n      } else if (type instanceof definitions_1.UnionType) {\n        let isEmpty = true;\n        for (const member of type.types()) {\n          if (!isInaccessible(member)) isEmpty = false;\n        }\n        if (isEmpty) {\n          errors.push(error_1.ERRORS.ONLY_INACCESSIBLE_CHILDREN.err(`Type \"${type.coordinate}\" is in the API schema but all of its` + ` members are @inaccessible.`, {\n            nodes: type.sourceAST,\n            extensions: {\n              inaccessible_elements: type.types().map(type => type.coordinate),\n              inaccessible_referencers: [type.coordinate]\n            }\n          }));\n        }\n      } else if (type instanceof definitions_1.EnumType) {\n        let isEmpty = true;\n        for (const enumValue of type.values) {\n          if (!isInaccessible(enumValue)) isEmpty = false;\n        }\n        if (isEmpty) {\n          errors.push(error_1.ERRORS.ONLY_INACCESSIBLE_CHILDREN.err(`Type \"${type.coordinate}\" is in the API schema but all of its` + ` values are @inaccessible.`, {\n            nodes: type.sourceAST,\n            extensions: {\n              inaccessible_elements: type.values.map(enumValue => enumValue.coordinate),\n              inaccessible_referencers: [type.coordinate]\n            }\n          }));\n        }\n      }\n      if (type instanceof definitions_1.ObjectType || type instanceof definitions_1.InterfaceType) {\n        const implementedInterfaces = type.interfaces();\n        const implementingTypes = [];\n        if (type instanceof definitions_1.InterfaceType) {\n          for (const referencer of type.referencers()) {\n            if (referencer instanceof definitions_1.ObjectType || referencer instanceof definitions_1.InterfaceType) {\n              implementingTypes.push(referencer);\n            }\n          }\n        }\n        for (const field of type.fields()) {\n          if (isInaccessible(field)) {\n            for (const implementedInterface of implementedInterfaces) {\n              const implementedField = implementedInterface.field(field.name);\n              if (implementedField && isInAPISchema(implementedField)) {\n                errors.push(error_1.ERRORS.IMPLEMENTED_BY_INACCESSIBLE.err(`Field \"${field.coordinate}\" is @inaccessible but` + ` implements the interface field` + ` \"${implementedField.coordinate}\", which is in the API` + ` schema.`, {\n                  nodes: field.sourceAST,\n                  extensions: {\n                    inaccessible_elements: [field.coordinate],\n                    inaccessible_referencers: [implementedField.coordinate]\n                  }\n                }));\n              }\n            }\n          } else {\n            for (const argument of field.arguments()) {\n              if (isInaccessible(argument)) {\n                if (argument.isRequired()) {\n                  errors.push(error_1.ERRORS.REQUIRED_INACCESSIBLE.err(`Argument \"${argument.coordinate}\" is @inaccessible but` + ` is a required argument of its field.`, {\n                    nodes: argument.sourceAST,\n                    extensions: {\n                      inaccessible_elements: [argument.coordinate],\n                      inaccessible_referencers: [argument.coordinate]\n                    }\n                  }));\n                }\n                for (const implementingType of implementingTypes) {\n                  const implementingField = implementingType.field(field.name);\n                  (0, utils_1.assert)(implementingField, \"Schema should have been valid, but an implementing type\" + \" did not implement one of this type's fields.\");\n                  const implementingArgument = implementingField.argument(argument.name);\n                  (0, utils_1.assert)(implementingArgument, \"Schema should have been valid, but an implementing type\" + \" did not implement one of this type's field's arguments.\");\n                  if (isInAPISchema(implementingArgument) && implementingArgument.isRequired()) {\n                    errors.push(error_1.ERRORS.REQUIRED_INACCESSIBLE.err(`Argument \"${argument.coordinate}\" is @inaccessible` + ` but is implemented by the required argument` + ` \"${implementingArgument.coordinate}\", which is` + ` in the API schema.`, {\n                      nodes: argument.sourceAST,\n                      extensions: {\n                        inaccessible_elements: [argument.coordinate],\n                        inaccessible_referencers: [implementingArgument.coordinate]\n                      }\n                    }));\n                  }\n                }\n                for (const implementedInterface of implementedInterfaces) {\n                  const implementedArgument = (_a = implementedInterface.field(field.name)) === null || _a === void 0 ? void 0 : _a.argument(argument.name);\n                  if (implementedArgument && isInAPISchema(implementedArgument)) {\n                    errors.push(error_1.ERRORS.IMPLEMENTED_BY_INACCESSIBLE.err(`Argument \"${argument.coordinate}\" is @inaccessible` + ` but implements the interface argument` + ` \"${implementedArgument.coordinate}\", which is in` + ` the API schema.`, {\n                      nodes: argument.sourceAST,\n                      extensions: {\n                        inaccessible_elements: [argument.coordinate],\n                        inaccessible_referencers: [implementedArgument.coordinate]\n                      }\n                    }));\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else if (type instanceof definitions_1.InputObjectType) {\n        for (const inputField of type.fields()) {\n          if (isInaccessible(inputField)) {\n            if (inputField.isRequired()) {\n              errors.push(error_1.ERRORS.REQUIRED_INACCESSIBLE.err(`Input field \"${inputField.coordinate}\" is @inaccessible` + ` but is a required input field of its type.`, {\n                nodes: inputField.sourceAST,\n                extensions: {\n                  inaccessible_elements: [inputField.coordinate],\n                  inaccessible_referencers: [inputField.coordinate]\n                }\n              }));\n            }\n            (0, utils_1.assert)(defaultValueReferencers, \"Input fields can't be @inaccessible in v0.1, but default value\" + \" referencers weren't computed (which is only skipped for v0.1).\");\n            const referencers = (_b = defaultValueReferencers.get(inputField)) !== null && _b !== void 0 ? _b : [];\n            for (const referencer of referencers) {\n              if (isInAPISchema(referencer)) {\n                errors.push(error_1.ERRORS.DEFAULT_VALUE_USES_INACCESSIBLE.err(`Input field \"${inputField.coordinate}\" is @inaccessible` + ` but is used in the default value of` + ` \"${referencer.coordinate}\", which is in the API schema.`, {\n                  nodes: type.sourceAST,\n                  extensions: {\n                    inaccessible_elements: [type.coordinate],\n                    inaccessible_referencers: [referencer.coordinate]\n                  }\n                }));\n              }\n            }\n          }\n        }\n      } else if (type instanceof definitions_1.EnumType) {\n        for (const enumValue of type.values) {\n          if (isInaccessible(enumValue)) {\n            (0, utils_1.assert)(defaultValueReferencers, \"Enum values can't be @inaccessible in v0.1, but default value\" + \" referencers weren't computed (which is only skipped for v0.1).\");\n            const referencers = (_c = defaultValueReferencers.get(enumValue)) !== null && _c !== void 0 ? _c : [];\n            for (const referencer of referencers) {\n              if (isInAPISchema(referencer)) {\n                errors.push(error_1.ERRORS.DEFAULT_VALUE_USES_INACCESSIBLE.err(`Enum value \"${enumValue.coordinate}\" is @inaccessible` + ` but is used in the default value of` + ` \"${referencer.coordinate}\", which is in the API schema.`, {\n                  nodes: type.sourceAST,\n                  extensions: {\n                    inaccessible_elements: [type.coordinate],\n                    inaccessible_referencers: [referencer.coordinate]\n                  }\n                }));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  for (const directive of schema.allDirectives()) {\n    const typeSystemLocations = directive.locations.filter(loc => (0, definitions_1.isTypeSystemDirectiveLocation)(loc));\n    if (hasBuiltInName(directive)) {\n      const inaccessibleElements = fetchInaccessibleElementsDeep(directive);\n      if (inaccessibleElements.length > 0) {\n        errors.push(error_1.ERRORS.DISALLOWED_INACCESSIBLE.err(`Built-in directive \"${directive.coordinate}\" cannot use @inaccessible.`, {\n          nodes: directive.sourceAST,\n          extensions: {\n            inaccessible_elements: inaccessibleElements.map(element => element.coordinate),\n            inaccessible_referencers: [directive.coordinate]\n          }\n        }));\n      }\n    } else if (isFeatureDefinition(directive)) {\n      const inaccessibleElements = fetchInaccessibleElementsDeep(directive);\n      if (inaccessibleElements.length > 0) {\n        errors.push(error_1.ERRORS.DISALLOWED_INACCESSIBLE.err(`Core feature directive \"${directive.coordinate}\" cannot use @inaccessible.`, {\n          nodes: directive.sourceAST,\n          extensions: {\n            inaccessible_elements: inaccessibleElements.map(element => element.coordinate),\n            inaccessible_referencers: [directive.coordinate]\n          }\n        }));\n      }\n    } else if (typeSystemLocations.length > 0) {\n      const inaccessibleElements = fetchInaccessibleElementsDeep(directive);\n      if (inaccessibleElements.length > 0) {\n        errors.push(error_1.ERRORS.DISALLOWED_INACCESSIBLE.err(`Directive \"${directive.coordinate}\" cannot use @inaccessible` + ` because it may be applied to these type-system locations:` + ` ${typeSystemLocations.join(', ')}.`, {\n          nodes: directive.sourceAST,\n          extensions: {\n            inaccessible_elements: inaccessibleElements.map(element => element.coordinate),\n            inaccessible_referencers: [directive.coordinate]\n          }\n        }));\n      }\n    } else {\n      for (const argument of directive.arguments()) {\n        if (argument.isRequired()) {\n          if (isInaccessible(argument)) {\n            errors.push(error_1.ERRORS.REQUIRED_INACCESSIBLE.err(`Argument \"${argument.coordinate}\" is @inaccessible but is a` + ` required argument of its directive.`, {\n              nodes: argument.sourceAST,\n              extensions: {\n                inaccessible_elements: [argument.coordinate],\n                inaccessible_referencers: [argument.coordinate]\n              }\n            }));\n          }\n        }\n      }\n    }\n  }\n  if (errors.length > 0) {\n    throw (0, definitions_1.ErrGraphQLAPISchemaValidationFailed)(errors);\n  }\n}\nfunction computeDefaultValueReferencers(schema) {\n  const referencers = new Map();\n  function addReference(reference, referencer) {\n    var _a;\n    const referencerList = (_a = referencers.get(reference)) !== null && _a !== void 0 ? _a : [];\n    if (referencerList.length === 0) {\n      referencers.set(reference, referencerList);\n    }\n    referencerList.push(referencer);\n  }\n  for (const type of schema.allTypes()) {\n    if (hasBuiltInName(type)) continue;\n    if (type instanceof definitions_1.ObjectType || type instanceof definitions_1.InterfaceType) {\n      for (const field of type.fields()) {\n        for (const argument of field.arguments()) {\n          for (const reference of computeDefaultValueReferences(argument)) {\n            addReference(reference, argument);\n          }\n        }\n      }\n    }\n    if (type instanceof definitions_1.InputObjectType) {\n      for (const inputField of type.fields()) {\n        for (const reference of computeDefaultValueReferences(inputField)) {\n          addReference(reference, inputField);\n        }\n      }\n    }\n  }\n  for (const directive of schema.allDirectives()) {\n    if (hasBuiltInName(directive)) continue;\n    for (const argument of directive.arguments()) {\n      for (const reference of computeDefaultValueReferences(argument)) {\n        addReference(reference, argument);\n      }\n    }\n  }\n  return referencers;\n}\nfunction computeDefaultValueReferences(element) {\n  const references = [];\n  addValueReferences(element.defaultValue, getInputType(element), references);\n  return references;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  (0, utils_1.assert)(type, \"Schema should have been valid, but argument/input field did not have type.\");\n  return type;\n}\nfunction addValueReferences(value, type, references) {\n  if (value === undefined || value === null) {\n    return;\n  }\n  if ((0, definitions_1.isNonNullType)(type)) {\n    return addValueReferences(value, type.ofType, references);\n  }\n  if ((0, definitions_1.isScalarType)(type)) {\n    return;\n  }\n  if ((0, definitions_1.isVariable)(value)) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    if ((0, definitions_1.isListType)(type)) {\n      const itemType = type.ofType;\n      for (const item of value) {\n        addValueReferences(item, itemType, references);\n      }\n    } else {}\n    return;\n  }\n  if ((0, definitions_1.isListType)(type)) {\n    return addValueReferences(value, type.ofType, references);\n  }\n  if (typeof value === 'object') {\n    if ((0, definitions_1.isInputObjectType)(type)) {\n      for (const field of type.fields()) {\n        const fieldValue = value[field.name];\n        if (fieldValue !== undefined) {\n          references.push(field);\n          addValueReferences(fieldValue, field.type, references);\n        } else {}\n      }\n    } else {}\n    return;\n  }\n  if (typeof value === 'string') {\n    if ((0, definitions_1.isEnumType)(type)) {\n      const enumValue = type.value(value);\n      if (enumValue !== undefined) {\n        references.push(enumValue);\n      } else {}\n    } else {}\n    return;\n  }\n  return;\n}\nfunction hasBuiltInName(element) {\n  const schema = element.schema();\n  if (element instanceof definitions_1.ObjectType || element instanceof definitions_1.InterfaceType || element instanceof definitions_1.UnionType || element instanceof definitions_1.ScalarType || element instanceof definitions_1.EnumType || element instanceof definitions_1.InputObjectType) {\n    return schema.builtInTypes(true).some(type => type.name === element.name);\n  } else if (element instanceof definitions_1.DirectiveDefinition) {\n    return schema.builtInDirectives(true).some(directive => directive.name === element.name);\n  }\n  (0, utils_1.assert)(false, \"Unreachable code, element is of unknown type.\");\n}\nfunction removeInaccessibleElementsAssumingValid(schema, inaccessibleDirective) {\n  function isInaccessible(element) {\n    return element.hasAppliedDirective(inaccessibleDirective);\n  }\n  for (const type of schema.types()) {\n    if (isInaccessible(type)) {\n      type.remove();\n    } else {\n      if (type instanceof definitions_1.ObjectType || type instanceof definitions_1.InterfaceType) {\n        for (const field of type.fields()) {\n          if (isInaccessible(field)) {\n            field.remove();\n          } else {\n            for (const argument of field.arguments()) {\n              if (isInaccessible(argument)) {\n                argument.remove();\n              }\n            }\n          }\n        }\n      } else if (type instanceof definitions_1.InputObjectType) {\n        for (const inputField of type.fields()) {\n          if (isInaccessible(inputField)) {\n            inputField.remove();\n          }\n        }\n      } else if (type instanceof definitions_1.EnumType) {\n        for (const enumValue of type.values) {\n          if (isInaccessible(enumValue)) {\n            enumValue.remove();\n          }\n        }\n      }\n    }\n  }\n  for (const directive of schema.directives()) {\n    for (const argument of directive.arguments()) {\n      if (isInaccessible(argument)) {\n        argument.remove();\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["coreSpec_1","require","definitions_1","graphql_1","knownCoreFeatures_1","error_1","directiveAndTypeSpecification_1","utils_1","exports","inaccessibleIdentity","InaccessibleSpecDefinition","FeatureDefinition","constructor","version","minimumFederationVersion","FeatureUrl","inaccessibleLocations","DirectiveLocation","FIELD_DEFINITION","OBJECT","INTERFACE","UNION","printedInaccessibleDefinition","isV01","push","ARGUMENT_DEFINITION","SCALAR","ENUM","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","inaccessibleDirectiveSpec","createDirectiveSpecification","name","locations","composes","supergraphSpecification","fedVersion","INACCESSIBLE_VERSIONS","getMinimumRequiredVersion","registerDirective","equals","FeatureVersion","inaccessibleDirective","schema","directive","checkCompatibleDirective","definition","hasUnknownArguments","Object","keys","arguments","length","hasRepeatable","repeatable","hasValidLocations","every","loc","includes","ERRORS","DIRECTIVE_DEFINITION_INVALID","err","undefined","defaultCorePurpose","FeatureDefinitions","add","registerKnownFeature","removeInaccessibleElements","validate","coreFeatures","inaccessibleFeature","getByIdentity","inaccessibleSpec","find","url","ErrGraphQLAPISchemaValidationFailed","GraphQLError","versions","join","incompatibleError","validateInaccessibleElements","removeInaccessibleElementsAssumingValid","isInaccessible","element","hasAppliedDirective","featureList","allFeatures","isFeatureDefinition","some","feature","isInAPISchema","DirectiveDefinition","ObjectType","InterfaceType","UnionType","ScalarType","EnumType","InputObjectType","FieldDefinition","ArgumentDefinition","InputFieldDefinition","EnumValue","parent","assert","fetchInaccessibleElementsDeep","inaccessibleElements","field","fields","enumValue","values","argument","errors","defaultValueReferencers","computeDefaultValueReferencers","type","allTypes","hasBuiltInName","DISALLOWED_INACCESSIBLE","coordinate","nodes","sourceAST","extensions","inaccessible_elements","map","inaccessible_referencers","referencers","referencer","REFERENCED_INACCESSIBLE","SchemaDefinition","rootType","QUERY_ROOT_TYPE_INACCESSIBLE","isEmpty","ONLY_INACCESSIBLE_CHILDREN","member","types","implementedInterfaces","interfaces","implementingTypes","implementedInterface","implementedField","IMPLEMENTED_BY_INACCESSIBLE","isRequired","REQUIRED_INACCESSIBLE","implementingType","implementingField","implementingArgument","implementedArgument","_a","inputField","_b","get","DEFAULT_VALUE_USES_INACCESSIBLE","_c","allDirectives","typeSystemLocations","filter","isTypeSystemDirectiveLocation","Map","addReference","reference","referencerList","set","computeDefaultValueReferences","references","addValueReferences","defaultValue","getInputType","value","isNonNullType","ofType","isScalarType","isVariable","Array","isArray","isListType","itemType","item","isInputObjectType","fieldValue","isEnumType","builtInTypes","builtInDirectives","remove","directives"],"sourceRoot":"","sources":["../src/inaccessibleSpec.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}