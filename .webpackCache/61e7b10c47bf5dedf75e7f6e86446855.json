{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// TODO: allow for nesting (use arrays) and boolean settings\n// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.OperatorsAndFunctions.html\n// Import standard error handler\nconst utils_1 = require(\"./utils\");\nconst checkAttribute_1 = __importDefault(require(\"./checkAttribute\"));\nconst buildExpression = (exp, table, entity, group = 0, level = 0) => {\n  // Coerce to array if not already\n  const clauses = Array.isArray(exp) ? exp : [exp];\n  let expression = '';\n  let names = {};\n  let values = {};\n  let logic; // init undefined at each level\n  // group logic tracker - need to mark the first clause\n  // Loop through the clauses\n  clauses.forEach((x, id) => {\n    // If clause is nested in an array\n    if (Array.isArray(clauses[id])) {\n      // Build the sub clause\n      let sub = buildExpression(clauses[id], table, entity, group, level);\n      // If no logic at this level, capture from sub clause\n      logic = logic ? logic : sub.logic;\n      // Concat to expression and merge names and values\n      expression += `${id > 0 ? ` ${sub.logic} ` : ''}(${sub.expression})`;\n      names = Object.assign(names, sub.names);\n      values = Object.assign(values, sub.values);\n      group = sub.group;\n      // Else process the clause\n    } else {\n      // Make sure TS knows this is a FilterExpression\n      const exp = clauses[id];\n      // Increment group counter for each clause\n      group++; // guarantees uniqueness\n      // Default entity reference\n      if (entity && !exp.entity) exp.entity = entity;\n      // Parse the clause\n      const clause = parseClause(exp, group, table);\n      // Concat to expression and merge names and values\n      expression += `${id > 0 ? ` ${clause.logic} ` : ''}${clause.clause}`;\n      names = Object.assign(names, clause.names);\n      values = Object.assign(values, clause.values);\n      // Capture the first logic indicator at this level      \n      logic = logic ? logic : clause.logic;\n    }\n  }); // end for\n  return {\n    logic,\n    expression,\n    names,\n    values,\n    group\n  };\n};\n// Export buildExpression\nexports.default = buildExpression;\n// Define condition expression error\nconst conditionError = op => utils_1.error(`You can only supply one filter condition per query. Already using '${op}'`);\n// Parses expression clause and returns structured clause object\nconst parseClause = (_clause, grp, table) => {\n  // Init clause, names, and values\n  let clause = '';\n  const names = {};\n  const values = {};\n  // Deconstruct valid expression options\n  const {\n      attr,\n      // attribute\n      size,\n      // wraps attr in size()\n      negate,\n      // negates expression\n      or,\n      // change logical evaluator to OR\n      eq,\n      // =\n      ne,\n      // <>\n      in: _in,\n      // IN\n      lt,\n      // <\n      lte,\n      // <=\n      gt,\n      // >\n      gte,\n      // >=\n      between,\n      // BETWEEN\n      exists,\n      // NULL and NOT_NULL\n      contains,\n      // CONTAINS\n      beginsWith,\n      // BEGINS_WITH\n      type,\n      // checks attribute_type\n      entity\n    } = _clause,\n    // optional entity reference for aliasing\n    args = __rest(_clause\n    // Error on extraneous arguments\n    , [\"attr\", \"size\", \"negate\", \"or\", \"eq\", \"ne\", \"in\", \"lt\", \"lte\", \"gt\", \"gte\", \"between\", \"exists\", \"contains\", \"beginsWith\", \"type\", \"entity\"]);\n  // Error on extraneous arguments\n  if (Object.keys(args).length > 0) utils_1.error(`Invalid expression options: ${Object.keys(args).join(', ')}`);\n  // Verify entity\n  if (entity !== undefined && (typeof entity !== 'string' || !table[entity] || !table[entity].schema || !table[entity].schema.attributes)) utils_1.error(`'entity' value of '${entity}' must be a string and a valid table Entity name`);\n  // Add filter attribute to names\n  names[`#attr${grp}`] = typeof attr === 'string' ? checkAttribute_1.default(attr, entity ? table[entity].schema.attributes : table.Table.attributes) : typeof size === 'string' ? checkAttribute_1.default(size, entity ? table[entity].schema.attributes : table.Table.attributes) : utils_1.error(`A string for 'attr' or 'size' is required for condition expressions`);\n  // Parse clause operator and value\n  let operator, value, f;\n  if (eq !== undefined) {\n    value = eq;\n    f = 'eq';\n    operator = '=';\n  }\n  if (ne !== undefined) {\n    value = value ? conditionError(f) : ne;\n    f = 'ne';\n    operator = '<>';\n  }\n  if (_in) {\n    value = value ? conditionError(f) : _in;\n    f = 'in';\n    operator = 'IN';\n  }\n  if (lt !== undefined) {\n    value = value ? conditionError(f) : lt;\n    f = 'lt';\n    operator = '<';\n  }\n  if (lte !== undefined) {\n    value = value ? conditionError(f) : lte;\n    f = 'lte';\n    operator = '<=';\n  }\n  if (gt !== undefined) {\n    value = value ? conditionError(f) : gt;\n    f = 'gt';\n    operator = '>';\n  }\n  if (gte !== undefined) {\n    value = value ? conditionError(f) : gte;\n    f = 'gte';\n    operator = '>=';\n  }\n  if (between) {\n    value = value ? conditionError(f) : between;\n    f = 'between';\n    operator = 'BETWEEN';\n  }\n  if (exists !== undefined) {\n    value = value ? conditionError(f) : exists;\n    f = 'exists';\n    operator = 'EXISTS';\n  }\n  if (contains) {\n    value = value ? conditionError(f) : contains;\n    f = 'contains';\n    operator = 'CONTAINS';\n  }\n  if (beginsWith) {\n    value = value ? conditionError(f) : beginsWith;\n    f = 'beginsWith';\n    operator = 'BEGINS_WITH';\n  }\n  if (type) {\n    value = value ? conditionError(f) : type;\n    f = 'type';\n    operator = 'ATTRIBUTE_TYPE';\n  }\n  // If a operator was set\n  if (operator) {\n    // If begins_with\n    if (operator === 'BETWEEN') {\n      // Verify array input\n      if (Array.isArray(value) && value.length === 2) {\n        // Add values and special key condition\n        values[`:attr${grp}_0`] = value[0];\n        values[`:attr${grp}_1`] = value[1];\n        clause = `${size ? `size(#attr${grp})` : `#attr${grp}`} between :attr${grp}_0 and :attr${grp}_1`;\n      } else {\n        utils_1.error(`'between' conditions require an array with two values.`);\n      }\n    } else if (operator === 'IN') {\n      if (!attr) utils_1.error(`'in' conditions require an 'attr'.`);\n      // Verify array input\n      if (Array.isArray(value)) {\n        // Add values and special key condition\n        clause = `#attr${grp} IN (${value.map((x, i) => {\n          values[`:attr${grp}_${i}`] = x;\n          return `:attr${grp}_${i}`;\n        }).join(',')})`;\n      } else {\n        utils_1.error(`'in' conditions require an array.`);\n      }\n    } else if (operator === 'EXISTS') {\n      if (!attr) utils_1.error(`'exists' conditions require an 'attr'.`);\n      clause = value ? `attribute_exists(#attr${grp})` : `attribute_not_exists(#attr${grp})`;\n    } else {\n      // Add value\n      values[`:attr${grp}`] = value;\n      // If begins_with, add special key condition\n      if (operator === 'BEGINS_WITH') {\n        if (!attr) utils_1.error(`'beginsWith' conditions require an 'attr'.`);\n        clause = `begins_with(#attr${grp},:attr${grp})`;\n      } else if (operator === 'CONTAINS') {\n        if (!attr) utils_1.error(`'contains' conditions require an 'attr'.`);\n        clause = `contains(#attr${grp},:attr${grp})`;\n      } else if (operator === 'ATTRIBUTE_TYPE') {\n        if (!attr) utils_1.error(`'type' conditions require an 'attr'.`);\n        // TODO: validate/convert types\n        clause = `attribute_type(#attr${grp},:attr${grp})`;\n      } else {\n        clause = `${size ? `size(#attr${grp})` : `#attr${grp}`} ${operator} :attr${grp}`;\n      }\n    } // end if-else\n    // Negate the clause\n    if (negate) {\n      clause = `(NOT ${clause})`;\n    }\n  } else {\n    utils_1.error('A condition is required');\n  } // end if operator\n  // console.log('CLAUSE:',clause,'\\nNAMES:',names,'\\nVALUES:',values)\n  return {\n    logic: or ? 'OR' : 'AND',\n    clause,\n    names,\n    values\n  };\n}; // end parseClause","map":{"version":3,"names":["__rest","undefined","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__importDefault","mod","__esModule","defineProperty","exports","value","utils_1","require","checkAttribute_1","buildExpression","exp","table","entity","group","level","clauses","Array","isArray","expression","names","values","logic","forEach","x","id","sub","assign","clause","parseClause","default","conditionError","op","error","_clause","grp","attr","size","negate","or","eq","ne","in","_in","lt","lte","gt","gte","between","exists","contains","beginsWith","type","args","keys","join","schema","attributes","Table","operator","f","map"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/expressionBuilder.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: allow for nesting (use arrays) and boolean settings\n// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.OperatorsAndFunctions.html\n// Import standard error handler\nconst utils_1 = require(\"./utils\");\nconst checkAttribute_1 = __importDefault(require(\"./checkAttribute\"));\nconst buildExpression = (exp, table, entity, group = 0, level = 0) => {\n    // Coerce to array if not already\n    const clauses = Array.isArray(exp) ? exp : [exp];\n    let expression = '';\n    let names = {};\n    let values = {};\n    let logic; // init undefined at each level\n    // group logic tracker - need to mark the first clause\n    // Loop through the clauses\n    clauses.forEach((x, id) => {\n        // If clause is nested in an array\n        if (Array.isArray(clauses[id])) {\n            // Build the sub clause\n            let sub = buildExpression(clauses[id], table, entity, group, level);\n            // If no logic at this level, capture from sub clause\n            logic = logic ? logic : sub.logic;\n            // Concat to expression and merge names and values\n            expression += `${id > 0 ? ` ${sub.logic} ` : ''}(${sub.expression})`;\n            names = Object.assign(names, sub.names);\n            values = Object.assign(values, sub.values);\n            group = sub.group;\n            // Else process the clause\n        }\n        else {\n            // Make sure TS knows this is a FilterExpression\n            const exp = clauses[id];\n            // Increment group counter for each clause\n            group++; // guarantees uniqueness\n            // Default entity reference\n            if (entity && !exp.entity)\n                exp.entity = entity;\n            // Parse the clause\n            const clause = parseClause(exp, group, table);\n            // Concat to expression and merge names and values\n            expression += `${id > 0 ? ` ${clause.logic} ` : ''}${clause.clause}`;\n            names = Object.assign(names, clause.names);\n            values = Object.assign(values, clause.values);\n            // Capture the first logic indicator at this level      \n            logic = logic ? logic : clause.logic;\n        }\n    }); // end for\n    return {\n        logic,\n        expression,\n        names,\n        values,\n        group\n    };\n};\n// Export buildExpression\nexports.default = buildExpression;\n// Define condition expression error\nconst conditionError = (op) => utils_1.error(`You can only supply one filter condition per query. Already using '${op}'`);\n// Parses expression clause and returns structured clause object\nconst parseClause = (_clause, grp, table) => {\n    // Init clause, names, and values\n    let clause = '';\n    const names = {};\n    const values = {};\n    // Deconstruct valid expression options\n    const { attr, // attribute\n    size, // wraps attr in size()\n    negate, // negates expression\n    or, // change logical evaluator to OR\n    eq, // =\n    ne, // <>\n    in: _in, // IN\n    lt, // <\n    lte, // <=\n    gt, // >\n    gte, // >=\n    between, // BETWEEN\n    exists, // NULL and NOT_NULL\n    contains, // CONTAINS\n    beginsWith, // BEGINS_WITH\n    type, // checks attribute_type\n    entity } = _clause, // optional entity reference for aliasing\n    args = __rest(_clause\n    // Error on extraneous arguments\n    , [\"attr\", \"size\", \"negate\", \"or\", \"eq\", \"ne\", \"in\", \"lt\", \"lte\", \"gt\", \"gte\", \"between\", \"exists\", \"contains\", \"beginsWith\", \"type\", \"entity\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0)\n        utils_1.error(`Invalid expression options: ${Object.keys(args).join(', ')}`);\n    // Verify entity\n    if (entity !== undefined && (typeof entity !== 'string' || (!table[entity] || !table[entity].schema || !table[entity].schema.attributes)))\n        utils_1.error(`'entity' value of '${entity}' must be a string and a valid table Entity name`);\n    // Add filter attribute to names\n    names[`#attr${grp}`] = typeof attr === 'string' ? checkAttribute_1.default(attr, (entity ? table[entity].schema.attributes : table.Table.attributes))\n        : typeof size === 'string' ? checkAttribute_1.default(size, (entity ? table[entity].schema.attributes : table.Table.attributes))\n            : utils_1.error(`A string for 'attr' or 'size' is required for condition expressions`);\n    // Parse clause operator and value\n    let operator, value, f;\n    if (eq !== undefined) {\n        value = eq;\n        f = 'eq';\n        operator = '=';\n    }\n    if (ne !== undefined) {\n        value = value ? conditionError(f) : ne;\n        f = 'ne';\n        operator = '<>';\n    }\n    if (_in) {\n        value = value ? conditionError(f) : _in;\n        f = 'in';\n        operator = 'IN';\n    }\n    if (lt !== undefined) {\n        value = value ? conditionError(f) : lt;\n        f = 'lt';\n        operator = '<';\n    }\n    if (lte !== undefined) {\n        value = value ? conditionError(f) : lte;\n        f = 'lte';\n        operator = '<=';\n    }\n    if (gt !== undefined) {\n        value = value ? conditionError(f) : gt;\n        f = 'gt';\n        operator = '>';\n    }\n    if (gte !== undefined) {\n        value = value ? conditionError(f) : gte;\n        f = 'gte';\n        operator = '>=';\n    }\n    if (between) {\n        value = value ? conditionError(f) : between;\n        f = 'between';\n        operator = 'BETWEEN';\n    }\n    if (exists !== undefined) {\n        value = value ? conditionError(f) : exists;\n        f = 'exists';\n        operator = 'EXISTS';\n    }\n    if (contains) {\n        value = value ? conditionError(f) : contains;\n        f = 'contains';\n        operator = 'CONTAINS';\n    }\n    if (beginsWith) {\n        value = value ? conditionError(f) : beginsWith;\n        f = 'beginsWith';\n        operator = 'BEGINS_WITH';\n    }\n    if (type) {\n        value = value ? conditionError(f) : type;\n        f = 'type';\n        operator = 'ATTRIBUTE_TYPE';\n    }\n    // If a operator was set\n    if (operator) {\n        // If begins_with\n        if (operator === 'BETWEEN') {\n            // Verify array input\n            if (Array.isArray(value) && value.length === 2) {\n                // Add values and special key condition\n                values[`:attr${grp}_0`] = value[0];\n                values[`:attr${grp}_1`] = value[1];\n                clause = `${size ? `size(#attr${grp})` : `#attr${grp}`} between :attr${grp}_0 and :attr${grp}_1`;\n            }\n            else {\n                utils_1.error(`'between' conditions require an array with two values.`);\n            }\n        }\n        else if (operator === 'IN') {\n            if (!attr)\n                utils_1.error(`'in' conditions require an 'attr'.`);\n            // Verify array input\n            if (Array.isArray(value)) {\n                // Add values and special key condition\n                clause = `#attr${grp} IN (${value.map((x, i) => {\n                    values[`:attr${grp}_${i}`] = x;\n                    return `:attr${grp}_${i}`;\n                }).join(',')})`;\n            }\n            else {\n                utils_1.error(`'in' conditions require an array.`);\n            }\n        }\n        else if (operator === 'EXISTS') {\n            if (!attr)\n                utils_1.error(`'exists' conditions require an 'attr'.`);\n            clause = value ? `attribute_exists(#attr${grp})` : `attribute_not_exists(#attr${grp})`;\n        }\n        else {\n            // Add value\n            values[`:attr${grp}`] = value;\n            // If begins_with, add special key condition\n            if (operator === 'BEGINS_WITH') {\n                if (!attr)\n                    utils_1.error(`'beginsWith' conditions require an 'attr'.`);\n                clause = `begins_with(#attr${grp},:attr${grp})`;\n            }\n            else if (operator === 'CONTAINS') {\n                if (!attr)\n                    utils_1.error(`'contains' conditions require an 'attr'.`);\n                clause = `contains(#attr${grp},:attr${grp})`;\n            }\n            else if (operator === 'ATTRIBUTE_TYPE') {\n                if (!attr)\n                    utils_1.error(`'type' conditions require an 'attr'.`);\n                // TODO: validate/convert types\n                clause = `attribute_type(#attr${grp},:attr${grp})`;\n            }\n            else {\n                clause = `${size ? `size(#attr${grp})` : `#attr${grp}`} ${operator} :attr${grp}`;\n            }\n        } // end if-else\n        // Negate the clause\n        if (negate) {\n            clause = `(NOT ${clause})`;\n        }\n    }\n    else {\n        utils_1.error('A condition is required');\n    } // end if operator\n    // console.log('CLAUSE:',clause,'\\nNAMES:',names,'\\nVALUES:',values)\n    return {\n        logic: or ? 'OR' : 'AND',\n        clause,\n        names,\n        values\n    };\n}; // end parseClause\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}