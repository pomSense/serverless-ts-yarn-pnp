{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_js_1 = require(\"./utils.js\");\nconst merge_nodes_js_1 = require(\"./merge-nodes.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nfunction mergeTypeDefs(typeSource, config) {\n  (0, utils_1.resetComments)();\n  const doc = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(typeSource, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n    result = (0, utils_1.printWithComments)(doc);\n  } else {\n    result = doc;\n  }\n  (0, utils_1.resetComments)();\n  return result;\n}\nexports.mergeTypeDefs = mergeTypeDefs;\nfunction visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set()) {\n  if (typeSource && !visitedTypeSources.has(typeSource)) {\n    visitedTypeSources.add(typeSource);\n    if (typeof typeSource === 'function') {\n      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);\n    } else if (Array.isArray(typeSource)) {\n      for (const type of typeSource) {\n        visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);\n      }\n    } else if ((0, graphql_1.isSchema)(typeSource)) {\n      const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n    } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {\n      const documentNode = (0, graphql_1.parse)(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n    } else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {\n      if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        allDirectives.push(typeSource);\n      } else {\n        allNodes.push(typeSource);\n      }\n    } else if ((0, utils_1.isDocumentNode)(typeSource)) {\n      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);\n    } else {\n      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n    }\n  }\n  return {\n    allDirectives,\n    allNodes\n  };\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n  var _a, _b, _c;\n  (0, utils_1.resetComments)();\n  const {\n    allDirectives,\n    allNodes\n  } = visitTypeSources(typeSource, config);\n  const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);\n  const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);\n  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n    // XXX: right now we don't handle multiple schema definitions\n    const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      operationTypes: []\n    };\n    const operationTypes = schemaDef.operationTypes;\n    for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n      const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n      if (!opTypeDefNode) {\n        const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n        const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n          operationTypes.push({\n            kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n            type: {\n              kind: graphql_1.Kind.NAMED_TYPE,\n              name: existingPossibleRootType.name\n            },\n            operation: opTypeDefNodeType\n          });\n        }\n      }\n    }\n    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n      mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;\n    }\n  }\n  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n    mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      operationTypes: [{\n        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n        operation: 'query',\n        type: {\n          kind: graphql_1.Kind.NAMED_TYPE,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: 'Query'\n          }\n        }\n      }]\n    };\n  }\n  const mergedNodeDefinitions = Object.values(mergedNodes);\n  if (config === null || config === void 0 ? void 0 : config.sort) {\n    const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;\n    mergedNodeDefinitions.sort((a, b) => {\n      var _a, _b;\n      return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);\n    });\n  }\n  return mergedNodeDefinitions;\n}\nexports.mergeGraphQLTypes = mergeGraphQLTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeGraphQLTypes","mergeTypeDefs","graphql_1","require","utils_js_1","merge_nodes_js_1","utils_1","schema_def_js_1","typeSource","config","resetComments","doc","kind","Kind","DOCUMENT","definitions","useSchemaDefinition","forceSchemaDefinition","throwOnConflict","commentDescriptions","result","printWithComments","visitTypeSources","options","allDirectives","allNodes","visitedTypeSources","Set","has","add","Array","isArray","type","isSchema","documentNode","getDocumentNodeFromSchema","isStringTypes","isSourceTypes","parse","isDefinitionNode","DIRECTIVE_DEFINITION","push","isDocumentNode","Error","_a","_b","_c","mergedDirectives","mergeGraphQLNodes","mergedNodes","schemaDef","schemaDefSymbol","SCHEMA_DEFINITION","operationTypes","opTypeDefNodeType","DEFAULT_OPERATION_TYPE_NAME_MAP","opTypeDefNode","find","operationType","operation","possibleRootTypeName","existingPossibleRootType","name","OPERATION_TYPE_DEFINITION","NAMED_TYPE","length","NAME","mergedNodeDefinitions","values","sort","sortFn","defaultStringComparator","a","b"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/__virtual__/@graphql-tools-merge-virtual-3bffd3f135/0/cache/@graphql-tools-merge-npm-8.4.2-26df56fe04-96d57a3e81.zip/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_js_1 = require(\"./utils.js\");\nconst merge_nodes_js_1 = require(\"./merge-nodes.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nfunction mergeTypeDefs(typeSource, config) {\n    (0, utils_1.resetComments)();\n    const doc = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        result = (0, utils_1.printWithComments)(doc);\n    }\n    else {\n        result = doc;\n    }\n    (0, utils_1.resetComments)();\n    return result;\n}\nexports.mergeTypeDefs = mergeTypeDefs;\nfunction visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);\n            }\n        }\n        else if ((0, graphql_1.isSchema)(typeSource)) {\n            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {\n            const documentNode = (0, graphql_1.parse)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {\n            if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n                allDirectives.push(typeSource);\n            }\n            else {\n                allNodes.push(typeSource);\n            }\n        }\n        else if ((0, utils_1.isDocumentNode)(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return { allDirectives, allNodes };\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    var _a, _b, _c;\n    (0, utils_1.resetComments)();\n    const { allDirectives, allNodes } = visitTypeSources(typeSource, config);\n    const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config);\n    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config, mergedDirectives);\n    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: graphql_1.Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;\n        }\n    }\n    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config === null || config === void 0 ? void 0 : config.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => { var _a, _b; return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value); });\n    }\n    return mergedNodeDefinitions;\n}\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAGF,OAAO,CAACG,aAAa,GAAG,KAAK,CAAC;AAC1D,MAAMC,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAY,CAAC;AACxC,MAAME,gBAAgB,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMG,OAAO,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAC/C,MAAMI,eAAe,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AAClD,SAASF,aAAaA,CAACO,UAAU,EAAEC,MAAM,EAAE;EACvC,CAAC,CAAC,EAAEH,OAAO,CAACI,aAAa,EAAE,CAAC;EAC5B,MAAMC,GAAG,GAAG;IACRC,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACC,QAAQ;IAC7BC,WAAW,EAAEf,iBAAiB,CAACQ,UAAU,EAAE;MACvCQ,mBAAmB,EAAE,IAAI;MACzBC,qBAAqB,EAAE,KAAK;MAC5BC,eAAe,EAAE,KAAK;MACtBC,mBAAmB,EAAE,KAAK;MAC1B,GAAGV;IACP,CAAC;EACL,CAAC;EACD,IAAIW,MAAM;EACV,IAAIX,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACU,mBAAmB,EAAE;IAC5EC,MAAM,GAAG,CAAC,CAAC,EAAEd,OAAO,CAACe,iBAAiB,EAAEV,GAAG,CAAC;EAChD,CAAC,MACI;IACDS,MAAM,GAAGT,GAAG;EAChB;EACA,CAAC,CAAC,EAAEL,OAAO,CAACI,aAAa,EAAE,CAAC;EAC5B,OAAOU,MAAM;AACjB;AACAtB,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrC,SAASqB,gBAAgBA,CAACd,UAAU,EAAEe,OAAO,EAAEC,aAAa,GAAG,EAAE,EAAEC,QAAQ,GAAG,EAAE,EAAEC,kBAAkB,GAAG,IAAIC,GAAG,CAAC,CAAC,EAAE;EAC9G,IAAInB,UAAU,IAAI,CAACkB,kBAAkB,CAACE,GAAG,CAACpB,UAAU,CAAC,EAAE;IACnDkB,kBAAkB,CAACG,GAAG,CAACrB,UAAU,CAAC;IAClC,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;MAClCc,gBAAgB,CAACd,UAAU,CAAC,CAAC,EAAEe,OAAO,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,kBAAkB,CAAC;IACxF,CAAC,MACI,IAAII,KAAK,CAACC,OAAO,CAACvB,UAAU,CAAC,EAAE;MAChC,KAAK,MAAMwB,IAAI,IAAIxB,UAAU,EAAE;QAC3Bc,gBAAgB,CAACU,IAAI,EAAET,OAAO,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,kBAAkB,CAAC;MAChF;IACJ,CAAC,MACI,IAAI,CAAC,CAAC,EAAExB,SAAS,CAAC+B,QAAQ,EAAEzB,UAAU,CAAC,EAAE;MAC1C,MAAM0B,YAAY,GAAG,CAAC,CAAC,EAAE5B,OAAO,CAAC6B,yBAAyB,EAAE3B,UAAU,EAAEe,OAAO,CAAC;MAChFD,gBAAgB,CAACY,YAAY,CAACnB,WAAW,EAAEQ,OAAO,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,kBAAkB,CAAC;IACpG,CAAC,MACI,IAAI,CAAC,CAAC,EAAEtB,UAAU,CAACgC,aAAa,EAAE5B,UAAU,CAAC,IAAI,CAAC,CAAC,EAAEJ,UAAU,CAACiC,aAAa,EAAE7B,UAAU,CAAC,EAAE;MAC7F,MAAM0B,YAAY,GAAG,CAAC,CAAC,EAAEhC,SAAS,CAACoC,KAAK,EAAE9B,UAAU,EAAEe,OAAO,CAAC;MAC9DD,gBAAgB,CAACY,YAAY,CAACnB,WAAW,EAAEQ,OAAO,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,kBAAkB,CAAC;IACpG,CAAC,MACI,IAAI,OAAOlB,UAAU,KAAK,QAAQ,IAAI,CAAC,CAAC,EAAEN,SAAS,CAACqC,gBAAgB,EAAE/B,UAAU,CAAC,EAAE;MACpF,IAAIA,UAAU,CAACI,IAAI,KAAKV,SAAS,CAACW,IAAI,CAAC2B,oBAAoB,EAAE;QACzDhB,aAAa,CAACiB,IAAI,CAACjC,UAAU,CAAC;MAClC,CAAC,MACI;QACDiB,QAAQ,CAACgB,IAAI,CAACjC,UAAU,CAAC;MAC7B;IACJ,CAAC,MACI,IAAI,CAAC,CAAC,EAAEF,OAAO,CAACoC,cAAc,EAAElC,UAAU,CAAC,EAAE;MAC9Cc,gBAAgB,CAACd,UAAU,CAACO,WAAW,EAAEQ,OAAO,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,kBAAkB,CAAC;IAClG,CAAC,MACI;MACD,MAAM,IAAIiB,KAAK,CAAE,6EAA4E,OAAOnC,UAAW,EAAC,CAAC;IACrH;EACJ;EACA,OAAO;IAAEgB,aAAa;IAAEC;EAAS,CAAC;AACtC;AACA,SAASzB,iBAAiBA,CAACQ,UAAU,EAAEC,MAAM,EAAE;EAC3C,IAAImC,EAAE,EAAEC,EAAE,EAAEC,EAAE;EACd,CAAC,CAAC,EAAExC,OAAO,CAACI,aAAa,EAAE,CAAC;EAC5B,MAAM;IAAEc,aAAa;IAAEC;EAAS,CAAC,GAAGH,gBAAgB,CAACd,UAAU,EAAEC,MAAM,CAAC;EACxE,MAAMsC,gBAAgB,GAAG,CAAC,CAAC,EAAE1C,gBAAgB,CAAC2C,iBAAiB,EAAExB,aAAa,EAAEf,MAAM,CAAC;EACvF,MAAMwC,WAAW,GAAG,CAAC,CAAC,EAAE5C,gBAAgB,CAAC2C,iBAAiB,EAAEvB,QAAQ,EAAEhB,MAAM,EAAEsC,gBAAgB,CAAC;EAC/F,IAAItC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACO,mBAAmB,EAAE;IAC5E;IACA,MAAMkC,SAAS,GAAGD,WAAW,CAAC5C,gBAAgB,CAAC8C,eAAe,CAAC,IAAI;MAC/DvC,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACuC,iBAAiB;MACtCC,cAAc,EAAE;IACpB,CAAC;IACD,MAAMA,cAAc,GAAGH,SAAS,CAACG,cAAc;IAC/C,KAAK,MAAMC,iBAAiB,IAAI/C,eAAe,CAACgD,+BAA+B,EAAE;MAC7E,MAAMC,aAAa,GAAGH,cAAc,CAACI,IAAI,CAACC,aAAa,IAAIA,aAAa,CAACC,SAAS,KAAKL,iBAAiB,CAAC;MACzG,IAAI,CAACE,aAAa,EAAE;QAChB,MAAMI,oBAAoB,GAAGrD,eAAe,CAACgD,+BAA+B,CAACD,iBAAiB,CAAC;QAC/F,MAAMO,wBAAwB,GAAGZ,WAAW,CAACW,oBAAoB,CAAC;QAClE,IAAIC,wBAAwB,IAAI,IAAI,IAAIA,wBAAwB,CAACC,IAAI,IAAI,IAAI,EAAE;UAC3ET,cAAc,CAACZ,IAAI,CAAC;YAChB7B,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACkD,yBAAyB;YAC9C/B,IAAI,EAAE;cACFpB,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACmD,UAAU;cAC/BF,IAAI,EAAED,wBAAwB,CAACC;YACnC,CAAC;YACDH,SAAS,EAAEL;UACf,CAAC,CAAC;QACN;MACJ;IACJ;IACA,IAAI,CAAC,CAACV,EAAE,GAAGM,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACG,cAAc,MAAM,IAAI,IAAIT,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACqB,MAAM,KAAK,IAAI,IAAIf,SAAS,CAACG,cAAc,CAACY,MAAM,GAAG,CAAC,EAAE;MACvLhB,WAAW,CAAC5C,gBAAgB,CAAC8C,eAAe,CAAC,GAAGD,SAAS;IAC7D;EACJ;EACA,IAAI,CAACzC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACQ,qBAAqB,KAAK,EAAE,CAAC6B,EAAE,GAAG,CAACD,EAAE,GAAGI,WAAW,CAAC5C,gBAAgB,CAAC8C,eAAe,CAAC,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACQ,cAAc,MAAM,IAAI,IAAIP,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACmB,MAAM,CAAC,EAAE;IACxPhB,WAAW,CAAC5C,gBAAgB,CAAC8C,eAAe,CAAC,GAAG;MAC5CvC,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACuC,iBAAiB;MACtCC,cAAc,EAAE,CACZ;QACIzC,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACkD,yBAAyB;QAC9CJ,SAAS,EAAE,OAAO;QAClB3B,IAAI,EAAE;UACFpB,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACmD,UAAU;UAC/BF,IAAI,EAAE;YACFlD,IAAI,EAAEV,SAAS,CAACW,IAAI,CAACqD,IAAI;YACzBnE,KAAK,EAAE;UACX;QACJ;MACJ,CAAC;IAET,CAAC;EACL;EACA,MAAMoE,qBAAqB,GAAGvE,MAAM,CAACwE,MAAM,CAACnB,WAAW,CAAC;EACxD,IAAIxC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC4D,IAAI,EAAE;IAC7D,MAAMC,MAAM,GAAG,OAAO7D,MAAM,CAAC4D,IAAI,KAAK,UAAU,GAAG5D,MAAM,CAAC4D,IAAI,GAAGjE,UAAU,CAACmE,uBAAuB;IACnGJ,qBAAqB,CAACE,IAAI,CAAC,CAACG,CAAC,EAAEC,CAAC,KAAK;MAAE,IAAI7B,EAAE,EAAEC,EAAE;MAAE,OAAOyB,MAAM,CAAC,CAAC1B,EAAE,GAAG4B,CAAC,CAACV,IAAI,MAAM,IAAI,IAAIlB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC7C,KAAK,EAAE,CAAC8C,EAAE,GAAG4B,CAAC,CAACX,IAAI,MAAM,IAAI,IAAIjB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC9C,KAAK,CAAC;IAAE,CAAC,CAAC;EAClM;EACA,OAAOoE,qBAAqB;AAChC;AACArE,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB"},"metadata":{},"sourceType":"module"}