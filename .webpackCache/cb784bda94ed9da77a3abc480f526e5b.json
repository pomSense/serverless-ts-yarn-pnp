{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RuleFalse = exports.RuleTrue = exports.RuleNot = exports.RuleRace = exports.RuleChain = exports.RuleAnd = exports.RuleOr = exports.LogicRule = exports.InputRule = exports.Rule = void 0;\nconst Yup = require(\"yup\");\nconst utils_1 = require(\"./utils\");\nconst util_1 = require(\"util\");\nclass Rule {\n  constructor(name, func, constructorOptions) {\n    const options = this.normalizeOptions(constructorOptions);\n    this.name = name;\n    this.func = func;\n    this.cache = options.cache;\n    this.fragment = options.fragment;\n  }\n  /**\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   *\n   * Resolves rule and writes to cache its result.\n   *\n   */\n  async resolve(parent, args, ctx, info, options) {\n    try {\n      /* Resolve */\n      const res = await this.executeRule(parent, args, ctx, info, options);\n      if (res instanceof Error) {\n        return res;\n      } else if (typeof res === 'string') {\n        return new Error(res);\n      } else if (res === true) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (err) {\n      if (options.debug) {\n        throw err;\n      } else {\n        return false;\n      }\n    }\n  }\n  /**\n   *\n   * @param rule\n   *\n   * Compares a given rule with the current one\n   * and checks whether their functions are equal.\n   *\n   */\n  equals(rule) {\n    return this.func === rule.func;\n  }\n  /**\n   *\n   * Extracts fragment from the rule.\n   *\n   */\n  extractFragment() {\n    return this.fragment;\n  }\n  /**\n   *\n   * @param options\n   *\n   * Sets default values for options.\n   *\n   */\n  normalizeOptions(options) {\n    return {\n      cache: options.cache !== undefined ? this.normalizeCacheOption(options.cache) : 'no_cache',\n      fragment: options.fragment !== undefined ? options.fragment : undefined\n    };\n  }\n  /**\n   *\n   * @param cache\n   *\n   * This ensures backward capability of shield.\n   *\n   */\n  normalizeCacheOption(cache) {\n    switch (cache) {\n      case true:\n        {\n          return 'strict';\n        }\n      case false:\n        {\n          return 'no_cache';\n        }\n      default:\n        {\n          return cache;\n        }\n    }\n  }\n  /**\n   * Executes a rule and writes to cache if needed.\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   */\n  executeRule(parent, args, ctx, info, options) {\n    switch (typeof this.cache) {\n      case 'function':\n        {\n          /* User defined cache function. */\n          const key = `${this.name}-${this.cache(parent, args, ctx, info)}`;\n          return this.writeToCache(key)(parent, args, ctx, info);\n        }\n      case 'string':\n        {\n          /* Standard cache option. */\n          switch (this.cache) {\n            case 'strict':\n              {\n                const key = options.hashFunction({\n                  parent,\n                  args\n                });\n                return this.writeToCache(`${this.name}-${key}`)(parent, args, ctx, info);\n              }\n            case 'contextual':\n              {\n                return this.writeToCache(this.name)(parent, args, ctx, info);\n              }\n            case 'no_cache':\n              {\n                return this.func(parent, args, ctx, info);\n              }\n          }\n        }\n      /* istanbul ignore next */\n      default:\n        {\n          throw new Error(`Unsupported cache format: ${typeof this.cache}`);\n        }\n    }\n  }\n  /**\n   * Writes or reads result from cache.\n   *\n   * @param key\n   */\n  writeToCache(key) {\n    return (parent, args, ctx, info) => {\n      if (!ctx._shield.cache[key]) {\n        ctx._shield.cache[key] = this.func(parent, args, ctx, info);\n      }\n      return ctx._shield.cache[key];\n    };\n  }\n}\nexports.Rule = Rule;\nclass InputRule extends Rule {\n  constructor(name, schema, options) {\n    const validationFunction = (parent, args, ctx) => schema(Yup, ctx).validate(args, options).then(() => true).catch(err => err);\n    super(name, validationFunction, {\n      cache: 'strict',\n      fragment: undefined\n    });\n  }\n}\nexports.InputRule = InputRule;\nclass LogicRule {\n  constructor(rules) {\n    this.rules = rules;\n  }\n  /**\n   * By default logic rule resolves to false.\n   */\n  async resolve(parent, args, ctx, info, options) {\n    return false;\n  }\n  /**\n   * Evaluates all the rules.\n   */\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    const tasks = rules.map(rule => rule.resolve(parent, args, ctx, info, options));\n    return Promise.all(tasks);\n  }\n  /**\n   * Returns rules in a logic rule.\n   */\n  getRules() {\n    return this.rules;\n  }\n  /**\n   * Extracts fragments from the defined rules.\n   */\n  extractFragments() {\n    const fragments = this.rules.reduce((fragments, rule) => {\n      if (utils_1.isLogicRule(rule)) {\n        return fragments.concat(...rule.extractFragments());\n      }\n      const fragment = rule.extractFragment();\n      if (fragment) return fragments.concat(fragment);\n      return fragments;\n    }, []);\n    return fragments;\n  }\n}\nexports.LogicRule = LogicRule;\n// Extended Types\nclass RuleOr extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that at least one of them has evaluated to true.\n   */\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n    if (result.every(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n}\nexports.RuleOr = RuleOr;\nclass RuleAnd extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that all of them have resolved to true.\n   */\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n    if (result.some(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n}\nexports.RuleAnd = RuleAnd;\nclass RuleChain extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that all of them have resolved to true.\n   */\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n    if (result.some(res => res !== true)) {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Evaluates all the rules.\n   */\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    return iterate(rules);\n    async function iterate([rule, ...otherRules]) {\n      if (util_1.isUndefined(rule)) return [];\n      return rule.resolve(parent, args, ctx, info, options).then(res => {\n        if (res !== true) {\n          return [res];\n        } else {\n          return iterate(otherRules).then(ress => ress.concat(res));\n        }\n      });\n    }\n  }\n}\nexports.RuleChain = RuleChain;\nclass RuleRace extends LogicRule {\n  constructor(rules) {\n    super(rules);\n  }\n  /**\n   * Makes sure that at least one of them resolved to true.\n   */\n  async resolve(parent, args, ctx, info, options) {\n    const result = await this.evaluate(parent, args, ctx, info, options);\n    if (result.some(res => res === true)) {\n      return true;\n    } else {\n      const customError = result.find(res => res instanceof Error);\n      return customError || false;\n    }\n  }\n  /**\n   * Evaluates all the rules.\n   */\n  async evaluate(parent, args, ctx, info, options) {\n    const rules = this.getRules();\n    return iterate(rules);\n    async function iterate([rule, ...otherRules]) {\n      if (util_1.isUndefined(rule)) return [];\n      return rule.resolve(parent, args, ctx, info, options).then(res => {\n        if (res === true) {\n          return [res];\n        } else {\n          return iterate(otherRules).then(ress => ress.concat(res));\n        }\n      });\n    }\n  }\n}\nexports.RuleRace = RuleRace;\nclass RuleNot extends LogicRule {\n  constructor(rule, error) {\n    super([rule]);\n    this.error = error;\n  }\n  /**\n   *\n   * @param parent\n   * @param args\n   * @param ctx\n   * @param info\n   *\n   * Negates the result.\n   *\n   */\n  async resolve(parent, args, ctx, info, options) {\n    const [res] = await this.evaluate(parent, args, ctx, info, options);\n    if (res instanceof Error) {\n      return true;\n    } else if (res !== true) {\n      return true;\n    } else {\n      if (this.error) return this.error;\n      return false;\n    }\n  }\n}\nexports.RuleNot = RuleNot;\nclass RuleTrue extends LogicRule {\n  constructor() {\n    super([]);\n  }\n  /**\n   *\n   * Always true.\n   *\n   */\n  async resolve() {\n    return true;\n  }\n}\nexports.RuleTrue = RuleTrue;\nclass RuleFalse extends LogicRule {\n  constructor() {\n    super([]);\n  }\n  /**\n   *\n   * Always false.\n   *\n   */\n  async resolve() {\n    return false;\n  }\n}\nexports.RuleFalse = RuleFalse;","map":{"version":3,"mappings":"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","names":["Yup","require","utils_1","util_1","Rule","constructor","name","func","constructorOptions","options","normalizeOptions","cache","fragment","resolve","parent","args","ctx","info","res","executeRule","Error","err","debug","equals","rule","extractFragment","undefined","normalizeCacheOption","key","writeToCache","hashFunction","_shield","exports","InputRule","schema","validationFunction","validate","then","catch","LogicRule","rules","evaluate","getRules","tasks","map","Promise","all","extractFragments","fragments","reduce","isLogicRule","concat","RuleOr","result","every","customError","find","RuleAnd","some","RuleChain","iterate","otherRules","isUndefined","ress","RuleRace","RuleNot","error","RuleTrue","RuleFalse"],"sourceRoot":"","sources":["../src/rules.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}