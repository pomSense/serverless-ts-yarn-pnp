{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deny = exports.allow = exports.not = exports.or = exports.race = exports.chain = exports.and = exports.inputRule = exports.rule = void 0;\nconst rules_1 = require(\"./rules\");\n/**\n *\n * @param name\n * @param options\n *\n * Wraps a function into a Rule class. This way we can identify rules\n * once we start generating middleware from our ruleTree.\n *\n * 1.\n * const auth = rule()(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n * 2.\n * const auth = rule('name')(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n * 3.\n * const auth = rule({\n *  name: 'name',\n *  fragment: 'string',\n *  cache: 'cache',\n * })(async (parent, args, ctx, info) => {\n *  return true\n * })\n *\n */\nconst rule = (name, options) => func => {\n  if (typeof name === 'object') {\n    options = name;\n    name = Math.random().toString();\n  } else if (typeof name === 'string') {\n    options = options || {};\n  } else {\n    name = Math.random().toString();\n    options = {};\n  }\n  return new rules_1.Rule(name, func, {\n    fragment: options.fragment,\n    cache: options.cache\n  });\n};\nexports.rule = rule;\n/**\n *\n * Constructs a new InputRule based on the schema.\n *\n * @param schema\n */\nconst inputRule = name => (schema, options) => {\n  if (typeof name === 'string') {\n    return new rules_1.InputRule(name, schema, options);\n  } else {\n    return new rules_1.InputRule(Math.random().toString(), schema, options);\n  }\n};\nexports.inputRule = inputRule;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\nconst and = (...rules) => {\n  return new rules_1.RuleAnd(rules);\n};\nexports.and = and;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\nconst chain = (...rules) => {\n  return new rules_1.RuleChain(rules);\n};\nexports.chain = chain;\n/**\n *\n * @param rules\n *\n * Logical operator and serves as a wrapper for and operation.\n *\n */\nconst race = (...rules) => {\n  return new rules_1.RuleRace(rules);\n};\nexports.race = race;\n/**\n *\n * @param rules\n *\n * Logical operator or serves as a wrapper for or operation.\n *\n */\nconst or = (...rules) => {\n  return new rules_1.RuleOr(rules);\n};\nexports.or = or;\n/**\n *\n * @param rule\n *\n * Logical operator not serves as a wrapper for not operation.\n *\n */\nconst not = (rule, error) => {\n  if (typeof error === 'string') return new rules_1.RuleNot(rule, new Error(error));\n  return new rules_1.RuleNot(rule, error);\n};\nexports.not = not;\n/**\n *\n * Allow queries.\n *\n */\nexports.allow = new rules_1.RuleTrue();\n/**\n *\n * Deny queries.\n *\n */\nexports.deny = new rules_1.RuleFalse();","map":{"version":3,"mappings":";;;;;;AAOA,MAAAA,OAAA,GAAAC,OAAA;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BO,MAAMC,IAAI,GAAGA,CAClBC,IAAuC,EACvCC,OAAiC,KAC7BC,IAAmB,IAAU;EACjC,IAAI,OAAOF,IAAI,KAAK,QAAQ,EAAE;IAC5BC,OAAO,GAAGD,IAAI;IACdA,IAAI,GAAGG,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,EAAE;GAChC,MAAM,IAAI,OAAOL,IAAI,KAAK,QAAQ,EAAE;IACnCC,OAAO,GAAGA,OAAO,IAAI,EAAE;GACxB,MAAM;IACLD,IAAI,GAAGG,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,EAAE;IAC/BJ,OAAO,GAAG,EAAE;;EAGd,OAAO,IAAIJ,OAAA,CAAAS,IAAI,CAACN,IAAI,EAAEE,IAAI,EAAE;IAC1BK,QAAQ,EAAEN,OAAO,CAACM,QAAQ;IAC1BC,KAAK,EAAEP,OAAO,CAACO;GAChB,CAAC;AACJ,CAAC;AAlBYC,OAAA,CAAAV,IAAI,GAAAA,IAAA;AAoBjB;;;;;;AAMO,MAAMW,SAAS,GAAOV,IAAa,IAAK,CAC7CW,MAA+D,EAC/DV,OAA6B,KAC3B;EACF,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,IAAIH,OAAA,CAAAe,SAAS,CAACZ,IAAI,EAAEW,MAAM,EAAEV,OAAO,CAAC;GAC5C,MAAM;IACL,OAAO,IAAIJ,OAAA,CAAAe,SAAS,CAACT,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,EAAE,EAAEM,MAAM,EAAEV,OAAO,CAAC;;AAEnE,CAAC;AATYQ,OAAA,CAAAC,SAAS,GAAAA,SAAA;AAWtB;;;;;;;AAOO,MAAMG,GAAG,GAAGA,CAAC,GAAGC,KAAmB,KAAa;EACrD,OAAO,IAAIjB,OAAA,CAAAkB,OAAO,CAACD,KAAK,CAAC;AAC3B,CAAC;AAFYL,OAAA,CAAAI,GAAG,GAAAA,GAAA;AAIhB;;;;;;;AAOO,MAAMG,KAAK,GAAGA,CAAC,GAAGF,KAAmB,KAAe;EACzD,OAAO,IAAIjB,OAAA,CAAAoB,SAAS,CAACH,KAAK,CAAC;AAC7B,CAAC;AAFYL,OAAA,CAAAO,KAAK,GAAAA,KAAA;AAIlB;;;;;;;AAOO,MAAME,IAAI,GAAGA,CAAC,GAAGJ,KAAmB,KAAc;EACvD,OAAO,IAAIjB,OAAA,CAAAsB,QAAQ,CAACL,KAAK,CAAC;AAC5B,CAAC;AAFYL,OAAA,CAAAS,IAAI,GAAAA,IAAA;AAIjB;;;;;;;AAOO,MAAME,EAAE,GAAGA,CAAC,GAAGN,KAAmB,KAAY;EACnD,OAAO,IAAIjB,OAAA,CAAAwB,MAAM,CAACP,KAAK,CAAC;AAC1B,CAAC;AAFYL,OAAA,CAAAW,EAAE,GAAAA,EAAA;AAIf;;;;;;;AAOO,MAAME,GAAG,GAAGA,CAACvB,IAAgB,EAAEwB,KAAsB,KAAa;EACvE,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAO,IAAI1B,OAAA,CAAA2B,OAAO,CAACzB,IAAI,EAAE,IAAI0B,KAAK,CAACF,KAAK,CAAC,CAAC;EACzE,OAAO,IAAI1B,OAAA,CAAA2B,OAAO,CAACzB,IAAI,EAAEwB,KAAK,CAAC;AACjC,CAAC;AAHYd,OAAA,CAAAa,GAAG,GAAAA,GAAA;AAKhB;;;;;AAKab,OAAA,CAAAiB,KAAK,GAAG,IAAI7B,OAAA,CAAA8B,QAAQ,EAAE;AAEnC;;;;;AAKalB,OAAA,CAAAmB,IAAI,GAAG,IAAI/B,OAAA,CAAAgC,SAAS,EAAE","names":["rules_1","require","rule","name","options","func","Math","random","toString","Rule","fragment","cache","exports","inputRule","schema","InputRule","and","rules","RuleAnd","chain","RuleChain","race","RuleRace","or","RuleOr","not","error","RuleNot","Error","allow","RuleTrue","deny","RuleFalse"],"sourceRoot":"","sources":["../src/constructors.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}