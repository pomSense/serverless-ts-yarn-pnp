{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEnumTypeSpecification = exports.createUnionTypeSpecification = exports.createObjectTypeSpecification = exports.createScalarTypeSpecification = exports.createDirectiveSpecification = void 0;\nconst graphql_1 = require(\"graphql\");\nconst definitions_1 = require(\"./definitions\");\nconst error_1 = require(\"./error\");\nconst values_1 = require(\"./values\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nfunction createDirectiveSpecification({\n  name,\n  locations,\n  repeatable = false,\n  args = [],\n  composes = false,\n  supergraphSpecification = undefined\n}) {\n  let composition = undefined;\n  if (composes) {\n    (0, utils_1.assert)(supergraphSpecification, `Should provide a @link specification to use in supergraph for directive @${name} if it composes`);\n    const argStrategies = new Map(args.filter(arg => arg.compositionStrategy).map(arg => [arg.name, arg.compositionStrategy]));\n    let argumentsMerger = undefined;\n    if (argStrategies.size > 0) {\n      (0, utils_1.assert)(!repeatable, () => `Invalid directive specification for @${name}: @${name} is repeatable and should not define composition strategy for its arguments`);\n      (0, utils_1.assert)(argStrategies.size === args.length, () => `Invalid directive specification for @${name}: not all arguments define a composition strategy`);\n      argumentsMerger = (schema, feature) => {\n        for (const {\n          name: argName,\n          type\n        } of args) {\n          const strategy = argStrategies.get(argName);\n          (0, utils_1.assert)(strategy, () => `Should have a strategy for ${argName}`);\n          const argType = type(schema, feature);\n          (0, utils_1.assert)(!Array.isArray(argType), () => `Should have gotten error getting type for @${name}(${argName}:), but got ${argType}`);\n          const {\n            valid,\n            supportedMsg\n          } = strategy.isTypeSupported(schema, argType);\n          if (!valid) {\n            return new graphql_1.GraphQLError(`Invalid composition strategy ${strategy.name} for argument @${name}(${argName}:) of type ${argType}; ` + `${strategy.name} only supports ${supportedMsg}`);\n          }\n        }\n        ;\n        return {\n          merge: (argName, values) => {\n            const strategy = argStrategies.get(argName);\n            (0, utils_1.assert)(strategy, () => `Should have a strategy for ${argName}`);\n            return strategy.mergeValues(values);\n          },\n          toString: () => {\n            if (argStrategies.size === 0) {\n              return \"<none>\";\n            }\n            return '{ ' + [...argStrategies.entries()].map(([arg, strategy]) => `\"${arg}\": ${strategy.name}`).join(', ') + ' }';\n          }\n        };\n      };\n    }\n    composition = {\n      supergraphSpecification,\n      argumentsMerger\n    };\n  }\n  return {\n    name,\n    composition,\n    checkOrAdd: (schema, feature, asBuiltIn) => {\n      var _a;\n      const actualName = (_a = feature === null || feature === void 0 ? void 0 : feature.directiveNameInSchema(name)) !== null && _a !== void 0 ? _a : name;\n      const {\n        resolvedArgs,\n        errors\n      } = args.reduce(({\n        resolvedArgs,\n        errors\n      }, arg) => {\n        const typeOrErrors = arg.type(schema, feature);\n        if (Array.isArray(typeOrErrors)) {\n          errors.push(...typeOrErrors);\n        } else {\n          resolvedArgs.push({\n            ...arg,\n            type: typeOrErrors\n          });\n        }\n        return {\n          resolvedArgs,\n          errors\n        };\n      }, {\n        resolvedArgs: [],\n        errors: []\n      });\n      if (errors.length > 0) {\n        return errors;\n      }\n      const existing = schema.directive(actualName);\n      if (existing) {\n        return ensureSameDirectiveStructure({\n          name: actualName,\n          locations,\n          repeatable,\n          args: resolvedArgs\n        }, existing);\n      } else {\n        const directive = schema.addDirectiveDefinition(new definitions_1.DirectiveDefinition(actualName, asBuiltIn));\n        directive.repeatable = repeatable;\n        directive.addLocations(...locations);\n        for (const {\n          name,\n          type,\n          defaultValue\n        } of resolvedArgs) {\n          directive.addArgument(name, type, defaultValue);\n        }\n        return [];\n      }\n    }\n  };\n}\nexports.createDirectiveSpecification = createDirectiveSpecification;\nfunction createScalarTypeSpecification({\n  name\n}) {\n  return {\n    name,\n    checkOrAdd: (schema, feature, asBuiltIn) => {\n      var _a;\n      const actualName = (_a = feature === null || feature === void 0 ? void 0 : feature.typeNameInSchema(name)) !== null && _a !== void 0 ? _a : name;\n      const existing = schema.type(actualName);\n      if (existing) {\n        return ensureSameTypeKind('ScalarType', existing);\n      } else {\n        schema.addType(new definitions_1.ScalarType(actualName, asBuiltIn));\n        return [];\n      }\n    }\n  };\n}\nexports.createScalarTypeSpecification = createScalarTypeSpecification;\nfunction createObjectTypeSpecification({\n  name,\n  fieldsFct\n}) {\n  return {\n    name,\n    checkOrAdd: (schema, feature, asBuiltIn) => {\n      var _a;\n      const actualName = (_a = feature === null || feature === void 0 ? void 0 : feature.typeNameInSchema(name)) !== null && _a !== void 0 ? _a : name;\n      const expectedFields = fieldsFct(schema);\n      const existing = schema.type(actualName);\n      if (existing) {\n        let errors = ensureSameTypeKind('ObjectType', existing);\n        if (errors.length > 0) {\n          return errors;\n        }\n        (0, utils_1.assert)((0, definitions_1.isObjectType)(existing), 'Should be an object type');\n        for (const {\n          name,\n          type,\n          args\n        } of expectedFields) {\n          const existingField = existing.field(name);\n          if (!existingField) {\n            errors = errors.concat(error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition of type ${name}: missing field ${name}`, {\n              nodes: existing.sourceAST\n            }));\n            continue;\n          }\n          let existingType = existingField.type;\n          if (!(0, definitions_1.isNonNullType)(type) && (0, definitions_1.isNonNullType)(existingType)) {\n            existingType = existingType.ofType;\n          }\n          if (!(0, types_1.sameType)(type, existingType)) {\n            errors = errors.concat(error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition for field ${name} of type ${name}: should have type ${type} but found type ${existingField.type}`, {\n              nodes: existingField.sourceAST\n            }));\n          }\n          errors = errors.concat(ensureSameArguments({\n            name,\n            args\n          }, existingField, `field \"${existingField.coordinate}\"`));\n        }\n        return errors;\n      } else {\n        const createdType = schema.addType(new definitions_1.ObjectType(actualName, asBuiltIn));\n        for (const {\n          name,\n          type,\n          args\n        } of expectedFields) {\n          const field = createdType.addField(name, type);\n          for (const {\n            name: argName,\n            type: argType,\n            defaultValue\n          } of args !== null && args !== void 0 ? args : []) {\n            field.addArgument(argName, argType, defaultValue);\n          }\n        }\n        return [];\n      }\n    }\n  };\n}\nexports.createObjectTypeSpecification = createObjectTypeSpecification;\nfunction createUnionTypeSpecification({\n  name,\n  membersFct\n}) {\n  return {\n    name,\n    checkOrAdd: (schema, feature, asBuiltIn) => {\n      var _a;\n      const actualName = (_a = feature === null || feature === void 0 ? void 0 : feature.typeNameInSchema(name)) !== null && _a !== void 0 ? _a : name;\n      const existing = schema.type(actualName);\n      const expectedMembers = membersFct(schema).sort((n1, n2) => n1.localeCompare(n2));\n      if (expectedMembers.length === 0) {\n        if (existing) {\n          return [error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition of type ${name}: expected the union type to not exist/have no members but it is defined.`, {\n            nodes: existing.sourceAST\n          })];\n        }\n        return [];\n      }\n      if (existing) {\n        let errors = ensureSameTypeKind('UnionType', existing);\n        if (errors.length > 0) {\n          return errors;\n        }\n        (0, utils_1.assert)((0, definitions_1.isUnionType)(existing), 'Should be an union type');\n        const actualMembers = existing.members().map(m => m.type.name).sort((n1, n2) => n1.localeCompare(n2));\n        if (!(0, utils_1.arrayEquals)(expectedMembers, actualMembers)) {\n          errors = errors.concat(error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition of type ${name}: expected members [${expectedMembers}] but found [${actualMembers}].`, {\n            nodes: existing.sourceAST\n          }));\n        }\n        return errors;\n      } else {\n        const type = schema.addType(new definitions_1.UnionType(actualName, asBuiltIn));\n        for (const member of expectedMembers) {\n          type.addType(member);\n        }\n        return [];\n      }\n    }\n  };\n}\nexports.createUnionTypeSpecification = createUnionTypeSpecification;\nfunction createEnumTypeSpecification({\n  name,\n  values\n}) {\n  return {\n    name,\n    checkOrAdd: (schema, feature, asBuiltIn) => {\n      var _a;\n      const actualName = (_a = feature === null || feature === void 0 ? void 0 : feature.typeNameInSchema(name)) !== null && _a !== void 0 ? _a : name;\n      const existing = schema.type(actualName);\n      const expectedValueNames = values.map(v => v.name).sort((n1, n2) => n1.localeCompare(n2));\n      if (existing) {\n        let errors = ensureSameTypeKind('EnumType', existing);\n        if (errors.length > 0) {\n          return errors;\n        }\n        (0, utils_1.assert)((0, definitions_1.isEnumType)(existing), 'Should be an enum type');\n        const actualValueNames = existing.values.map(v => v.name).sort((n1, n2) => n1.localeCompare(n2));\n        if (!(0, utils_1.arrayEquals)(expectedValueNames, actualValueNames)) {\n          errors = errors.concat(error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition for type \"${name}\": expected values [${expectedValueNames.join(', ')}] but found [${actualValueNames.join(', ')}].`, {\n            nodes: existing.sourceAST\n          }));\n        }\n        return errors;\n      } else {\n        const type = schema.addType(new definitions_1.EnumType(actualName, asBuiltIn));\n        for (const {\n          name,\n          description\n        } of values) {\n          type.addValue(name).description = description;\n        }\n        return [];\n      }\n    }\n  };\n}\nexports.createEnumTypeSpecification = createEnumTypeSpecification;\nfunction ensureSameTypeKind(expected, actual) {\n  return expected === actual.kind ? [] : [error_1.ERRORS.TYPE_DEFINITION_INVALID.err(`Invalid definition for type ${actual.name}: ${actual.name} should be a ${expected} but is defined as a ${actual.kind}`, {\n    nodes: actual.sourceAST\n  })];\n}\nfunction ensureSameDirectiveStructure(expected, actual) {\n  const directiveName = `\"@${expected.name}\"`;\n  let errors = ensureSameArguments(expected, actual, `directive ${directiveName}`);\n  if (!expected.repeatable && actual.repeatable) {\n    errors = errors.concat(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for directive ${directiveName}: ${directiveName} should${expected.repeatable ? \"\" : \" not\"} be repeatable`, {\n      nodes: actual.sourceAST\n    }));\n  }\n  if (!actual.locations.every(loc => expected.locations.includes(loc))) {\n    errors = errors.concat(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for directive ${directiveName}: ${directiveName} should have locations ${expected.locations.join(', ')}, but found (non-subset) ${actual.locations.join(', ')}`, {\n      nodes: actual.sourceAST\n    }));\n  }\n  return errors;\n}\nfunction ensureSameArguments(expected, actual, what, containerSourceAST) {\n  var _a;\n  const expectedArguments = (_a = expected.args) !== null && _a !== void 0 ? _a : [];\n  const errors = [];\n  for (const {\n    name,\n    type,\n    defaultValue\n  } of expectedArguments) {\n    const actualArgument = actual.argument(name);\n    if (!actualArgument) {\n      if ((0, definitions_1.isNonNullType)(type) && defaultValue === undefined) {\n        errors.push(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for ${what}: missing required argument \"${name}\"`, {\n          nodes: containerSourceAST\n        }));\n      }\n      continue;\n    }\n    let actualType = actualArgument.type;\n    if ((0, definitions_1.isNonNullType)(actualType) && !(0, definitions_1.isNonNullType)(type)) {\n      actualType = actualType.ofType;\n    }\n    if (!(0, types_1.sameType)(type, actualType) && !isValidInputTypeRedefinition(type, actualType)) {\n      errors.push(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for ${what}: argument \"${name}\" should have type \"${type}\" but found type \"${actualArgument.type}\"`, {\n        nodes: actualArgument.sourceAST\n      }));\n    } else if (!(0, definitions_1.isNonNullType)(actualArgument.type) && !(0, values_1.valueEquals)(defaultValue, actualArgument.defaultValue)) {\n      errors.push(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for ${what}: argument \"${name}\" should have default value ${(0, values_1.valueToString)(defaultValue)} but found default value ${(0, values_1.valueToString)(actualArgument.defaultValue)}`, {\n        nodes: actualArgument.sourceAST\n      }));\n    }\n  }\n  for (const actualArgument of actual.arguments()) {\n    if (!expectedArguments.some(arg => arg.name === actualArgument.name)) {\n      errors.push(error_1.ERRORS.DIRECTIVE_DEFINITION_INVALID.err(`Invalid definition for ${what}: unknown/unsupported argument \"${actualArgument.name}\"`, {\n        nodes: actualArgument.sourceAST\n      }));\n    }\n  }\n  return errors;\n}\nfunction isValidInputTypeRedefinition(expectedType, actualType) {\n  if ((0, definitions_1.isListType)(expectedType)) {\n    return (0, definitions_1.isListType)(actualType) && isValidInputTypeRedefinition(expectedType.ofType, actualType.ofType);\n  }\n  if ((0, definitions_1.isNonNullType)(expectedType)) {\n    return (0, definitions_1.isNonNullType)(actualType) && isValidInputTypeRedefinition(expectedType.ofType, actualType.ofType);\n  }\n  return (0, definitions_1.isCustomScalarType)(expectedType) && !(0, definitions_1.isCustomScalarType)(actualType);\n}","map":{"version":3,"mappings":"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","names":["graphql_1","require","definitions_1","error_1","values_1","types_1","utils_1","createDirectiveSpecification","name","locations","repeatable","args","composes","supergraphSpecification","undefined","composition","assert","argStrategies","Map","filter","arg","compositionStrategy","map","argumentsMerger","size","length","schema","feature","argName","type","strategy","get","argType","Array","isArray","valid","supportedMsg","isTypeSupported","GraphQLError","merge","values","mergeValues","toString","entries","join","checkOrAdd","asBuiltIn","actualName","_a","directiveNameInSchema","resolvedArgs","errors","reduce","typeOrErrors","push","existing","directive","ensureSameDirectiveStructure","addDirectiveDefinition","DirectiveDefinition","addLocations","defaultValue","addArgument","exports","createScalarTypeSpecification","typeNameInSchema","ensureSameTypeKind","addType","ScalarType","createObjectTypeSpecification","fieldsFct","expectedFields","isObjectType","existingField","field","concat","ERRORS","TYPE_DEFINITION_INVALID","err","nodes","sourceAST","existingType","isNonNullType","ofType","sameType","ensureSameArguments","coordinate","createdType","ObjectType","addField","createUnionTypeSpecification","membersFct","expectedMembers","sort","n1","n2","localeCompare","isUnionType","actualMembers","members","m","arrayEquals","UnionType","member","createEnumTypeSpecification","expectedValueNames","v","isEnumType","actualValueNames","EnumType","description","addValue","expected","actual","kind","directiveName","DIRECTIVE_DEFINITION_INVALID","every","loc","includes","what","containerSourceAST","expectedArguments","actualArgument","argument","actualType","isValidInputTypeRedefinition","valueEquals","valueToString","arguments","some","expectedType","isListType","isCustomScalarType"],"sourceRoot":"","sources":["../src/directiveAndTypeSpecification.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}