{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIn = getIn;\nvar _propertyExpr = require(\"property-expr\");\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\nfunction getIn(schema, path, value, context) {\n  if (context === void 0) {\n    context = value;\n  }\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n      }\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\nexports.default = reach;","map":{"version":3,"names":["getIn","_propertyExpr","require","trim","part","substr","length","schema","path","value","context","parent","lastPart","lastPartDebug","parentPath","forEach","_part","isBracket","isArray","resolve","innerType","idx","parseInt","Error","fields","_type","reach","obj","exports","default"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/yup-npm-0.31.1-e4cae13a77-79bf28d6af.zip/node_modules/yup/es/util/reach.js"],"sourcesContent":["import { forEach } from 'property-expr';\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nexport function getIn(schema, path, value, context) {\n  if (context === void 0) {\n    context = value;\n  }\n\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  forEach(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nexport default reach;"],"mappings":";;;;;QAMgBA,KAAK,GAALA,KAAK;AANrB,IAAAC,aAAA,GAAAC,OAAA;AAEA,IAAIC,IAAI,GAAG,SAASA,IAAIA,CAACC,IAAI,EAAE;EAC7B,OAAOA,IAAI,CAACC,MAAM,CAAC,CAAC,EAAED,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC,CAACD,MAAM,CAAC,CAAC,CAAC;AAClD,CAAC;AAEM,SAASL,KAAKA,CAACO,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAClD,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IACtBA,OAAO,GAAGD,KAAK;EACjB;EAEA,IAAIE,MAAM,EAAEC,QAAQ,EAAEC,aAAa,CAAC,CAAC;;EAErC,IAAI,CAACL,IAAI,EAAE,OAAO;IAChBG,MAAM,EAAEA,MAAM;IACdG,UAAU,EAAEN,IAAI;IAChBD,MAAM,EAAEA;EACV,CAAC;EACD,IAAAQ,qBAAO,EAACP,IAAI,EAAE,UAAUQ,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACjD,IAAId,IAAI,GAAGa,SAAS,GAAGd,IAAI,CAACa,KAAK,CAAC,GAAGA,KAAK;IAC1CT,MAAM,GAAGA,MAAM,CAACY,OAAO,CAAC;MACtBT,OAAO,EAAEA,OAAO;MAChBC,MAAM,EAAEA,MAAM;MACdF,KAAK,EAAEA;IACT,CAAC,CAAC;IAEF,IAAIF,MAAM,CAACa,SAAS,EAAE;MACpB,IAAIC,GAAG,GAAGH,OAAO,GAAGI,QAAQ,CAAClB,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC;MAE1C,IAAIK,KAAK,IAAIY,GAAG,IAAIZ,KAAK,CAACH,MAAM,EAAE;QAChC,MAAM,IAAIiB,KAAK,CAAC,mDAAmD,GAAGP,KAAK,GAAG,iBAAiB,GAAGR,IAAI,GAAG,IAAI,GAAG,2CAA2C,CAAC;MAC9J;MAEAG,MAAM,GAAGF,KAAK;MACdA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACY,GAAG,CAAC;MAC3Bd,MAAM,GAAGA,MAAM,CAACa,SAAS;IAC3B,CAAC,CAAC;IACF;IACA;IACA;;IAGA,IAAI,CAACF,OAAO,EAAE;MACZ,IAAI,CAACX,MAAM,CAACiB,MAAM,IAAI,CAACjB,MAAM,CAACiB,MAAM,CAACpB,IAAI,CAAC,EAAE,MAAM,IAAImB,KAAK,CAAC,wCAAwC,GAAGf,IAAI,GAAG,IAAI,IAAI,cAAc,GAAGK,aAAa,GAAG,sBAAsB,GAAGN,MAAM,CAACkB,KAAK,GAAG,KAAK,CAAC,CAAC;MACtMd,MAAM,GAAGF,KAAK;MACdA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACL,IAAI,CAAC;MAC5BG,MAAM,GAAGA,MAAM,CAACiB,MAAM,CAACpB,IAAI,CAAC;IAC9B;IAEAQ,QAAQ,GAAGR,IAAI;IACfS,aAAa,GAAGI,SAAS,GAAG,GAAG,GAAGD,KAAK,GAAG,GAAG,GAAG,GAAG,GAAGA,KAAK;EAC7D,CAAC,CAAC;EACF,OAAO;IACLT,MAAM,EAAEA,MAAM;IACdI,MAAM,EAAEA,MAAM;IACdG,UAAU,EAAEF;EACd,CAAC;AACH;AAEA,IAAIc,KAAK,GAAG,SAASA,KAAKA,CAACC,GAAG,EAAEnB,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EACpD,OAAOV,KAAK,CAAC2B,GAAG,EAAEnB,IAAI,EAAEC,KAAK,EAAEC,OAAO,CAAC,CAACH,MAAM;AAChD,CAAC;AAACqB,OAAA,CAAAC,OAAA,GAEaH,KAAK"},"metadata":{},"sourceType":"module"}