{"ast":null,"code":"\"use strict\";\n\nconst util = require('util');\nconst ServerlessRequest = require('./request');\nconst ServerlessResponse = require('./response');\nconst {\n  getEventSource\n} = require('./event-sources');\nconst Response = require('./response');\nconst isBinary = require('./is-binary');\nfunction forwardResponse({\n  binarySettings,\n  response,\n  resolver,\n  eventSource,\n  event,\n  log\n}) {\n  const statusCode = response.statusCode;\n  const headers = Response.headers(response);\n  const isBase64Encoded = isBinary({\n    headers,\n    binarySettings\n  });\n  const encoding = isBase64Encoded ? 'base64' : 'utf8';\n  const body = Response.body(response).toString(encoding);\n  const logBody = isBase64Encoded ? '[BASE64_ENCODED]' : body;\n  log.debug('SERVERLESS_EXPRESS:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE_PARAMS', {\n    statusCode,\n    body: logBody,\n    headers,\n    isBase64Encoded\n  });\n  const successResponse = eventSource.getResponse({\n    event,\n    statusCode,\n    body,\n    headers,\n    isBase64Encoded,\n    response\n  });\n  log.debug('SERVERLESS_EXPRESS:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE', () => ({\n    successResponse: util.inspect(successResponse, {\n      depth: null\n    }),\n    body: logBody\n  }));\n  resolver.succeed({\n    response: successResponse\n  });\n}\nfunction respondToEventSourceWithError({\n  error,\n  resolver,\n  log,\n  respondWithErrors,\n  eventSourceName,\n  eventSource\n}) {\n  log.error('SERVERLESS_EXPRESS:RESPOND_TO_EVENT_SOURCE_WITH_ERROR', error);\n  if (eventSourceName !== 'AWS_ALB' && eventSourceName !== 'AWS_LAMBDA_EDGE' && eventSourceName !== 'AWS_API_GATEWAY_V1' && eventSourceName !== 'AWS_API_GATEWAY_V2' && eventSourceName !== 'AZURE_HTTP_FUNCTION_V3' && eventSourceName !== 'AZURE_HTTP_FUNCTION_V4') {\n    resolver.fail({\n      error\n    });\n    return;\n  }\n  const body = respondWithErrors ? error.stack : '';\n  const errorResponse = eventSource.getResponse({\n    statusCode: 500,\n    body,\n    headers: {},\n    isBase64Encoded: false\n  });\n  resolver.succeed({\n    response: errorResponse\n  });\n}\nasync function getRequestResponse({\n  method,\n  headers,\n  body,\n  remoteAddress,\n  path\n}) {\n  const request = new ServerlessRequest({\n    method,\n    headers,\n    body,\n    remoteAddress,\n    url: path\n  });\n  await waitForStreamComplete(request);\n  const response = new ServerlessResponse(request);\n  return {\n    request,\n    response\n  };\n}\nfunction waitForStreamComplete(stream) {\n  if (stream.complete || stream.writableEnded) {\n    return stream;\n  }\n  return new Promise((resolve, reject) => {\n    stream.once('error', complete);\n    stream.once('end', complete);\n    stream.once('finish', complete);\n    let isComplete = false;\n    function complete(err) {\n      if (isComplete) {\n        return;\n      }\n      isComplete = true;\n      stream.removeListener('error', complete);\n      stream.removeListener('end', complete);\n      stream.removeListener('finish', complete);\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stream);\n      }\n    }\n  });\n}\nasync function forwardRequestToNodeServer({\n  app,\n  framework,\n  event,\n  context,\n  resolver,\n  eventSourceName,\n  binarySettings,\n  eventSource = getEventSource({\n    eventSourceName\n  }),\n  eventSourceRoutes,\n  log\n}) {\n  const requestValues = eventSource.getRequest({\n    event,\n    context,\n    log\n  });\n  if (!requestValues.path && eventSourceRoutes[eventSourceName]) {\n    requestValues.path = eventSourceRoutes[eventSourceName];\n  }\n  log.debug('SERVERLESS_EXPRESS:FORWARD_REQUEST_TO_NODE_SERVER:REQUEST_VALUES', {\n    requestValues\n  });\n  const {\n    request,\n    response\n  } = await getRequestResponse(requestValues);\n  await framework.sendRequest({\n    app,\n    request,\n    response\n  });\n  await waitForStreamComplete(response);\n  log.debug('SERVERLESS_EXPRESS:FORWARD_REQUEST_TO_NODE_SERVER:RESPONSE', {\n    response\n  });\n  forwardResponse({\n    binarySettings,\n    response,\n    resolver,\n    eventSource,\n    event,\n    log\n  });\n  return response;\n}\nmodule.exports = {\n  forwardResponse,\n  respondToEventSourceWithError,\n  forwardRequestToNodeServer,\n  getRequestResponse\n};","map":{"version":3,"names":["util","require","ServerlessRequest","ServerlessResponse","getEventSource","Response","isBinary","forwardResponse","binarySettings","response","resolver","eventSource","event","log","statusCode","headers","isBase64Encoded","encoding","body","toString","logBody","debug","successResponse","getResponse","inspect","depth","succeed","respondToEventSourceWithError","error","respondWithErrors","eventSourceName","fail","stack","errorResponse","getRequestResponse","method","remoteAddress","path","request","url","waitForStreamComplete","stream","complete","writableEnded","Promise","resolve","reject","once","isComplete","err","removeListener","forwardRequestToNodeServer","app","framework","context","eventSourceRoutes","requestValues","getRequest","sendRequest","module","exports"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/@vendia-serverless-express-npm-4.10.4-2e67e59920-f33d3f0f08.zip/node_modules/@vendia/serverless-express/src/transport.js"],"sourcesContent":["const util = require('util')\nconst ServerlessRequest = require('./request')\nconst ServerlessResponse = require('./response')\nconst { getEventSource } = require('./event-sources')\nconst Response = require('./response')\nconst isBinary = require('./is-binary')\n\nfunction forwardResponse ({\n  binarySettings,\n  response,\n  resolver,\n  eventSource,\n  event,\n  log\n}) {\n  const statusCode = response.statusCode\n  const headers = Response.headers(response)\n  const isBase64Encoded = isBinary({\n    headers,\n    binarySettings\n  })\n  const encoding = isBase64Encoded ? 'base64' : 'utf8'\n  const body = Response.body(response).toString(encoding)\n  const logBody = isBase64Encoded ? '[BASE64_ENCODED]' : body\n\n  log.debug('SERVERLESS_EXPRESS:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE_PARAMS', {\n    statusCode,\n    body: logBody,\n    headers,\n    isBase64Encoded\n  })\n\n  const successResponse = eventSource.getResponse({\n    event,\n    statusCode,\n    body,\n    headers,\n    isBase64Encoded,\n    response\n  })\n\n  log.debug('SERVERLESS_EXPRESS:FORWARD_RESPONSE:EVENT_SOURCE_RESPONSE', () => ({\n    successResponse: util.inspect(successResponse, { depth: null }),\n    body: logBody\n  }))\n\n  resolver.succeed({\n    response: successResponse\n  })\n}\n\nfunction respondToEventSourceWithError ({\n  error,\n  resolver,\n  log,\n  respondWithErrors,\n  eventSourceName,\n  eventSource\n}) {\n  log.error('SERVERLESS_EXPRESS:RESPOND_TO_EVENT_SOURCE_WITH_ERROR', error)\n\n  if (\n    eventSourceName !== 'AWS_ALB' &&\n    eventSourceName !== 'AWS_LAMBDA_EDGE' &&\n    eventSourceName !== 'AWS_API_GATEWAY_V1' &&\n    eventSourceName !== 'AWS_API_GATEWAY_V2' &&\n    eventSourceName !== 'AZURE_HTTP_FUNCTION_V3' &&\n    eventSourceName !== 'AZURE_HTTP_FUNCTION_V4'\n  ) {\n    resolver.fail({ error })\n    return\n  }\n\n  const body = respondWithErrors ? error.stack : ''\n  const errorResponse = eventSource.getResponse({\n    statusCode: 500,\n    body,\n    headers: {},\n    isBase64Encoded: false\n  })\n\n  resolver.succeed({ response: errorResponse })\n}\n\nasync function getRequestResponse ({\n  method,\n  headers,\n  body,\n  remoteAddress,\n  path\n}) {\n  const request = new ServerlessRequest({\n    method,\n    headers,\n    body,\n    remoteAddress,\n    url: path\n  })\n  await waitForStreamComplete(request)\n\n  const response = new ServerlessResponse(request)\n\n  return { request, response }\n}\n\nfunction waitForStreamComplete (stream) {\n  if (stream.complete || stream.writableEnded) {\n    return stream\n  }\n\n  return new Promise((resolve, reject) => {\n    stream.once('error', complete)\n    stream.once('end', complete)\n    stream.once('finish', complete)\n\n    let isComplete = false\n\n    function complete (err) {\n      if (isComplete) {\n        return\n      }\n\n      isComplete = true\n\n      stream.removeListener('error', complete)\n      stream.removeListener('end', complete)\n      stream.removeListener('finish', complete)\n\n      if (err) {\n        reject(err)\n      } else {\n        resolve(stream)\n      }\n    }\n  })\n}\nasync function forwardRequestToNodeServer ({\n  app,\n  framework,\n  event,\n  context,\n  resolver,\n  eventSourceName,\n  binarySettings,\n  eventSource = getEventSource({ eventSourceName }),\n  eventSourceRoutes,\n  log\n}) {\n  const requestValues = eventSource.getRequest({ event, context, log })\n\n  if (!requestValues.path && eventSourceRoutes[eventSourceName]) {\n    requestValues.path = eventSourceRoutes[eventSourceName]\n  }\n\n  log.debug('SERVERLESS_EXPRESS:FORWARD_REQUEST_TO_NODE_SERVER:REQUEST_VALUES', { requestValues })\n  const { request, response } = await getRequestResponse(requestValues)\n  await framework.sendRequest({ app, request, response })\n  await waitForStreamComplete(response)\n  log.debug('SERVERLESS_EXPRESS:FORWARD_REQUEST_TO_NODE_SERVER:RESPONSE', { response })\n  forwardResponse({\n    binarySettings,\n    response,\n    resolver,\n    eventSource,\n    event,\n    log\n  })\n  return response\n}\n\nmodule.exports = {\n  forwardResponse,\n  respondToEventSourceWithError,\n  forwardRequestToNodeServer,\n  getRequestResponse\n}\n"],"mappings":";;AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,WAAW,CAAC;AAC9C,MAAME,kBAAkB,GAAGF,OAAO,CAAC,YAAY,CAAC;AAChD,MAAM;EAAEG;AAAe,CAAC,GAAGH,OAAO,CAAC,iBAAiB,CAAC;AACrD,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMK,QAAQ,GAAGL,OAAO,CAAC,aAAa,CAAC;AAEvC,SAASM,eAAeA,CAAE;EACxBC,cAAc;EACdC,QAAQ;EACRC,QAAQ;EACRC,WAAW;EACXC,KAAK;EACLC;AACF,CAAC,EAAE;EACD,MAAMC,UAAU,GAAGL,QAAQ,CAACK,UAAU;EACtC,MAAMC,OAAO,GAAGV,QAAQ,CAACU,OAAO,CAACN,QAAQ,CAAC;EAC1C,MAAMO,eAAe,GAAGV,QAAQ,CAAC;IAC/BS,OAAO;IACPP;EACF,CAAC,CAAC;EACF,MAAMS,QAAQ,GAAGD,eAAe,GAAG,QAAQ,GAAG,MAAM;EACpD,MAAME,IAAI,GAAGb,QAAQ,CAACa,IAAI,CAACT,QAAQ,CAAC,CAACU,QAAQ,CAACF,QAAQ,CAAC;EACvD,MAAMG,OAAO,GAAGJ,eAAe,GAAG,kBAAkB,GAAGE,IAAI;EAE3DL,GAAG,CAACQ,KAAK,CAAC,kEAAkE,EAAE;IAC5EP,UAAU;IACVI,IAAI,EAAEE,OAAO;IACbL,OAAO;IACPC;EACF,CAAC,CAAC;EAEF,MAAMM,eAAe,GAAGX,WAAW,CAACY,WAAW,CAAC;IAC9CX,KAAK;IACLE,UAAU;IACVI,IAAI;IACJH,OAAO;IACPC,eAAe;IACfP;EACF,CAAC,CAAC;EAEFI,GAAG,CAACQ,KAAK,CAAC,2DAA2D,EAAE,OAAO;IAC5EC,eAAe,EAAEtB,IAAI,CAACwB,OAAO,CAACF,eAAe,EAAE;MAAEG,KAAK,EAAE;IAAK,CAAC,CAAC;IAC/DP,IAAI,EAAEE;EACR,CAAC,CAAC,CAAC;EAEHV,QAAQ,CAACgB,OAAO,CAAC;IACfjB,QAAQ,EAAEa;EACZ,CAAC,CAAC;AACJ;AAEA,SAASK,6BAA6BA,CAAE;EACtCC,KAAK;EACLlB,QAAQ;EACRG,GAAG;EACHgB,iBAAiB;EACjBC,eAAe;EACfnB;AACF,CAAC,EAAE;EACDE,GAAG,CAACe,KAAK,CAAC,uDAAuD,EAAEA,KAAK,CAAC;EAEzE,IACEE,eAAe,KAAK,SAAS,IAC7BA,eAAe,KAAK,iBAAiB,IACrCA,eAAe,KAAK,oBAAoB,IACxCA,eAAe,KAAK,oBAAoB,IACxCA,eAAe,KAAK,wBAAwB,IAC5CA,eAAe,KAAK,wBAAwB,EAC5C;IACApB,QAAQ,CAACqB,IAAI,CAAC;MAAEH;IAAM,CAAC,CAAC;IACxB;EACF;EAEA,MAAMV,IAAI,GAAGW,iBAAiB,GAAGD,KAAK,CAACI,KAAK,GAAG,EAAE;EACjD,MAAMC,aAAa,GAAGtB,WAAW,CAACY,WAAW,CAAC;IAC5CT,UAAU,EAAE,GAAG;IACfI,IAAI;IACJH,OAAO,EAAE,CAAC,CAAC;IACXC,eAAe,EAAE;EACnB,CAAC,CAAC;EAEFN,QAAQ,CAACgB,OAAO,CAAC;IAAEjB,QAAQ,EAAEwB;EAAc,CAAC,CAAC;AAC/C;AAEA,eAAeC,kBAAkBA,CAAE;EACjCC,MAAM;EACNpB,OAAO;EACPG,IAAI;EACJkB,aAAa;EACbC;AACF,CAAC,EAAE;EACD,MAAMC,OAAO,GAAG,IAAIpC,iBAAiB,CAAC;IACpCiC,MAAM;IACNpB,OAAO;IACPG,IAAI;IACJkB,aAAa;IACbG,GAAG,EAAEF;EACP,CAAC,CAAC;EACF,MAAMG,qBAAqB,CAACF,OAAO,CAAC;EAEpC,MAAM7B,QAAQ,GAAG,IAAIN,kBAAkB,CAACmC,OAAO,CAAC;EAEhD,OAAO;IAAEA,OAAO;IAAE7B;EAAS,CAAC;AAC9B;AAEA,SAAS+B,qBAAqBA,CAAEC,MAAM,EAAE;EACtC,IAAIA,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACE,aAAa,EAAE;IAC3C,OAAOF,MAAM;EACf;EAEA,OAAO,IAAIG,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtCL,MAAM,CAACM,IAAI,CAAC,OAAO,EAAEL,QAAQ,CAAC;IAC9BD,MAAM,CAACM,IAAI,CAAC,KAAK,EAAEL,QAAQ,CAAC;IAC5BD,MAAM,CAACM,IAAI,CAAC,QAAQ,EAAEL,QAAQ,CAAC;IAE/B,IAAIM,UAAU,GAAG,KAAK;IAEtB,SAASN,QAAQA,CAAEO,GAAG,EAAE;MACtB,IAAID,UAAU,EAAE;QACd;MACF;MAEAA,UAAU,GAAG,IAAI;MAEjBP,MAAM,CAACS,cAAc,CAAC,OAAO,EAAER,QAAQ,CAAC;MACxCD,MAAM,CAACS,cAAc,CAAC,KAAK,EAAER,QAAQ,CAAC;MACtCD,MAAM,CAACS,cAAc,CAAC,QAAQ,EAAER,QAAQ,CAAC;MAEzC,IAAIO,GAAG,EAAE;QACPH,MAAM,CAACG,GAAG,CAAC;MACb,CAAC,MAAM;QACLJ,OAAO,CAACJ,MAAM,CAAC;MACjB;IACF;EACF,CAAC,CAAC;AACJ;AACA,eAAeU,0BAA0BA,CAAE;EACzCC,GAAG;EACHC,SAAS;EACTzC,KAAK;EACL0C,OAAO;EACP5C,QAAQ;EACRoB,eAAe;EACftB,cAAc;EACdG,WAAW,GAAGP,cAAc,CAAC;IAAE0B;EAAgB,CAAC,CAAC;EACjDyB,iBAAiB;EACjB1C;AACF,CAAC,EAAE;EACD,MAAM2C,aAAa,GAAG7C,WAAW,CAAC8C,UAAU,CAAC;IAAE7C,KAAK;IAAE0C,OAAO;IAAEzC;EAAI,CAAC,CAAC;EAErE,IAAI,CAAC2C,aAAa,CAACnB,IAAI,IAAIkB,iBAAiB,CAACzB,eAAe,CAAC,EAAE;IAC7D0B,aAAa,CAACnB,IAAI,GAAGkB,iBAAiB,CAACzB,eAAe,CAAC;EACzD;EAEAjB,GAAG,CAACQ,KAAK,CAAC,kEAAkE,EAAE;IAAEmC;EAAc,CAAC,CAAC;EAChG,MAAM;IAAElB,OAAO;IAAE7B;EAAS,CAAC,GAAG,MAAMyB,kBAAkB,CAACsB,aAAa,CAAC;EACrE,MAAMH,SAAS,CAACK,WAAW,CAAC;IAAEN,GAAG;IAAEd,OAAO;IAAE7B;EAAS,CAAC,CAAC;EACvD,MAAM+B,qBAAqB,CAAC/B,QAAQ,CAAC;EACrCI,GAAG,CAACQ,KAAK,CAAC,4DAA4D,EAAE;IAAEZ;EAAS,CAAC,CAAC;EACrFF,eAAe,CAAC;IACdC,cAAc;IACdC,QAAQ;IACRC,QAAQ;IACRC,WAAW;IACXC,KAAK;IACLC;EACF,CAAC,CAAC;EACF,OAAOJ,QAAQ;AACjB;AAEAkD,MAAM,CAACC,OAAO,GAAG;EACfrD,eAAe;EACfoB,6BAA6B;EAC7BwB,0BAA0B;EAC1BjB;AACF,CAAC"},"metadata":{},"sourceType":"module"}