{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"./utils\");\n// Parse the attributes and verify valid types\nexports.default = (attrs, partitionKey, sortKey) => Object.keys(attrs).reduce((acc, field) => {\n  if (typeof attrs[field] === 'string') {\n    // TODO: Calling .toString() to satisfy TS even though I'm type checking\n    // Error if invalid key type\n    if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(attrs[field].toString())) {\n      utils_1.keyTypeError(field);\n    }\n    // Error if invalid type\n    if (!utils_1.validTypes.includes(attrs[field].toString())) {\n      utils_1.typeError(field);\n    }\n    // Merge and return parsed attribute\n    return Object.assign(acc, parseAttributeConfig(field, {\n      type: attrs[field]\n    }));\n  } else {\n    // TODO: Is there a better way to do this without casting this value?\n    const fieldVal = attrs[field];\n    // Error if invalid key type\n    if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(fieldVal.type)) {\n      utils_1.keyTypeError(field);\n    }\n    // Error if invalid type\n    if (!utils_1.validTypes.includes(fieldVal.type)) {\n      utils_1.typeError(field);\n    }\n    // Merge and return parsed attribute\n    return Object.assign(acc, parseAttributeConfig(field, fieldVal));\n  } // end else\n}, {});\n// Parse and validate attributes config\nconst parseAttributeConfig = (field, config) => {\n  // Validate props\n  Object.keys(config).forEach(prop => {\n    switch (prop) {\n      case 'type':\n        break;\n      case 'setType':\n        if (config.type !== 'set') utils_1.error(`'setType' is only valid for type 'set'`);\n        if (!['string', 'number', 'binary'].includes(config[prop])) utils_1.error(`Invalid 'setType', must be 'string', 'number', or 'binary'`);\n        break;\n      default:\n        utils_1.error(`'${prop}' is not a valid property type`);\n    }\n  });\n  return {\n    [field]: Object.assign(Object.assign({}, config), {\n      mappings: {}\n    })\n  };\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","default","attrs","partitionKey","sortKey","keys","reduce","acc","field","includes","validKeyTypes","toString","keyTypeError","validTypes","typeError","assign","parseAttributeConfig","type","fieldVal","config","forEach","prop","error","mappings"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/parseTableAttributes.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// Parse the attributes and verify valid types\nexports.default = (attrs, partitionKey, sortKey) => Object.keys(attrs).reduce((acc, field) => {\n    if (typeof attrs[field] === 'string') {\n        // TODO: Calling .toString() to satisfy TS even though I'm type checking\n        // Error if invalid key type\n        if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(attrs[field].toString())) {\n            utils_1.keyTypeError(field);\n        }\n        // Error if invalid type\n        if (!utils_1.validTypes.includes(attrs[field].toString())) {\n            utils_1.typeError(field);\n        }\n        // Merge and return parsed attribute\n        return Object.assign(acc, parseAttributeConfig(field, { type: attrs[field] }));\n    }\n    else {\n        // TODO: Is there a better way to do this without casting this value?\n        const fieldVal = attrs[field];\n        // Error if invalid key type\n        if ([partitionKey, sortKey].includes(field) && !utils_1.validKeyTypes.includes(fieldVal.type)) {\n            utils_1.keyTypeError(field);\n        }\n        // Error if invalid type\n        if (!utils_1.validTypes.includes(fieldVal.type)) {\n            utils_1.typeError(field);\n        }\n        // Merge and return parsed attribute\n        return Object.assign(acc, parseAttributeConfig(field, fieldVal));\n    } // end else\n}, {});\n// Parse and validate attributes config\nconst parseAttributeConfig = (field, config) => {\n    // Validate props\n    Object.keys(config).forEach(prop => {\n        switch (prop) {\n            case 'type':\n                break;\n            case 'setType':\n                if (config.type !== 'set')\n                    utils_1.error(`'setType' is only valid for type 'set'`);\n                if (!['string', 'number', 'binary'].includes(config[prop]))\n                    utils_1.error(`Invalid 'setType', must be 'string', 'number', or 'binary'`);\n                break;\n            default:\n                utils_1.error(`'${prop}' is not a valid property type`);\n        }\n    });\n    return {\n        [field]: Object.assign(Object.assign({}, config), { mappings: {} })\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}