{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeDirective = exports.mergeDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction isRepeatableDirective(directive, directives) {\n  var _a;\n  return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);\n}\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(({\n    value\n  }) => value === name.value);\n}\nfunction mergeArguments(a1, a2) {\n  const result = [...a2];\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values;\n        // merge values of two lists\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n  return result;\n}\nfunction deduplicateDirectives(directives, definitions) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n    if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments(directive.arguments, dup.arguments);\n      return null;\n    }\n    return directive;\n  }).filter(utils_1.isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config, directives) {\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext], directives);\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n  return result;\n}\nexports.mergeDirectives = mergeDirectives;\nfunction validateInputs(node, existingNode) {\n  const printedNode = (0, graphql_1.print)({\n    ...node,\n    description: undefined\n  });\n  const printedExistingNode = (0, graphql_1.print)({\n    ...existingNode,\n    description: undefined\n  });\n  // eslint-disable-next-line\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return {\n      ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n  return node;\n}\nexports.mergeDirective = mergeDirective;\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeDirective","mergeDirectives","graphql_1","require","utils_1","directiveAlreadyExists","directivesArr","otherDirective","find","directive","name","isRepeatableDirective","directives","_a","repeatable","nameAlreadyExists","namesArr","some","mergeArguments","a1","a2","result","argument","existingIndex","findIndex","a","existingArg","kind","source","values","target","deduplicateLists","targetVal","sourceVal","push","deduplicateDirectives","definitions","map","i","all","firstAt","d","dup","arguments","filter","isSome","d1","d2","config","reverseOrder","reverseDirectives","asNext","asFirst","existingDirectiveIndex","existingDirective","validateInputs","node","existingNode","printedNode","print","description","undefined","printedExistingNode","leaveInputs","RegExp","sameArguments","replace","Error","locations","filterFn","concat","val"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/__virtual__/@graphql-tools-merge-virtual-3bffd3f135/0/cache/@graphql-tools-merge-npm-8.4.2-26df56fe04-96d57a3e81.zip/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeDirective = exports.mergeDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction isRepeatableDirective(directive, directives) {\n    var _a;\n    return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives, definitions) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(utils_1.isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config, directives) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext], directives);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nexports.mergeDirectives = mergeDirectives;\nfunction validateInputs(node, existingNode) {\n    const printedNode = (0, graphql_1.print)({\n        ...node,\n        description: undefined,\n    });\n    const printedExistingNode = (0, graphql_1.print)({\n        ...existingNode,\n        description: undefined,\n    });\n    // eslint-disable-next-line\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nexports.mergeDirective = mergeDirective;\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}