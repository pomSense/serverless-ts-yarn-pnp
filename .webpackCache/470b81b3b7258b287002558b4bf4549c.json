{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTable = void 0;\n// Import libraries, types, and classes\nconst parseTableAttributes_1 = __importDefault(require(\"./parseTableAttributes\"));\nconst utils_1 = require(\"./utils\");\n// Parse table\nconst parseTable = table => {\n  let {\n      name,\n      // Table name\n      alias,\n      // For batch references\n      partitionKey,\n      sortKey,\n      entityField,\n      attributes,\n      indexes,\n      autoExecute,\n      autoParse,\n      removeNullAttributes,\n      entities,\n      DocumentClient\n    } = table,\n    args = __rest(table\n    // Error on extraneous arguments\n    , [\"name\", \"alias\", \"partitionKey\", \"sortKey\", \"entityField\", \"attributes\", \"indexes\", \"autoExecute\", \"autoParse\", \"removeNullAttributes\", \"entities\", \"DocumentClient\"]) // extraneous config\n  ;\n  // Error on extraneous arguments\n  if (Object.keys(args).length > 0) utils_1.error(`Invalid Table configuration options: ${Object.keys(args).join(', ')}`);\n  // Table name\n  name = typeof name === 'string' && name.trim().length > 0 ? name.trim() : utils_1.error(`'name' must be defined`);\n  // Verify alias\n  alias = typeof alias === 'string' && alias.trim().length > 0 ? alias.trim() : alias ? utils_1.error(`'alias' must be a string value`) : null;\n  // Specify partitionKey attribute\n  partitionKey = typeof partitionKey === 'string' && partitionKey.trim().length > 0 ? partitionKey.trim() : utils_1.error(`'partitionKey' must be defined`);\n  // Specify sortKey attribute (optional)\n  sortKey = typeof sortKey === 'string' && sortKey.trim().length > 0 ? sortKey.trim() : sortKey ? utils_1.error(`'sortKey' must be a string value`) : null;\n  // Disable, or rename field for entity tracking\n  entityField = entityField === false ? false : typeof entityField === 'string' && entityField.trim().length > 0 ? entityField.trim() : '_et';\n  // Parse table attributes\n  attributes = utils_1.hasValue(attributes) && typeof attributes === 'object' && !Array.isArray(attributes) ? attributes : attributes ? utils_1.error(`Please provide a valid 'attributes' object`) : {};\n  // Add entityField to attributes\n  if (entityField) attributes[entityField] = 'string';\n  // Parse indexes (optional)\n  indexes = utils_1.hasValue(indexes) && typeof indexes === 'object' && !Array.isArray(indexes) ? parseIndexes(indexes, partitionKey) : indexes ? utils_1.error(`Please provide a valid 'indexes' object`) : {};\n  // Return the table\n  return Object.assign({\n    name,\n    alias,\n    Table: {\n      partitionKey,\n      sortKey,\n      entityField,\n      attributes: parseTableAttributes_1.default(attributes, partitionKey, sortKey),\n      indexes\n    },\n    autoExecute,\n    autoParse,\n    removeNullAttributes,\n    _entities: [] // init Entity tracker\n  }, DocumentClient ? {\n    DocumentClient\n  } : {},\n  // end DocumentClient\n  entities ? {\n    entities\n  } : {} // end entities\n  );\n}; // end parseTable\nexports.parseTable = parseTable;\n// Parse Indexes\nconst parseIndexes = (indexes, pk) => Object.keys(indexes).reduce((acc, index) => {\n  // TODO: indexes can not be named TABLE\n  // Destructure the index\n  const _a = indexes[index],\n    {\n      partitionKey,\n      sortKey\n    } = _a,\n    args = __rest(_a, [\"partitionKey\", \"sortKey\"]);\n  // Error on extraneous arguments\n  if (Object.keys(args).length > 0) utils_1.error(`Invalid index options: ${Object.keys(args).join(', ')}`);\n  // Verify partitionKey\n  if (partitionKey && typeof partitionKey !== 'string') utils_1.error(`'partitionKey' for ${index} must be a string`);\n  // Verify sortKey\n  if (sortKey && typeof sortKey !== 'string') utils_1.error(`'sortKey' for ${index} must be a string`);\n  // Verify the presences of either pk or sk\n  if (!sortKey && !partitionKey) utils_1.error(`A 'partitionKey', 'sortKey' or both, must be provided for ${index}`);\n  // Guess index type\n  const type = !partitionKey || partitionKey === pk ? 'LSI' : 'GSI';\n  // Return the structured index object\n  return Object.assign(acc, {\n    [index]: Object.assign({}, partitionKey && type === 'GSI' ? {\n      partitionKey\n    } : {}, sortKey ? {\n      sortKey\n    } : {}, {\n      type\n    }) // end\n  });\n}, {});\nexports.default = exports.parseTable;","map":{"version":3,"names":["__rest","undefined","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__importDefault","mod","__esModule","defineProperty","exports","value","parseTable","parseTableAttributes_1","require","utils_1","table","name","alias","partitionKey","sortKey","entityField","attributes","indexes","autoExecute","autoParse","removeNullAttributes","entities","DocumentClient","args","keys","error","join","trim","hasValue","Array","isArray","parseIndexes","assign","Table","default","_entities","pk","reduce","acc","index","_a","type"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/parseTable.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTable = void 0;\n// Import libraries, types, and classes\nconst parseTableAttributes_1 = __importDefault(require(\"./parseTableAttributes\"));\nconst utils_1 = require(\"./utils\");\n// Parse table\nconst parseTable = (table) => {\n    let { name, // Table name\n    alias, // For batch references\n    partitionKey, sortKey, entityField, attributes, indexes, autoExecute, autoParse, removeNullAttributes, entities, DocumentClient } = table, args = __rest(table\n    // Error on extraneous arguments\n    , [\"name\", \"alias\", \"partitionKey\", \"sortKey\", \"entityField\", \"attributes\", \"indexes\", \"autoExecute\", \"autoParse\", \"removeNullAttributes\", \"entities\", \"DocumentClient\"]) // extraneous config\n    ;\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0)\n        utils_1.error(`Invalid Table configuration options: ${Object.keys(args).join(', ')}`);\n    // Table name\n    name = typeof name === 'string' && name.trim().length > 0 ? name.trim()\n        : utils_1.error(`'name' must be defined`);\n    // Verify alias\n    alias = typeof alias === 'string'\n        && alias.trim().length > 0 ? alias.trim()\n        : alias ? utils_1.error(`'alias' must be a string value`)\n            : null;\n    // Specify partitionKey attribute\n    partitionKey = typeof partitionKey === 'string'\n        && partitionKey.trim().length > 0 ? partitionKey.trim()\n        : utils_1.error(`'partitionKey' must be defined`);\n    // Specify sortKey attribute (optional)\n    sortKey = typeof sortKey === 'string'\n        && sortKey.trim().length > 0 ? sortKey.trim()\n        : sortKey ? utils_1.error(`'sortKey' must be a string value`)\n            : null;\n    // Disable, or rename field for entity tracking\n    entityField = entityField === false ? false\n        : typeof entityField === 'string' && entityField.trim().length > 0 ?\n            entityField.trim()\n            : '_et';\n    // Parse table attributes\n    attributes = utils_1.hasValue(attributes) && typeof attributes === 'object' && !Array.isArray(attributes) ?\n        attributes\n        : attributes ? utils_1.error(`Please provide a valid 'attributes' object`)\n            : {};\n    // Add entityField to attributes\n    if (entityField)\n        attributes[entityField] = 'string';\n    // Parse indexes (optional)\n    indexes = utils_1.hasValue(indexes) && typeof indexes === 'object' && !Array.isArray(indexes) ?\n        parseIndexes(indexes, partitionKey)\n        : indexes ? utils_1.error(`Please provide a valid 'indexes' object`)\n            : {};\n    // Return the table\n    return Object.assign({\n        name,\n        alias,\n        Table: {\n            partitionKey,\n            sortKey,\n            entityField,\n            attributes: parseTableAttributes_1.default(attributes, partitionKey, sortKey),\n            indexes\n        },\n        autoExecute,\n        autoParse,\n        removeNullAttributes,\n        _entities: [] // init Entity tracker\n    }, DocumentClient ? { DocumentClient } : {}, // end DocumentClient\n    entities ? { entities } : {} // end entities\n    );\n}; // end parseTable\nexports.parseTable = parseTable;\n// Parse Indexes\nconst parseIndexes = (indexes, pk) => Object.keys(indexes).reduce((acc, index) => {\n    // TODO: indexes can not be named TABLE\n    // Destructure the index\n    const _a = indexes[index], { partitionKey, sortKey } = _a, args = __rest(_a, [\"partitionKey\", \"sortKey\"]);\n    // Error on extraneous arguments\n    if (Object.keys(args).length > 0)\n        utils_1.error(`Invalid index options: ${Object.keys(args).join(', ')}`);\n    // Verify partitionKey\n    if (partitionKey && typeof partitionKey !== 'string')\n        utils_1.error(`'partitionKey' for ${index} must be a string`);\n    // Verify sortKey\n    if (sortKey && typeof sortKey !== 'string')\n        utils_1.error(`'sortKey' for ${index} must be a string`);\n    // Verify the presences of either pk or sk\n    if (!sortKey && !partitionKey)\n        utils_1.error(`A 'partitionKey', 'sortKey' or both, must be provided for ${index}`);\n    // Guess index type\n    const type = !partitionKey || partitionKey === pk ? 'LSI' : 'GSI';\n    // Return the structured index object\n    return Object.assign(acc, {\n        [index]: Object.assign({}, partitionKey && type === 'GSI' ? { partitionKey } : {}, sortKey ? { sortKey } : {}, { type }) // end\n    });\n}, {});\nexports.default = exports.parseTable;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}