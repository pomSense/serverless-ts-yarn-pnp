{"ast":null,"code":"\"use strict\";\n\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __importDefault = undefined && undefined.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst validateTypes_1 = __importDefault(require(\"./validateTypes\"));\nconst utils_1 = require(\"./utils\");\n// Normalize Data\nexports.default = DocumentClient => (schema, linked, data, filter = false) => {\n  // Intialize validate type\n  const validateType = validateTypes_1.default(DocumentClient);\n  // Build and execute defaults dependency graph\n  const dependsOn = (map, attr) => {\n    // If the default depends on other attributes\n    if (schema[attr].dependsOn) {\n      (Array.isArray(schema[attr].dependsOn) ? schema[attr].dependsOn : [schema[attr].dependsOn]).forEach(dependent => {\n        // If the dependent is a valid attribute or alias\n        if (schema[dependent]) {\n          // If the dependent is a function\n          if (typeof map[dependent] === 'function') {\n            // Resolve the dependency graph\n            map = dependsOn(map, dependent);\n          }\n        } else {\n          utils_1.error(`'${dependent}' is not a valid attribute or alias name`);\n        }\n      }); // end dependency loop\n      map[attr] = map[attr](map);\n      return map;\n    } else {\n      try {\n        map[attr] = map[attr](map);\n        if (schema[attr].alias) map[schema[attr].alias] = map[attr];\n        if (schema[attr].map) map[schema[attr].map] = map[attr];\n      } catch (e) {\n        // TODO: Find a better way to prevent this for missing fields\n      }\n      return map;\n    }\n  }; // end dependsOn\n  // Generate normalized data object\n  let dataMap = Object.keys(data).reduce((acc, field) => {\n    // Return a map with normalized data and alias references\n    return Object.assign(acc, schema[field] ? {\n      data: Object.assign(Object.assign({}, acc.data), {\n        [schema[field].map || field]: data[field]\n      }),\n      aliases: Object.assign(Object.assign({}, acc.aliases), {\n        [schema[field].alias || field]: data[field]\n      })\n    } : filter ? {} // this will filter out non-mapped fields\n    : field === '$remove' ? {\n      data: Object.assign(Object.assign({}, acc.data), {\n        $remove: data[field]\n      })\n    } // support for removes\n    : utils_1.error(`Field '${field}' does not have a mapping or alias`));\n  }, {\n    data: {},\n    aliases: {}\n  });\n  // Create a combined data object for defaults\n  let defaultMap = Object.assign(Object.assign({}, dataMap.data), dataMap.aliases);\n  const defaults = Object.keys(defaultMap).reduce((acc, attr) => {\n    // If a function, resolve the dependency graph\n    if (typeof defaultMap[attr] === 'function') {\n      let map = dependsOn(defaultMap, attr);\n      defaultMap = map;\n    }\n    return Object.assign(acc, {\n      [attr]: defaultMap[attr]\n    });\n  }, {});\n  // Generate final data and evaluate function expressions\n  let _data = Object.keys(dataMap.data).reduce((acc, field) => {\n    return Object.assign(acc, {\n      [field]: defaults[field]\n    });\n  }, {});\n  // Process linked\n  let composites = Object.keys(linked).reduce((acc, attr) => {\n    // Convert field to mapped field\n    const field = schema[attr] && schema[attr].map || attr;\n    if (_data[field] !== undefined) return acc; // if value exists, let override\n    let values = linked[attr].map(f => {\n      if (_data[f] === undefined) {\n        return null;\n      }\n      return utils_1.transformAttr(schema[f], validateType(schema[f], f, _data[f]), _data);\n    }).filter(x => x !== null);\n    // TODO: add required fields\n    // if (values.length > 0 && values.length !== linked[field].length) {\n    //   error(`${linked[field].join(', ')} are all required for composite key`)\n    // } else  \n    if (values.length === linked[attr].length) {\n      return Object.assign(acc, {\n        //[field]: `${schema[attr].prefix || ''}${values.join(schema[attr].delimiter || '#')}${schema[attr].suffix || ''}`\n        [field]: values.join(schema[attr].delimiter || '#')\n      });\n    } else {\n      return acc;\n    }\n  }, {});\n  // Return the merged data\n  return Object.assign(composites, _data);\n}; // end normalizeData\n// Generate final data and evaluate function expressions\n// let _data = Object.keys(dataMap.data).reduce((acc,field) => {\n//   return Object.assign(acc, { \n//     [field]: typeof dataMap.data[field] === 'function' ? dataMap.data[field](defaults) : dataMap.data[field]\n//   })\n// },{})\n// console.log(_data)\n// map[schema[attr].dependsOn] = typeof map[schema[attr].dependsOn] === 'function' ? \n//   dependsOn(map,schema[attr].dependsOn) // map[schema[attr].dependsOn](map) \n//   : map[schema[attr].dependsOn]\n// return { map, val: map[attr](map) }\n// return dependsOn(map,attr)","map":{"version":3,"names":["__importDefault","undefined","mod","__esModule","Object","defineProperty","exports","value","validateTypes_1","require","utils_1","default","DocumentClient","schema","linked","data","filter","validateType","dependsOn","map","attr","Array","isArray","forEach","dependent","error","alias","e","dataMap","keys","reduce","acc","field","assign","aliases","$remove","defaultMap","defaults","_data","composites","values","f","transformAttr","x","length","join","delimiter"],"sources":["/Users/pom/Code/serverless-ts-yarn-pnp/.yarn/cache/dynamodb-toolbox-npm-0.3.5-3ff4bf5328-d75542b529.zip/node_modules/dynamodb-toolbox/dist/lib/normalizeData.js"],"sourcesContent":["\"use strict\";\n/**\n * DynamoDB Toolbox: A simple set of tools for working with Amazon DynamoDB\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @license MIT\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validateTypes_1 = __importDefault(require(\"./validateTypes\"));\nconst utils_1 = require(\"./utils\");\n// Normalize Data\nexports.default = (DocumentClient) => (schema, linked, data, filter = false) => {\n    // Intialize validate type\n    const validateType = validateTypes_1.default(DocumentClient);\n    // Build and execute defaults dependency graph\n    const dependsOn = (map, attr) => {\n        // If the default depends on other attributes\n        if (schema[attr].dependsOn) {\n            (Array.isArray(schema[attr].dependsOn) ? schema[attr].dependsOn : [schema[attr].dependsOn]).forEach((dependent) => {\n                // If the dependent is a valid attribute or alias\n                if (schema[dependent]) {\n                    // If the dependent is a function\n                    if (typeof map[dependent] === 'function') {\n                        // Resolve the dependency graph\n                        map = dependsOn(map, dependent);\n                    }\n                }\n                else {\n                    utils_1.error(`'${dependent}' is not a valid attribute or alias name`);\n                }\n            }); // end dependency loop\n            map[attr] = map[attr](map);\n            return map;\n        }\n        else {\n            try {\n                map[attr] = map[attr](map);\n                if (schema[attr].alias)\n                    map[schema[attr].alias] = map[attr];\n                if (schema[attr].map)\n                    map[schema[attr].map] = map[attr];\n            }\n            catch (e) {\n                // TODO: Find a better way to prevent this for missing fields\n            }\n            return map;\n        }\n    }; // end dependsOn\n    // Generate normalized data object\n    let dataMap = Object.keys(data).reduce((acc, field) => {\n        // Return a map with normalized data and alias references\n        return Object.assign(acc, schema[field] ? {\n            data: Object.assign(Object.assign({}, acc.data), { [schema[field].map || field]: data[field] }),\n            aliases: Object.assign(Object.assign({}, acc.aliases), { [schema[field].alias || field]: data[field] })\n        }\n            : filter ? {} // this will filter out non-mapped fields\n                : field === '$remove' ? { data: Object.assign(Object.assign({}, acc.data), { $remove: data[field] }) } // support for removes\n                    : utils_1.error(`Field '${field}' does not have a mapping or alias`));\n    }, { data: {}, aliases: {} });\n    // Create a combined data object for defaults\n    let defaultMap = Object.assign(Object.assign({}, dataMap.data), dataMap.aliases);\n    const defaults = Object.keys(defaultMap).reduce((acc, attr) => {\n        // If a function, resolve the dependency graph\n        if (typeof defaultMap[attr] === 'function') {\n            let map = dependsOn(defaultMap, attr);\n            defaultMap = map;\n        }\n        return Object.assign(acc, { [attr]: defaultMap[attr] });\n    }, {});\n    // Generate final data and evaluate function expressions\n    let _data = Object.keys(dataMap.data).reduce((acc, field) => {\n        return Object.assign(acc, {\n            [field]: defaults[field]\n        });\n    }, {});\n    // Process linked\n    let composites = Object.keys(linked).reduce((acc, attr) => {\n        // Convert field to mapped field\n        const field = (schema[attr] && schema[attr].map) || attr;\n        if (_data[field] !== undefined)\n            return acc; // if value exists, let override\n        let values = linked[attr].map((f) => {\n            if (_data[f] === undefined) {\n                return null;\n            }\n            return utils_1.transformAttr(schema[f], validateType(schema[f], f, _data[f]), _data);\n        }).filter((x) => x !== null);\n        // TODO: add required fields\n        // if (values.length > 0 && values.length !== linked[field].length) {\n        //   error(`${linked[field].join(', ')} are all required for composite key`)\n        // } else  \n        if (values.length === linked[attr].length) {\n            return Object.assign(acc, {\n                //[field]: `${schema[attr].prefix || ''}${values.join(schema[attr].delimiter || '#')}${schema[attr].suffix || ''}`\n                [field]: values.join(schema[attr].delimiter || '#')\n            });\n        }\n        else {\n            return acc;\n        }\n    }, {});\n    // Return the merged data\n    return Object.assign(composites, _data);\n}; // end normalizeData\n// Generate final data and evaluate function expressions\n// let _data = Object.keys(dataMap.data).reduce((acc,field) => {\n//   return Object.assign(acc, { \n//     [field]: typeof dataMap.data[field] === 'function' ? dataMap.data[field](defaults) : dataMap.data[field]\n//   })\n// },{})\n// console.log(_data)\n// map[schema[attr].dependsOn] = typeof map[schema[attr].dependsOn] === 'function' ? \n//   dependsOn(map,schema[attr].dependsOn) // map[schema[attr].dependsOn](map) \n//   : map[schema[attr].dependsOn]\n// return { map, val: map[attr](map) }\n// return dependsOn(map,attr)\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}